<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于5G通信的定位感知——AOA解算</title>
    <link href="/2025/04/24/AOA_Positioning/"/>
    <url>/2025/04/24/AOA_Positioning/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><em><strong>5G-NR</strong></em>，具有⾼速、低延迟的特性，是现代通信强有⼒的技术之一。又因广泛的基站建设，5G逐渐覆盖日常生活中的每个角落，随着覆盖范围的扩张，不仅意味着越来越稳定的通信，感知，更是随之不断的发展。</p><p>下⾯，本文将针对无人机向5G基站通信这一应用场景，尝试通过仿真验证利用无人机与5G基站的通信能够实现利用 <em><strong>CSI</strong></em> 解算出无人机的位置信息，如 <em><strong>AOA、AOD、ToF</strong></em> 等参数，验证 <em><strong>MUSIC</strong></em> 算法的可行性。下面是对如何通过通信的 <em><strong>CSI</strong></em> 实现对位置信息感知的理论描述。</p><h1 id="理论篇"><a href="#理论篇" class="headerlink" title="理论篇"></a>理论篇</h1><h2 id="信号在发送端天线的传播特性"><a href="#信号在发送端天线的传播特性" class="headerlink" title="信号在发送端天线的传播特性"></a>信号在发送端天线的传播特性</h2><p>发送端（无人机）仅考虑单根天线进行收发，且天线是全向极化天线。信号由无人机发出，向四面八方发送信号，这些信号在Tx天线处发出时对应的角度我们称为 <em><strong>AOD（Angle of Departure）</strong></em>。在 <em><strong>Tx</strong></em> 处的AOD有很多不同的值，我们近似认为范围为 <em><strong>[0, 2*pi]</strong></em>。</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250425123140384.png" alt="无人机发送天线"></p><p>由于发送端 —&gt; 接收端的距离很远，信号在信道中传输之后在到达5G基站的天线阵列时，我们近似认为这些信号可以被视为平⾏波。</p><h2 id="接收端天线阵列接收信号"><a href="#接收端天线阵列接收信号" class="headerlink" title="接收端天线阵列接收信号"></a>接收端天线阵列接收信号</h2><p>由于信号在信道中传递有多径特性，其中某⼀个单径上的信号在到达天线阵列时可以被视为⼀组平⾏波。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250425123346494.png" alt="接收天线阵列"></p><p>下面我们仅考虑某一个单径上的信号，这个信号以一组平行波的形式被接收端的天线阵列接收。作⼀条垂直于平⾏波的虚线，我们可以近似认为它与这一组平⾏波的交点所对应的信号相位相同，即这个虚线是一个等相线。由上图可⻅相邻两根天线之间信号传播距离相差 <em><strong>L</strong></em>，又因为波⻓与相应间存在某种关系，我们可以理解为，传播的距离差 <em><strong>L</strong></em> 等价于信号到达天线的相位差 <em><strong>φ</strong></em>。因此可以说,相邻两概天线在同时接收到的信号之间差⼀个恒定的 <em><strong>φ</strong></em> 。以另⼀个⻆度上说，同时接收 <em><strong>N</strong></em> 个天线上的信号且相邻信号之间差⼀个 <em><strong>φ</strong></em>，那么我们可以压缩天线，我只对第⼀根天线接收的信号采样，采样间隔 <em><strong>t &#x3D; L&#x2F;c &#x3D; φ&#x2F;f</strong></em> （ <em><strong>c</strong></em> 是光速，<em><strong>f</strong></em> 是信号的频率）。</p><p>以第⼀根天线接收的信号为基准定义为 <em><strong>S0 &#x3D; exp(j*2*pi*d*cosx)</strong></em>,如此其余天线接收的信号就能够定义为 <em><strong>Sk &#x3D; exp(j*2*pi*k*d*cosx) &#x3D; （exp(j*2*pi*d*cosx)）^k</strong></em> 等等，第k根天线的信号是第一根天线的k次方，又因为第k根天线相较于第一根天线有 <em><strong>k * d</strong></em> 的距离差，表现在信号上有k次方的关系，于是我们认为，第k根天线相较于第一根天线有 <em><strong>φ^k</strong></em> 的相位延迟。若我们定义第一根天线没有延迟，那么我们就可以写出第一条单径对应信号的导向矢量</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250425123744616.png" alt="导向矢量"></p><p>又因为多径，不同AOA的信号同时到达接收天线阵列，彼此叠加。所以我们在天线处采样得到的信号，是K个不同AOA路径信号的叠加。我们多次进行采样，一共采样 <em><strong>M</strong></em> 次就可以得到 <em><strong>MxN</strong></em> 的导向矩阵。</p><p>又因为每个列向量（导向矢量）的元素之间是成指数递增的关系，因此根据矩阵论的相关知识，该导向矩阵是满秩的。</p><h2 id="AOA解算"><a href="#AOA解算" class="headerlink" title="AOA解算"></a>AOA解算</h2><p>这里我们假设一共有一根 <em><strong>Tx</strong></em> ，3根 <em><strong>Rx</strong></em>，这里我们考虑两条多径（一条直射、一条反射）。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250425123355885.png" alt="多径模型"></p><p>对天线上接收的信号进行采样，每一次采样计算出来的导向矢量是由两条路径对应不同的导向矢量叠加得到。我们多次进行采样，这些采样得到的所有导向矢量构成一个导向矩阵，该导向矩阵一定是满秩的。</p><p>每一个导向矢量，xyz三个坐标，对应在一个三维空间中的一个位置，采样了 <em><strong>m</strong></em> 次，则一共有 <em><strong>m</strong></em> 个三维空间中的矢量，每一个矢量又是由两条路径对应的导向矢量通过平行四边形法则叠加得到。两条路径的导向矢量不同是因为不同路径到达接收天线阵列的AOA不同，因此导向矢量也不同。我们可以假设，如果有无数条路径，这些路径对应的AOA也不同，意味着有无数条不同的导向矢量，这些导向矢量的末端连起来必然是一个封闭的空间曲线（因为AOA有界）。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250425123406300.png" alt="空间封闭曲线"></p><p>已知每一个导向矢量对应一个AOA，导向矢量的模长受到对应信道时变衰落的影响，因此每一个导向矢量是对应方向延长线上的点。由于不同AOA的信号在天线处叠加，采样得到的导向矢量对应在空间中是不同AOA导向矢量的加权（信道衰落）和。</p><p>如果每次采样的信号是由两个多径信号叠加，那么采样信号的导向矢量就是这两个多径信号的导向矢量加权和。又两个向量可以张成一个二维的平面（子空间），我们称这个子空间为 <strong>信号子空间</strong>。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250425123415468.png" alt="信号子空间"></p><p>假设你的信道中没有噪声，那么我们可以推断出，无论采样多少次，每次采样的信号对应的导向矢量一定属于这个信号子空间。<em><strong>n</strong></em> 条路径 <em><strong>m</strong></em> 根接收天线对应的信号子空间维数为 <em><strong>R_min &#x3D; min(n, m)</strong></em>。因为信号子空间的维数一定小于或者等于整个导向矢量的空间维数，因此一定可以找到一个垂直于信号子空间的基，这个基对应的空间我们称为 <strong>噪声子空间</strong>。如果你的信道中有噪声，你的导向矢量在空间中表现为在垂直信号子空间的方向上有一定的偏移</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250425123421082.png" alt="正交噪声子空间"></p><h2 id="实际解算过程"><a href="#实际解算过程" class="headerlink" title="实际解算过程"></a>实际解算过程</h2><ol><li><p>同时对 <em><strong>N</strong></em> 个天线阵元采样得第⼀个导向矢量；多次采样得 <em><strong>M</strong></em> 个导向矢量；每一个导向矢量是来自 <em><strong>K</strong></em> 个路径的信号叠加（每个路径的AOA不同）。</p></li><li><p>得到导向矢量矩阵 <em><strong>A &#x3D; [P_1, P_2, …, P_n]</strong></em> ，矩阵的形状为 <em><strong>M x N</strong></em> 且一定是满秩的，信号子空间为维度为天线阵元数量与多径数量中的较小值。假设信号子空间为 <em><strong>K</strong></em> 维，导向矢量的空间维度为 <em><strong>N</strong></em> 维，对导向矢量矩阵做特征值分解，能够得到 <em><strong>N</strong></em> 个特征矢量，其中 <em><strong>K</strong></em> 个构成了信号子空间，也对应着 <em><strong>K</strong></em> 个多径各自的 <em><strong>AOA</strong></em>。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>5G 通感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读札记——“5G信道的估计与均衡”</title>
    <link href="/2025/04/02/Channel-state-info/"/>
    <url>/2025/04/02/Channel-state-info/</url>
    
    <content type="html"><![CDATA[<h1 id="5G通信信道估计"><a href="#5G通信信道估计" class="headerlink" title="5G通信信道估计"></a>5G通信信道估计</h1><h2 id="一、MIMO——OFDM技术简介"><a href="#一、MIMO——OFDM技术简介" class="headerlink" title="一、MIMO——OFDM技术简介"></a>一、MIMO——OFDM技术简介</h2><h3 id="MIMO："><a href="#MIMO：" class="headerlink" title="MIMO："></a>MIMO：</h3><p>多输入-多输出，即大规模天线阵列用于发送以及接收。</p><p>用基站端天线数量的扩展代替基站数量的扩展。</p><p>减少基站数量意味着多径效应的削弱，有利于减少小尺度衰减对信号传输的影响。</p><h3 id="OFDM："><a href="#OFDM：" class="headerlink" title="OFDM："></a>OFDM：</h3><p>在传统的频分传输基础上，进一步节省频带资源，实现正交频分调制。</p><h2 id="虽然OFDM各个子载波存在有频谱交叠的部分，但是由于是正交的，接收端仍能够解调信号并且可以高效的利用频谱。"><a href="#虽然OFDM各个子载波存在有频谱交叠的部分，但是由于是正交的，接收端仍能够解调信号并且可以高效的利用频谱。" class="headerlink" title="虽然OFDM各个子载波存在有频谱交叠的部分，但是由于是正交的，接收端仍能够解调信号并且可以高效的利用频谱。"></a>虽然OFDM各个子载波存在有频谱交叠的部分，但是由于是正交的，接收端仍能够解调信号并且可以高效的利用频谱。</h2><p>MIMO在空间域上节省资源；OFDM调制在频域上节省资源。</p><h2 id="二、mMIMO——Massive-MIMO"><a href="#二、mMIMO——Massive-MIMO" class="headerlink" title="二、mMIMO——Massive MIMO"></a>二、mMIMO——Massive MIMO</h2><h3 id="MIMO的信道增益"><a href="#MIMO的信道增益" class="headerlink" title="MIMO的信道增益"></a>MIMO的信道增益</h3><p>多用户大规模MIMO，面向于多个用户接入，单个基站端配备有几十上百跟天线：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image001.png" alt="MIMO and UE"></p><p>每个用户端只有一根天线，基站端配备有多根天线与用户相匹配。其中，第m根天线接收到来自第K个用户的信号Im,K在信道中的增益等于：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image002.png" alt="signal amp"></p><p>大尺度的衰减与小尺度的衰减相乘得到。其中，小尺度的衰减系数受天线的影响最大，可以认为是多个用户导致的用户间串扰（IUI-interUser interference）对于有M根天线阵列的基站来说，每根天线接收到K个用户传来的信号，将这<img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image003.png" alt="Channel Matrix">的信号组成矩阵，对应每个信号的信道增益就构成了信道矩阵。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image005.png" alt="Channel Matrix"></p><p>这也是CSI最终我们要得到的参数（矩阵）。</p><h3 id="MIMO的信道分析"><a href="#MIMO的信道分析" class="headerlink" title="MIMO的信道分析"></a>MIMO的信道分析</h3><p>已知不同信道、不同信号的信道估计增益都不一样，这取决于大尺度衰弱叠加上小尺度干扰；因此为了增强信号的信噪比以及削弱用户间的干扰，我们可以采用最大合并比以及最大比发送实现，具体的思想就是根据CSI估计的信道衰减反馈在接收端或者发送端添加一个增益，以追求所有天线的信噪比之和最大。通常不同天线的增益满足：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image006.png" alt="MRC"></p><p>即增益与信道衰减成正比，与上述的描述相符。</p><p>那么我们如何通过CSI解得的信道矩阵求出最大比合并的权重？我们将矩阵写成列向量矩阵，每一列表示一个用户发出的信号被M根天线接受的信道衰减系数，属于小尺度衰减。我们对信道矩阵取模计算衰减可以得到下面式子：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image007.png" alt="MRC"></p><p>中间的展开式暂时不理解为什么等于这个结果，但是直接考虑到展开之前的部分，由于空间域的复杂性，我们可以假设不同天线的信道之间是互不相关的，由此我们就能知道一个信道的共轭转置乘上另一个信道可以理解求取为两个信道的相关性，因此可以近似于0；式子1的结果是因为当前信道和自己的相关性固然为1.这样我们只需要采用线性的处理方式即最大比合并就可以实现大规模MIMO中多个用户的传播。</p><h3 id="MIMO优缺点"><a href="#MIMO优缺点" class="headerlink" title="MIMO优缺点"></a>MIMO优缺点</h3><p>MIMO实现了在同时、同频进行多用户传播（利用波束空间复用），开发了空间域的资源利用，提高了容量。但是于此同时，随着用户数量大量增加，信道数量根据基站侧的天线数量尺度进行扩张，这也会导致导频资源的紧缺（世间真理，一件事物的宽裕会导致另一件事物的紧缺），导致导频污染。就像原本是一个8x8的象棋格，原本是错开的排列，当用户（列数）增加时，就会出现某一行有两个用户，这也就造成了导频污染。</p><h2 id="OFDM调制"><a href="#OFDM调制" class="headerlink" title="OFDM调制"></a>OFDM调制</h2><h3 id="什么是OFDM调制"><a href="#什么是OFDM调制" class="headerlink" title="什么是OFDM调制"></a>什么是OFDM调制</h3><p>OFDM：正交频分复用，通过多载波调制（加载在不同的频段上）实现对频率选择性衰弱一定的抵抗，同时实现串行信号并行传输，提高速率且尽量节省频带资源。并行传输的优势还在于延长了单个符号的持续时间，假设我需要传输四个符号，每个符号持续0.25ns，那么一共传输1ns；如果我使用OFDM并行传输的话，使用4个子载波进行调制，那么在原来的传输时间1ns内我可以每个符号传输1ns并行传输，这样我单个符号的长度是原来的4倍，通过一些纠错码可以更容易校验符号、纠错，提高系统对ISI的抵抗性。</p><p>OFDM实信号的调制表达式如下：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image008.png" alt="MRC"><br><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image009.png" alt="MRC"></p><p>N为子载波的个数。在接收端由于每个子载波在频域上是相互正交的，可以容易的通过相干解调分离出每一个子载波承载的信号，最后再并串转换就可以得到信道传输后的接收信号。当然实际的调制过程更加复杂，一个可能的框图如下：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image010.png" alt="MRC"></p><h3 id="OFDM的技术特点"><a href="#OFDM的技术特点" class="headerlink" title="OFDM的技术特点"></a>OFDM的技术特点</h3><p>由于信道的不确定性，如多普勒频移导致的非正交性都会对OFDM传递的符号间产生严重的干扰；或者普遍存在的符号间干扰都会导致OFDM的正常传输，因此我们在传输的符号之间插入一段间隔称为保护间隔，通过牺牲一部分资源换取通信的稳定性。</p><p>在插入保护间隔的同时手动引入了时延，再加上多普勒频移导致子载波间不再是严格的正交，子载波信道之间会产生干扰，ICI即信道间干扰。于是添加了循环前缀，补全保护间隔的空缺，是不同信道的符号之间对齐，保持子载波之间的正交性，当然，这样也导致了资源的浪费，但是也能够减少复杂信号处理的开销。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image012.png" alt="MRC"></p><h2 id="信道估计"><a href="#信道估计" class="headerlink" title="信道估计"></a>信道估计</h2><p>信道估计即是通过信道估计算法等数学分析手段研究时变无线信道的信道相关参数，这些参数对于接收端的数据恢复有很重要的作用。信道估计算法大致上可以分为三类，非盲估计、半盲估计和盲估计。这里的“盲”是指发送端的信号是否含有导频，所谓导频是一段接收方和发送方约定好的信号，通过观测导频发生的变化可以解出信道对当前信号的响应。因此我们一般使用非盲估计的方法。</p><h3 id="传统信道估计算法"><a href="#传统信道估计算法" class="headerlink" title="传统信道估计算法"></a>传统信道估计算法</h3><p>接收端的信号是传输信号通过信道的冲激响应后叠加一个加性高斯白噪声的结果，通过算法将接收信号还原接近发送信号，而估计与实际之间的误差就是衡量算法优越性的一个指标：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image013.png" alt="MRC"></p><p>非盲估计是基于导频的信道估计算法，其中比较有代表性的有LS算法。即最小二乘法，其优点是复杂度低，易实现。信道模型如下</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image014.png" alt="MRC"><br><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image015.png" alt="MRC"></p><p>上述数学表达式是信号经过FFT后的频域表达，LS的估计目标是找到一个信道响应能够使HX即估计值与Y实际接收值之间的残差最小，数学表示如下：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image016.png" alt="MRC"></p><p>第一行就是求取两者的残差，矩阵运算也就等于共轭转置×原矩阵。最后的展开式是一个关于HLS的一个方程，我们想要让残差最小，也就是在方程的极小值处取值，因此我们对上式求偏导令等式两边为零，最终的结果是：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image017.png" alt="MRC"><br><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image018.png" alt="MRC"></p><p>其中<img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image019.png" alt="MRC">表示为X的伪逆矩阵。对LS算法求一下均方误差可以得到：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image021.png" alt="MRC"></p><p>结果是信噪比（SNR）的倒数，也就是说当信道的信噪比越高，LS算法的估计效果越好，反过来也意味着LS算法易受噪声干扰。从模型的建立也可以看出，若忽略加性白噪声那一项，估计值就等于实际值。</p><p>由于LS算法对噪声的忽略，导致LS在实际的应用上估计误差较大，所以我们考虑另一种算法即MMSE算法。不像LS算法通过对导频信号的估计与原信号之间的差值来取得信道估计的最佳，MMSE直接对信道的冲激响应进行估计，然后通过信道响应的估计与真实信道响应之间的差值来取得最佳，这也就考虑到信道的多种特质（包括噪声）。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image022.png" alt="MRC"></p><p>最小均方误差算法的思路就是实现信道估计结果与信道响应的真实值之间的均方误差达到最低值。我们假设一个矩阵M使得MY能够逼近发射信号X，令信道响应估计矩阵HMMSE为MY，均方差也就是</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image023.png" alt="MRC"></p><p>这是一个关于M矩阵的函数，我们想让均方差取得极小值也就是要令偏导为0。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image024.png" alt="MRC"></p><p>发现M矩阵是真实信道矩阵冲激响应与接收端信号的互相关矩阵乘上接收端信号自相关矩阵的逆。最后信道响应估计矩阵由等式HMMSE &#x3D; MY得出</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image025.png" alt="MRC"></p><p>MMSE 信道估计算法相对于前面的 LS 算法,最大的改进之处在于消除噪声对信道估计的不良影响,能够实现更为精准的信道估计效果。但是我们从算法的思想中也可以发现，MMSE算法是基于真实信道的自相关矩阵实现的，算法要求信道的统计先验信息，而这往往需要很大的工作量，而且大量的矩阵运算也导致运算的复杂度增大以及算力的需求。</p><hr><p>总结一下，上面两种算法对于信道估计在某些层面上都有较好的表现，LS算法是通过假定一个信道响应HLS，通过将导频通过假设的信道响应与接收端实际接收的导频之间的均方差来估计信道响应，这种假设忽略了信道中噪声的影响。而MMSE算法通过假设一个矩阵M，假定信道响应等于接收端的导频乘上矩阵M即MY，通过真实信道响应与估计的信道响应之间的均方差来估计信道响应，这种假设考虑到信道中的噪声提高了精度，但是需要先验条件即真是信道的自相关矩阵。</p><h2 id="压缩感知"><a href="#压缩感知" class="headerlink" title="压缩感知"></a>压缩感知</h2><p>压缩感知基于信号的稀疏性。该技术的原理是:首先求取得到一个域,它可以实现将原始信号转换至此域后能展现出信号的稀疏性质,完成原始信号的稀疏变换;然后为变换得来的稀疏信号寻找合适的观测矩阵,形成较低维度的信号;最后以低采样的代价,应用重构算法把原来的信号估计出来,回到稀疏域进行处理。例如，信号通过无线信道到达基站的天线阵列，从到达的角度考虑，实际信号到达的角度很有限，在角度域上呈现出稀疏性。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image026.png" alt="MRC"></p><p>如果信号本身不具有某些稀疏性，则利用某一正交基实现线性的稀疏转变：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image028.png" alt="MRC"></p><p>X是原始的N为信号向量，<img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image029.png" alt="thi">是稀疏变化矩阵，<img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image031.png" alt="theta">是完成转变的稀疏信号。完成信号的稀疏转变后的第二部就是进行测量矩阵的设计问题，将上一步完成的稀疏信号与测量矩阵相乘的目的是将信号降维。（去除冗余的信息）</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image033.png" alt="MRC"></p><p>测量矩阵×稀疏变换矩阵得到了A即感知矩阵。原信号是一个N维的信号，而感知矩阵是一个M×N的矩阵，也就是说实现了降维，后续只需要借助M维信号就可以实现最终的原始信号的恢复。</p>]]></content>
    
    
    <categories>
      
      <category>5G, 通感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>5G, Channel state infomation(CSI)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识无线通信——5G 信道估计</title>
    <link href="/2025/04/02/Knowing_5G/"/>
    <url>/2025/04/02/Knowing_5G/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是无线通信"><a href="#什么是无线通信" class="headerlink" title="什么是无线通信"></a>什么是无线通信</h1><p>你在你的手机微信上编辑了一段文字，轻点发送，远在天边的亲朋好友便能够几乎瞬时的接收到你讯息，这固然很好。但是你是否想象过，这个传输的过程是如何实现的？可能你知道，手机向手机基站发送信息，然后基站之间再进行传输，最后由基站向手机对面的人发送消息。那么，现在请你抬头，看看你周围，你是否生活在“盘丝洞”之中。我相信正常的答案是否的（如果你说yes，那你很厉害哟），这就是我们所说的无线通信。这是一个堪称伟大的科技手段，要是信号都只能通过光纤、信号线传输，那我们就真的生活在盘丝洞之中了（!_!）我们现在常用的移动设备像手机、电脑、电视这些，都配备有天线，在基站安装这几十上百的天线构成阵列来接受我们向他发送的信息（后面统称为信号）。</p><p>那你可能会说，就这？你一根天线、我一根天线就能解决的事情，能称得上伟大？当然不是这么简单，你在生活中不难发现，向前推一辆车，过一会他就会自己停下来；向前说话，声音却像是从前面传来。这些说明两点：</p><ol><li>日常生活中存在阻力，或者说衰减，空中传递的信号也不例外会受到衰减，导致从手机到基站的信号的质量往往不如手机端刚发出。</li><li>信号不是像一根线一样固定一个方向传播，而是像声波一样向四周扩散的传播，碰到物体也会反射。现实生活中的反射物更加多，这导致你发出的信号在传播过程中会变成2个、4个、8个甚至更多，这些信号传输到基站就会产生诸多问题，比如哪个信号才是你手机发出的？不同信号之间的到达时间还不同，可能导致通信的延迟。</li></ol><p>无论是上面信号的衰减还是反射导致多径（后续称反射导致的多个信号为多径）都会造成信号延时、信号错乱或者丢包的现象。这也就引起科学家们对无线信号传输的介质（后续我们称为信道）的研究热情，也就是我们所说的信道估计。</p><h1 id="什么是信道"><a href="#什么是信道" class="headerlink" title="什么是信道"></a>什么是信道</h1><p>通过上面的简单讲述，我们知道了信号传输需要借助信道来进行，但是信道是什么？简单来说，信道就是信息传输的“道路”，它决定了你的信号在传输过程中会遇到哪些“坑坑洼洼”，以及它最终能否顺利到达终点。信道可以按照物理性质进一步细分成两大类：</p><ol><li><strong>有线信道</strong>：你可以把它理解成现实生活中的“高速公路”，光纤、电缆等物理介质就像是坚固的公路，保证了信号可以稳定传输。</li><li><strong>无线信道</strong>：它更像是一条“空中航线”，信号依靠电磁波在空中传播，不需要任何实体的介质支撑，但也因此容易受到干扰。</li></ol><p>而我们的手机信号在绝大部分的情况下是按照无线的方式进行传输的，而无线信道不像有线信道那样受物理线路保护，它在现实环境中会受到各种因素的影响，导致信号在传输过程中变得“崎岖不平”。那么我们为了更好的传输信号，我们就需要研究无线信道的一些特性。</p><h3 id="衰弱"><a href="#衰弱" class="headerlink" title="衰弱"></a><strong>衰弱</strong></h3><p>你有没有试过在一个房间里走动时，手机的信号时好时坏？这就是衰落的表现。衰落的原因有很多，比如信号在传播过程中遇到障碍物（墙壁、建筑物等），或者随着传播距离的增加，能量逐渐减少。我们通常把衰落分成两类：</p><ol><li><strong>大尺度衰落</strong>：影响的是信号的整体强度，和传播距离、环境密集程度有关。比如，你站在空旷的草原上，手机信号可能很好；但如果你进入高楼大厦的电梯，信号可能会瞬间变差。</li><li><strong>小尺度衰落</strong>：影响的是信号的细微波动，通常是因为多条路径的信号相互干扰，比如你在城市的街道上走动时，信号可能会在不同建筑物间反射，导致质量不稳定。</li></ol><h3 id="多径效应"><a href="#多径效应" class="headerlink" title="多径效应"></a><strong>多径效应</strong></h3><p>想象一下你在山谷中大喊一声，你的声音会经过不同路径反射回来，形成“回声”。无线信号的情况也是如此——信号在传播过程中，会因为碰到建筑物、树木、地面等产生反射、折射、散射等现象，从而形成多个到达接收端的路径。问题是，不同路径的信号传播时间不一样，到达接收端时可能会相互叠加或抵消，导致信号失真。这种现象被称为多径效应。多径效应会导致两种衰落：</p><ol><li>平坦衰落：如果信号的带宽较小，整个频段的信道影响几乎相同，衰落不会太严重。</li><li>频率选择性衰落：如果信号的带宽较大，不同频率的信号分量会受到不同程度的衰落，从而导致接收信号的畸变。</li></ol><h3 id="多普勒效应"><a href="#多普勒效应" class="headerlink" title="多普勒效应"></a><strong>多普勒效应</strong></h3><p>如果你坐在路边，听着远处驶来的救护车警笛声，你会发现声音的频率在接近时变高，远离时变低。这就是多普勒效应。在无线通信中，如果信号的发射端或接收端在运动（比如你在开车时打电话），信号的频率会发生偏移，影响通信质量。多普勒效应带来的主要影响是：</p><ol><li><strong>频率偏移</strong>：信号的频率发生变化，可能会导致解调困难。</li><li><strong>快衰落</strong>：当信道的变化速度比信号的变化快时，你在传输一个信号符号的时候，还没传完信道的性质就发生了改变，信号就会迅速失真，影响通信的稳定性。</li></ol><p>无线信道是信息传输的“无形道路”，但它并不总是平坦顺畅的。衰落、多径效应、多普勒效应这些问题，使得无线信号在传输过程中会出现各种不可预测的变化。这也正是科学家们研究信道特性的原因——他们希望找到更好的方法来对抗信道的不利影响，让无线通信变得更加稳定高效。那么，如何才能让信号在复杂的无线环境下依然保持良好的质量呢？别着急，这就是我们下一步要讨论的话题——信道估计！</p><h1 id="什么是信道估计（CSI）"><a href="#什么是信道估计（CSI）" class="headerlink" title="什么是信道估计（CSI）"></a>什么是信道估计（CSI）</h1><p>我在上面通过一种举例子的方式带你简要的理解了一下什么是无线通信以及我们为什么要做信道估计，下面我从学术一点的角度上解释什么是信道估计、为什么需要信道估计，以及信道估计有什么用（作者也是初学者，仅作为参考以及补充）？信道估计，顾名思义是对信道参数进行的一种估计。由于信道的不确定性，我们通常采用统计的角度对信道的一些影响信号传输的参数进行估计，比如衰减、时延等等。那我们为什么需要信道估计？我还是举例进行说明，假设一个用户向基站传输10个信号，每个信号经历完全相同的信道（也就是说信道对信号的影响完全一样），如果我不做信道估计，那基站每接收一个信号都要对这个信号进行一个信道影响的消除，这对于基站这种大吞吐量的应用场景显然不合理。如果基站对第一个信号做信道估计，知道了信道对信号的冲激响应是幅度衰减为1&#x2F;2、相位延后10，那么后续的9个信号基站可以直接给一个2倍的增益，然后将相位提前10以此消除信道的干扰，如此就节省了资源又提高了效率。</p><p>后续科学家们通过对信道估计得到的参数进行研究，推出了许多的算法，发现可以通过CSI得到信号从发出到达基站的时间、信号到基站使被接收的角度等，由此衍生了CSI得出信道响应用于定位用户的功能等。</p>]]></content>
    
    
    <categories>
      
      <category>5G 通感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>5G Channel state infomation(CSI)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wi-Fi Backscatter communication</title>
    <link href="/2025/03/18/Wi-Fi%20Backscatter%20communication/"/>
    <url>/2025/03/18/Wi-Fi%20Backscatter%20communication/</url>
    
    <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This article is about a new way of communication for edge IoT devices. Aims at transmitting information of sensors without consuming energy or even store energy for sensing environment.</p><p>It is a great method to deal with situation which may encounter some problems like short-energy.</p><p>We realise this method based on 802.11.ac frame structure, using a mcu controling RFID switch to change the resist value, which cause the changing in phase of the Wi-Fi packets.</p><p>The <strong>180 degrees</strong> inversion in phase of Wi-Fi packets will destroy the mac frame of signal transmitted in Los(Line of sight) as superimposed by the inversed Wi-Fi packets, which cause the <strong>0 bits</strong> in ACK block.</p><p>So we can get the information that we modulated onto the Wi-Fi packets without transmitting it by decoding the ACK blocks. That is the main concept of what we do.</p><h2 id="什么是WiFi反向散射系统（WiFi-BackScatter-Communication-System）"><a href="#什么是WiFi反向散射系统（WiFi-BackScatter-Communication-System）" class="headerlink" title="什么是WiFi反向散射系统（WiFi BackScatter Communication System）"></a>什么是WiFi反向散射系统（WiFi BackScatter Communication System）</h2><p>直观点说，Backscatter 通信是一种极低功耗通信方式，设备不用主动“发射信号”，而是通过反射已有的无线信号（比如WiFi）来传递数据。基本原理是假设空气中已经存在一个无线信号（比如 WiFi 路由器发出的信号），背散射设备（比如标签）不自己发射信号，而是通过调节天线的阻抗，选择性地反射或不反射这些信号。接收端设备（比如智能手机）检测这些变化，从中恢复出数据。</p><p>可以理解为有人一直在用手电筒（WiFi 信号）照一个镜子，这个镜子（WiFi Tag）可以控制自己是反光还是吸光（反射或不反射信号），你站在另一边看，就能根据“亮”或“不亮”来解码信息。这样的通信方式可以实现超低功耗（甚至可以完全无电池），完全适配物联网（IoT）设备、RFID 标签等。</p><h2 id="如何理解WiFi-Backscatter所谓的破坏"><a href="#如何理解WiFi-Backscatter所谓的破坏" class="headerlink" title="如何理解WiFi Backscatter所谓的破坏"></a>如何理解WiFi Backscatter所谓的破坏</h2><ol><li><p>理解WiFi Tag的工作方式我们就需要先知道WiFi是怎么传输数据的。我们都知道数据在电脑中是呈现为0101这样的二进制比特流的，每8个bit构成一个字节。而WiFi将至少一个字节包装成一个子帧（subFrame），Tag就是以子帧为基本单位实现破坏的功能的（也就是说破坏很多个bit）。已知我们手机（UE）向路由器发送数据，如果路由器成功接收了那么就会回应UE一个BA（Block ACK）。如果接收到了，在BA对应的帧位置上会显示为1.假设我们原本要传输一共10个子帧，如果AP（例如路由器）全部都接收到了，那么在Wireshark（一个抓包软件）上就会显示BA对应位置有10个1（1表示成功接收）。</p></li><li><p>有的人想你把用户发出的数据破坏了，那用户不就丢包了吗？这时候，我们就要理解多径。信号在空气中不是只沿一条直线传播的，而是在一定范围的角度范围内都有的，这也导致了多径的产生。假设我们现在发出的信号只有两条路径</p></li></ol><p><img src="https://github.com/allforkarina/embadded_image/blob/master/20250406065801171.png?raw=true" alt="Multiple Path"></p><p>其中从Helper到Reader的路径是最短的直线（称为LOS）。另一条路径的信号可能由于外界环境的反射（跟声波一样），路径长度更长，使得信号到达Reader时相比于LOS有一个时延，而这个时延就会导致信号的相位发生改变（改变180°就相当于反向）。</p><ol start="3"><li>那么我们如何实现这个相位反向呢，靠运气等环境自己使信号相位改变吗？下面我们就要讲硬件实现思路。我们都知道信号波长与频率之间的关系：</li></ol><p><img src="https://github.com/allforkarina/embadded_image/blob/master/20250406065807770.png?raw=true" alt="Multiple Path"></p><p>一般频率我们已知，那么我们也就能够算出来信号的波长。一个波长从公式的角度等价于一个完整周期，等价于一个360°的相位偏移，那么我们可以设计一个标签我们的Tag在信号的传输路径中间，用一个开关切换路径，一共两条，一条路径长度是一个完整波长，那么信号通过Tag的天线进入标签再出来经过了一个完整的周期，可以认为相位不变；另一条路径的长度是半个波长，同理信号进入Tag再出来相位改变了180°，与原来的信号反向。相当于我们人为的将多径的长度差变成了一个波长。</p><h2 id="WiFi-Tag调制的具体实现流程"><a href="#WiFi-Tag调制的具体实现流程" class="headerlink" title="WiFi Tag调制的具体实现流程"></a>WiFi Tag调制的具体实现流程</h2><p>假设我们的手机和WiFi路由器在进行数据交换，在一种理想的情况下我们的信号质量很好，没有丢包的情况。我们在中间加入WiFi Backscatter Tag，并且以10KHz的频率去切换开关。假设我们手机网卡发送子帧的速率也是10K个子帧每秒，那么我们可以假设在LOS（即前面说的直射路径）中传输的信号（调制了10K个子帧）的相位都是0°（相对的）。然后在有WiFi Tag的另一条路径，信号调制的10K个子帧有5K个相位为360°，有5K个相位为180°。相位为360°的跟LOS的信号叠加在一起由于同相，对原来的信号起到增强的作用，接收端全是1（参考基础知识1）而相位为180°的跟LOS的信号反向，叠加到一起刚好相互抵消了，那么接收端就是全0（理想情况）。那么我们就可以通过这个0、1之间的交替得出我们WiFi Tag要调制的信号，如下：</p><p><img src="https://github.com/allforkarina/embadded_image/blob/master/20250406065816107.png?raw=true" alt="Multiple Path"></p><hr><p>以下是，我们如何通过软件实现对上述流程的仿真以及体现。</p><h2 id="Introduction-of-environment"><a href="#Introduction-of-environment" class="headerlink" title="Introduction of environment"></a>Introduction of environment</h2><p>In this section I will briefly give a introduction of the hardware requirement, software requirement and the system environment which we based on.</p><ul><li>Firstly, we setup ubuntu 22.04 version in real PC because one of the software we used requires real NIC(Network Interface Card).</li><li>Secondly, we need a low-speed, high-frequency RFID switch which also required low power consuming. Together with a mini-mcu to control it, which means you need a energy provided method.</li><li>thirdly, you may need wireshark to get packets info at initial, then you need PicoScenes as CSI Tool to get ACK block. Also you need pktgen which is provided by Linux kernel.</li></ul><h2 id="Process-of-experiment"><a href="#Process-of-experiment" class="headerlink" title="Process of experiment"></a>Process of experiment</h2><p>Let’s start from equiping your computer with necessary software. First thing is that you need an PC with a Ubuntu system at version 22.04. Then after your configuration of basic settings, you can start from ‘Pktgen’ which is already in your system software and all you need to do is activate it using your root privacy. The detail of the overall process please follow the blog: <a href="https://blog.csdn.net/qq_41596356/article/details/134004341">How to use Pktgen-powerful Wlan test tools</a>. Notice: once you reboot your system, you need to activate the Pktgen using root privacy again.</p><p>Pktgen, used as packet genration and transmission tool, you can send packet which you configure. You then need a software to receive packet and evaluate the infomation of signal-channel through the packet you received. Here I recommend using wireshark to capture packet, and using PicoScenes to get CSI. The installation steps as followed.<br>For Wireshark, you can visit its <a href="https://github.com/wireshark/wireshark">github repository</a> and paste the command at your terminal. The second one PicoScenes, you can download it following this <a href="https://www.bing.com/search?form=QBLH&q=PicoScenes">blog</a>, or visit the <a href="https://ps.zpj.io/">official docs</a> to get to know how to install, how to use it and what is the meaning of CSI values.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于博客的那些事o.O</title>
    <link href="/2025/03/18/hello-world/"/>
    <url>/2025/03/18/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-的使用指引"><a href="#Hexo-的使用指引" class="headerlink" title="Hexo 的使用指引"></a><em>Hexo</em> 的使用指引</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h1 id="如何快速入门-Markdown"><a href="#如何快速入门-Markdown" class="headerlink" title="如何快速入门 Markdown"></a>如何快速入门 <em><strong>Markdown</strong></em></h1><p><em>Markdown</em>，作为一种基于文本的快速格式化编写语法，相较于传统的文本编译器如 <em>Word</em>、<em>WPS</em> 这些基于图形化的 <em>format</em> 工具，只需要简单的几个字符便可以便可实现 <em>斜体</em>、<strong>粗体</strong>以及<code>高亮</code>等特殊 <em>format</em>。</p><p>而对比起 <em>Latex</em>，<em>Markdown</em> 虽然功能不如其强大，但是由于 <em>Latex</em> 需要更长的学习周期、繁杂的公式和文本表达式，以及较慢的编译速度，对于想快速编写 <em>blog</em> 或者 <em>diary</em> 的新手，我个人更加推荐使用 <em>Markdown</em>。下面我将带领你们快速入手 <em>Markdown</em>，让我们省去一些没用的废话，<em><strong>Let’s start it!!!</strong></em></p><h2 id="清晰分明的标题分级"><a href="#清晰分明的标题分级" class="headerlink" title="清晰分明的标题分级"></a>清晰分明的标题分级</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># | ## | ### | ####</span><br></code></pre></td></tr></table></figure><p>上述，便是 <em>Markdown</em> 中定义的标题分级方式，怎么样，是不是非常的简单清晰！只要你想，你可以不断地叠加<code>#</code>来实现多级标题，当然这样的结果可能只是标题比你的正文还要不起眼。</p><h2 id="强大、快捷的特殊-Format"><a href="#强大、快捷的特殊-Format" class="headerlink" title="强大、快捷的特殊 Format"></a>强大、快捷的特殊 <em>Format</em></h2><p>当你使用 <em>Word</em> 撰写一篇文章的时候，如果你想将某段文字变成粗体来起到强调的作用，你大概率会选中文字，移动你的鼠标到<code>B</code>的粗体标识上，Click一声，实现加粗的效果；如果你是高手，那么你可能会使用快捷键来加粗文字，但是在 <em>Markdown</em> 的世界里，你只需要</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**加粗的文字**</span><br></code></pre></td></tr></table></figure><p>便可以实现 <strong>加粗</strong> 的效果。</p><hr><p>同理，像 <strong>加粗</strong> 这样的方便快捷的 <em>Format</em> 还有 <em>斜体</em>、<code>代码</code>、<del>删除线</del>等等。他们分别对应的格式为</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">_斜体_</span> | <span class="hljs-code">`代码`</span> | ~~删除线~~<br></code></pre></td></tr></table></figure><h2 id="常用的文本结构"><a href="#常用的文本结构" class="headerlink" title="常用的文本结构"></a>常用的文本结构</h2><p>这时候有人会问了，博主博主，你的文本 <em><code>format</code></em> 还是太普通了，有没有不吃操作更强大的功能？有的有的！比如，你可以快速的自定义一个列表：</p><table><thead><tr><th></th><th>col1</th><th>col2</th></tr></thead><tbody><tr><td>row1</td><td>—-</td><td>—-</td></tr><tr><td>row2</td><td>—-</td><td>—-</td></tr></tbody></table><p>像上面这个2x2的表格只需要简单的定义方式，如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">|      | col1 | col2 |<br>| ---- | ---- | ---- |<br>| row1 | ---- | ---- |<br>| row2 | ---- | ---- |<br></code></pre></td></tr></table></figure><p>其中的<code>| ---- | ---- | ---- |</code>，也就是第二行，作用是区分表格的内容以及每一列的Title. </p><hr><p>当然，你可结合我们上一节的特殊format来自定义你的表格，像</p><table><thead><tr><th></th><th align="left">col1</th><th align="left">col2</th></tr></thead><tbody><tr><td>row1</td><td align="left"><code>code</code></td><td align="left"><em>Italic</em></td></tr><tr><td>row2</td><td align="left"><strong>Bold</strong></td><td align="left"><del>Dele</del></td></tr></tbody></table><hr><p>或许你正在尝试编写一个技术性的博客，你对如何将源码展示开源而感到头痛。直接复制粘贴，格式不对，不够优美；截图呢，虽然有高亮，但是没有办法<code>ctrl + c\v</code>. 对此，我强烈建议你使用 <em>Markdonw</em> 的代码块Structure</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$ <span class="hljs-code">``` (language)</span><br><span class="hljs-code">(Warning: $ 只是用于防止代码块在我定义的markdown代码块中生效，实际使用只需要上下用```</span>标注这是一个代码块即可生效)    <br>$ <span class="hljs-code">```</span><br></code></pre></td></tr></table></figure><p>括号内的Language表示，<em>Markdown</em> 的代码块支持多种不同的语言，像python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.random.randn(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><hr><p>或者你需要一个<code>TODO List</code>来帮助你管理你的事项，那么你可能需要使用到列表。</p><p><em>Markdown</em> 支持多种不同的列表，例如数字列表：</p><ol><li>This is the first list.</li><li>This is the second list</li></ol><p>又或者是点列表：</p><ul><li>list here.</li><li>list here.</li></ul><h2 id="特殊的玩法"><a href="#特殊的玩法" class="headerlink" title="特殊的玩法"></a>特殊的玩法</h2><p><em>Markdown</em> 不仅仅是提供一个方便快捷的文本编辑方式，它还有一些特殊的使用方法来装点你的Markdown文本。</p><ul><li><em><strong>Emoji</strong></em>：✅、😶‍🌫️ etc.</li></ul><hr><p>以上就是比较常用的Markdown使用格式，希望这个指引能够对你有帮助。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
