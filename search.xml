<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面向WiFi-Sensing的文献总结</title>
      <link href="/2025/09/21/research/survey-on-wifi-sensing-generalization/"/>
      <url>/2025/09/21/research/survey-on-wifi-sensing-generalization/</url>
      
        <content type="html"><![CDATA[<h1 id="Survey-on-WiFi-Sensing-Generalization"><a href="#Survey-on-WiFi-Sensing-Generalization" class="headerlink" title="Survey on WiFi-Sensing Generalization"></a>Survey on WiFi-Sensing Generalization</h1><h2 id="General概述"><a href="#General概述" class="headerlink" title="General概述"></a>General概述</h2><p>使用WiFi作为感知的媒介有广大的应用场景，以及较大的研究价值。但是由于WiFi对于环境过于敏感，导致感知系统跨环境的表现性能极差，大规模的部署极其困难，为此，大量研究人员提出了多种方法提高环境泛化能力，这些方法可以分为下面四类：</p><ul><li>设备的放置和布局；</li><li>信号的处理；</li><li>CSI的特征学习；</li><li>Sensing模型的部署迁移；</li></ul><p>下面我们从第一个方法开始，即实验场景、设备的配置和布局。</p><h2 id="Experimental-Setup实验配置"><a href="#Experimental-Setup实验配置" class="headerlink" title="Experimental Setup实验配置"></a>Experimental Setup实验配置</h2><h3 id="天线的分布"><a href="#天线的分布" class="headerlink" title="天线的分布"></a>天线的分布</h3><p>WiNDR和WiCross研究天线的布局对感知的影响，提出使用一个三发三收、交叉分布在圆上的天线分布可以实现不受方向影响的姿态识别：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921019.png" alt="Img"></p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921009.png" alt="Img"></p><p>同理，WiSDAR还测试了多种不同的分布形状如线、六边形、方形或者随机形状，对人类行为有不同的感知效果；</p><h3 id="设备的分布"><a href="#设备的分布" class="headerlink" title="设备的分布"></a>设备的分布</h3><p>ReWiS、Widar 3.0、OneFi等研究使用多个收发设备，提高感知系统的感知范围以及环境泛化能力，这些多设备系统在人类行为中的旋转和位置变化有优异的表现。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921002.png" alt="Img"></p><p>其中，WiTraj通过3个接收机从不同的角度捕获人类行走的行为，并最终实现对行走轨迹的复现。通过一定的理论研究，得出感知系统的感知范围与收发机的放置间距相关，从而可以更合理的进行场景的搭建，减弱环境的干扰。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921015.png" alt="Img"></p><h2 id="Signal-Processing数据处理"><a href="#Signal-Processing数据处理" class="headerlink" title="Signal Processing数据处理"></a>Signal Processing数据处理</h2><h3 id="信号分析算法"><a href="#信号分析算法" class="headerlink" title="信号分析算法"></a>信号分析算法</h3><p>通过特殊的信号分析算法，从原始的信号CSI中提取出<strong>与环境无关</strong>的特征，获得更好的跨环境泛化表现能力：</p><ul><li>WiHand通过部署<strong>低秩稀疏分解算法（Low Rank and Sparse Decomposition algorithm）<strong>将不同姿态对应的信号</strong>从环境噪声中提取分离</strong>；</li><li>CLAR使用<strong>奇异谱分析（Singular Spectrum Analysis）<strong>从WiFi信号中分析</strong>变化趋势</strong>，对行为的识别效果更好；</li><li>Gait-Enhance通过<strong>CSI重构算法</strong>，消除由于<strong>行为的方向性导致同类行为却有不同CSI模式</strong>的误差；</li><li>Abuhoureyah通过使用<strong>独立分量分析（Independent Component Analysis）和连续小波变换（Continuous Wavelet Transform）实现多目标分离</strong>、识别在一个复杂的环境中。</li></ul><h3 id="Advanced-Handcrafted-Indicators特殊的特征指标"><a href="#Advanced-Handcrafted-Indicators特殊的特征指标" class="headerlink" title="Advanced Handcrafted Indicators特殊的特征指标"></a>Advanced Handcrafted Indicators特殊的特征指标</h3><p>用于提取与空间域无关的更鲁棒性的特征；</p><ul><li>WiHGR通过相位差矩阵提取出与相位相关的特征；</li><li>PhaseAnti使用非线性相位误差变化，与同频道干扰无关，从而减轻干扰，提高识别的准确性；</li></ul><p>除此外还有从IQ复平面中提取特征的；</p><ul><li>Wang通过信号在IQ平面的曲率作为分析的特征；</li><li>WiGesFree引入了Sample Point Distance，通过CSI在复平面的比值关系判断姿态；</li><li>LiKey通过CSI在复平面的旋转方向特征提取与位置无关的特征；</li></ul><p>还有采样类似图像识别的方式，通过AI的手段进行特征处理；</p><ul><li>将CSI Stream的幅度信息（一维）转换称为CSI灰度图（二维），再通过微调、预训练的模型如VGG16提取特征；</li><li>将一维的CSI转换成二维的递归图，通过数据增强的手段如裁剪、旋转、翻转等提高模型表现以及鲁棒性；</li></ul><h3 id="Motion-Indicator行为指标"><a href="#Motion-Indicator行为指标" class="headerlink" title="Motion Indicator行为指标"></a>Motion Indicator行为指标</h3><p>通过研究某些行为中与环境无关的指标实现提高环境鲁棒性，跨环境识别性能，如速度、方向、轨迹等与环境无关的指标，提高感知系统的跨环境表现；</p><ul><li>OneSense以及Wilearner等通过研究由于行为导致的多普勒频移（Doppler Frequency Shift）实现感知；</li><li>Mini-Batch Alignment研究DFS和角度差矩阵；</li><li>WiLife通过研究多普勒速度进行感知；</li><li>WiTraj则通过结合多普勒-MUSIC的谱，使用多个接收器复现定位，最终复原轨迹；</li></ul><h3 id="Angle-Indicators角度指标"><a href="#Angle-Indicators角度指标" class="headerlink" title="Angle Indicators角度指标"></a>Angle Indicators角度指标</h3>]]></content>
      
      
      <categories>
          
          <category> Reading and Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WiFi Sensing </tag>
            
            <tag> AI </tag>
            
            <tag> Environment Generalization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unsupervised adversarial domain adaptation——对抗生成跨域泛化</title>
      <link href="/2025/09/20/research/Unsupervised-adversarial-domain-adaptation-By-han/"/>
      <url>/2025/09/20/research/Unsupervised-adversarial-domain-adaptation-By-han/</url>
      
        <content type="html"><![CDATA[<h1 id="Unsupervised-Adversarial-Domain-Adaptation-——-Han-Zou"><a href="#Unsupervised-Adversarial-Domain-Adaptation-——-Han-Zou" class="headerlink" title="Unsupervised Adversarial Domain Adaptation —— Han Zou"></a>Unsupervised Adversarial Domain Adaptation —— Han Zou</h1><h3 id="文献综述《Robust-WiFi-enabled-Device-free-Gesture-Recognition-via-Unsupervised-Adversarial-Domain-Adaptation》"><a href="#文献综述《Robust-WiFi-enabled-Device-free-Gesture-Recognition-via-Unsupervised-Adversarial-Domain-Adaptation》" class="headerlink" title="文献综述《Robust WiFi-enabled Device-free Gesture Recognition via Unsupervised Adversarial Domain Adaptation》"></a>文献综述《Robust WiFi-enabled Device-free Gesture Recognition via Unsupervised Adversarial Domain Adaptation》</h3><p><strong>研究目的 (Research Objective)</strong></p><p>本研究旨在解决现有WiFi手势识别系统在实际部署中的<strong>核心痛点</strong>：<strong>环境动态性导致的模型失效问题</strong>。当系统部署到新环境（如从会议室移到办公室）时，无需重新收集标注数据和训练新模型，即可保持高识别准确率。</p><h3 id="本文的创新点："><a href="#本文的创新点：" class="headerlink" title="本文的创新点："></a>本文的创新点：</h3><ul><li><p><strong>数据创新：利用CSI相位差作为输入</strong></p><ul><li>摒弃了传统方法中易受噪声影响的CSI幅度，转而使用<strong>接收端天线对之间的CSI相位差</strong>来构建数据帧。</li><li>相位差能有效消除由硬件（如载波频率偏移CFO、采样频率偏移SFO）引入的固定相位偏移，从而提取出更能反映人体动作的”干净”信号，对微小手势更敏感。</li></ul></li><li><p><strong>多场景下的如何实现模型泛化：</strong></p><ul><li>已知一个正常运行的模型分为三层，CSI原始数据、特征提取和分类器输出姿态。本文认为不同域下相同的姿态理论上对于CSI应该相同，但是由于域的差异引入了<strong>域标签（domain label）<strong>的影响使得不同场景下在</strong>特征空间的分布不同</strong>。</li><li>因此作者认为只要能够消除这个domain label的影响，使得<strong>在不同场景采集的CSI映射到特征空间仍有相同的分布</strong>，于是只需要一个分类器便可以实现不同场景的泛化。</li></ul></li></ul><h3 id="整体流程介绍："><a href="#整体流程介绍：" class="headerlink" title="整体流程介绍："></a>整体流程介绍：</h3><p>首先在一个确定的环境中进行训练，我们称这个环境为源域（Source domain）。训练的流程大致如下：</p><ul><li><p>采集源域中的CSI，根据做出的手势对CSI进行标签，得到带标签的CSI样本（CSI是一个时间序列，使用不同接收天线的相位差作为训练样本），CSI对应的信号子载波数量为114（文中使用），不同的动作在同一对接收天线的相同子载波上得到的相位差显著不同；</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921027.png" alt="Img"></p></li><li><p>得到用于训练的样本后，首先训练映射模型，将源域中对应CSI得到的样本映射到一个潜在的特征空间，该模型称为 $M_s$，不同的姿态映射到特征空间中符合某种特征分布；之后根据标签，计算损失函数，反向梯度下降优化模型参数，使源域中任意姿态对应的CSI通过该模型都可以正确分类，该分类模型称为 $C_s$，用于将CSI分类为不同的姿态；</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921024.png" alt="Img"></p></li></ul><p>在源域中能够姿态识别后，下一步就是进行场景的泛化，实现步骤如下：</p><ul><li><p>采集目标域中没有标签的姿态对应CSI，使用源域中的 $M_s$ 的参数作为初始参数，训练目标域的映射模型 $M_t$，该<strong>映射的目标是使相同姿态的CSI映射到特征空间中保持与相似的特征分布</strong>。我们可以假设<strong>相同的姿态理论上对应的CSI应该是相同</strong>的，但是由于域的不同，导致得到的CSI不同，这种由于域不同导致CSI的差异称作<strong>域标签（domain label）</strong>！</p></li><li><p>通过引入一个<strong>域判别器（Domain Discriminator）</strong> 来实现对抗训练：判别器试图区分数据是来自源域还是目标域，而目标编码器则努力”欺骗”判别器，使其无法区分。这个过程迫使两个域的数据在特征空间中对齐，从而实现”域不变”（domain-invariant）的特征表示。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921022.png" alt="Img"></p></li><li><p>最终实现在任意场景部署都可以实现姿态识别！目标场景中没有训练过的CSI + GAN训练后的特征空间映射模型 $M_t$ + 源域训练的分类器 $C_s$ &#x3D; 最终预测的姿态。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921025.png" alt="Img"></p></li></ul><h3 id="研究实现-Research-Implementation-Results"><a href="#研究实现-Research-Implementation-Results" class="headerlink" title="研究实现 (Research Implementation &amp; Results)"></a><strong>研究实现 (Research Implementation &amp; Results)</strong></h3><ul><li><p><strong>系统实现</strong>：</p><ul><li>使用两台TP-LINK N750路由器（一台TX，一台RX）搭建原型系统。</li><li>在路由器上刷入自研的OpenWrt固件，实现在5GHz频段、40MHz带宽下采集114个子载波的CSI数据。</li><li>后端计算单元（笔记本电脑）使用Python进行实时数据处理和模型推理。</li></ul></li><li><p><strong>实验验证</strong>：</p><ul><li>在两个真实室内环境（会议室和办公室）中进行测试，由2名志愿者执行6种常见手势（左移&#x2F;右移、左滚&#x2F;右滚、推&#x2F;拉）。</li><li><strong>在原始环境</strong>：WiADG的平均识别准确率高达<strong>98%</strong>，显著优于基线方法WiG和WiAG（分别高出约9-11%）。</li><li><strong>在新环境（无自适应）</strong>：直接迁移源模型，准确率骤降至约<strong>50%</strong>，证明了环境动态性的严重影响。</li><li><strong>在新环境（有自适应）</strong>：启用无监督对抗域自适应后，识别准确率大幅提升至<strong>66.6% - 83.3%</strong>，平均提升超过25%，且<strong>无需任何新环境的标注数据</strong>。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Reading and Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WiFi Sensing </tag>
            
            <tag> AI </tag>
            
            <tag> Environment Generalization </tag>
            
            <tag> Pose Estimation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MultiFormer——基于迭代的高准确率姿态估计</title>
      <link href="/2025/09/19/research/multiformer-By-wenhui-xiong/"/>
      <url>/2025/09/19/research/multiformer-By-wenhui-xiong/</url>
      
        <content type="html"><![CDATA[<h1 id="MultiFormer-——-Wenhui-Xiong"><a href="#MultiFormer-——-Wenhui-Xiong" class="headerlink" title="MultiFormer —— Wenhui Xiong"></a>MultiFormer —— Wenhui Xiong</h1><p><strong>研究目的：将在一个场景训练的姿势识别模型扩展到不同的场景中；</strong></p><p>可能的方法（建模上）：</p><ul><li>将不同的场景抽象为一个样本，多个场景训练（小样本学习）；</li><li>将时间、频率、<strong>空间</strong>特征抽象为张量，添加场景布局的影响；<ul><li>根据协议提出的标准室内WiFi建模，抽象为<strong>token</strong></li></ul></li><li>AI学习算法提高训练的模型对未知环境的适应能力，增强泛化能力</li></ul><p><strong>Keypoints:</strong></p><ul><li>Cross-Scene</li><li>Adaptive environment</li><li>dynamic environment</li><li>robustness</li><li>Ada boost</li><li>Meta-Learning</li><li>Data Augmentation for Generalization</li></ul><p><strong>对于当前研究的问题：</strong></p><ul><li>初始数据检索与清理：CSI是否会影响估计，环境中的信道很多，直射信道是否会影响反射或散射信道？仅考虑了CSI幅值用于姿态估计，忽略相位导致识别效果下降？</li><li>将CSI提取出feature，通过PAPM得到PAM和PCM，但是都是2维空间域中的识别，忽略了深度，如果多目标的姿态有重叠，是否影响估计的效果？</li><li>使用图像信息作为teacher模型的输入进行监督学习，除了图像中的关键点信息外，其余的环境信息是否影响了CSI模型的训练，导致跨场景表现下降？同理，图像作为2D信息缺少深度，是否是限制模型多目标识别的性能？</li></ul><h2 id="论文实现："><a href="#论文实现：" class="headerlink" title="论文实现："></a>论文实现：</h2><h3 id="整体流程介绍："><a href="#整体流程介绍：" class="headerlink" title="整体流程介绍："></a>整体流程介绍：</h3><p>环境中存在一个发送机和一个接收机，发送机只有单根天线、接收机有多根天线，在收发机中间有单人或多人摆出不同的姿势，做不同的行为。</p><p>接收端通过估计CSI，并通过上采样（插值+滤波）的方式将CSI的数据形状修正为模型输入的形状。CSI包含的信息有数据包index、子载波index和信道数量（发射天线x接收天线）。CSI的时间信息关乎一个持续性的行为、频率信息关乎瞬时的姿态，因此上采样操作分别从时域和频域上进行，获得两个Token —— Time Token, Frequency Token且两者彼此独立：</p><ul><li>Time Token：表征一个持续性的<strong>动作</strong>；</li><li>Frequency Token：表征一个时刻的瞬时<strong>姿态</strong>；</li></ul><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921021.png" alt="Img">  </p><p>首先将提取出的Token（64个）做正则化，防止数据异化影响注意力分布。Multi-Head Attention模型的输出通过softmax提高关键点的注意力显著性。之后经过一个前向反馈网络（FFN）通过残差连接保障记忆力，最后输出一个1D的通过Multi-Head Attention得到的时、频feature，在输出部分reconstruct成map的形式即可映射到2D的姿态估计中。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921006.png" alt="Img">  </p><p>feature maps输入Heatmep Decoder中可以解码出PCM（多少个关节多少张PCM，每一张对应一个关节，越亮的pixel表示该处是对应关节的置信度越高）、PAM（多少个关节连接关系多少张PAM，图中每一个点表示该点可能对应的连接方式的矢量，即连接方向和可信度。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921010.png" alt="Img">  </p><p>为了提高准确度，参考残差的方式添加了PAPM融合特征机制：</p><ul><li><p>首先初始化参数，将原始CSI提取出的特征通过Heatmap Decoder得到初代PCM、PAM，通过Teacher图像识别的监督结果，反向传播调整参数；</p></li><li><p>将初代估计结果通过Channel Attention和Spatial Attention得到<strong>时-频特征的注意力分布</strong>、估计结果<strong>PCM中关键点注意力分布</strong>，并将得到的注意力分布反馈到CSI提取的feature maps中，调整maps的权重、每一个map中不同点的权重；</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921016.png" alt="Img">  </p><ul><li><p>Channel Attention从128个特征图中选择对姿态估计最重要的特征，分配注意力，将加权后的融入下一阶段的姿态估计，提高准确率（容易过拟合）</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921026.png" alt="Img"></p></li><li><p>Spatial Attention通过卷积获得空间的关键点特征，即关节点的位置和连接关系</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921023.png" alt="Img"></p></li></ul></li><li><p>将得到的特征分布、姿态热力分布加权到原始CSI得到<strong>训练强化</strong>的CSI，此时的CSI对识别结果更加敏感，重新进行姿态估计，重复上述。</p></li></ul><p>上面两个分别是初始值为1时的Spatial Attention经过三次stage迭代后得到的关节识别注意力热力分布，以及Channel Attention经过三次stage迭代后对不同的特征图（index）注意力权重分布。</p>]]></content>
      
      
      <categories>
          
          <category> Reading and Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WiFi Sensing </tag>
            
            <tag> AI </tag>
            
            <tag> Environment Generalization </tag>
            
            <tag> Pose Estimation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leggiero——反向散射标签</title>
      <link href="/2025/09/19/research/leggiero-by-yuan-he/"/>
      <url>/2025/09/19/research/leggiero-by-yuan-he/</url>
      
        <content type="html"><![CDATA[<h1 id="Leggiero-——-by-Yuan-He"><a href="#Leggiero-——-by-Yuan-He" class="headerlink" title="Leggiero —— by Yuan He"></a>Leggiero —— by Yuan He</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一种物理层上的实现方式，在每一个WiFi Packet上都进行调制，但是只调制每个包的特定部分：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921001.png" alt="Img">  </p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921011.png" alt="Img">  </p><p>在帧头存在一部分的保留区域，不影响通信，可以在这部分进行调制；</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921003.png" alt="Img">  </p><p>定义反射系数为反射的信号比入射的信号，理想情况设置两种反射系数，幅值都为1，但是相位呈现180翻转。</p><p>如何实现根据要传输的数据自行在两种反射系数之间进行切换？可以使用可变电容作为负载：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921008.png" alt="Img">  </p><p>此时的反射系数定义如下：</p><p>$$\boxed{\Gamma_C &#x3D; \frac{Z_C - Z_0}{Z_C + Z_0} &#x3D; \frac{1 - j2\pi f C Z_0}{1 + j2\pi f C Z_0} &#x3D; e^{j\theta_C}, \theta_C &#x3D; -2 \arctan(2\pi f C Z_0)}$$</p><p>这里我们让 $Z_0$ 为特征阻抗 $50Ω$</p><p>因此我们只需要根据需要发送的数据，改变电容的数值，便可实现反射系数的改变，从而调制数据。一种知觉方法是使用可变电容传感器实现，但是该方案面临两个问题：</p><ul><li>可移植性差，由于电容传感器限制了应用范围；</li><li>非线性电容变化，可解释性差；</li></ul><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921017.png" alt="Img">  </p><p>因此，选择使用电压信号控制电容大小，从而实现反射系数的改变是一个更好的选择，实现方式就是将负载更改为反向偏置PN结压控二极管。这种二极管的电容有两个优势：</p><ul><li>电容值小，意味着有很大的可变范围；</li><li>电容值变化平滑。</li></ul><p>例如，一种典型的GaAs材质的压控二极管在偏置电压为 $0-20V$ 时的电容在 $0.1-2.0pF$ 中变化。</p><p>最终的电路设计如下：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921014.png" alt="Img">  </p><p>偏置电压对应的支路添加一个电感，防止WiFi信号从偏置电路逸散；同理，在信号到地之间添加一个电容，防止偏置电压直接到地。同时又因为偏置电压被压控二极管和电容 $C_s$ 阻塞，因此几乎没有电流！这就意味着整个电路几乎不消耗能量！</p><h2 id="特殊点：负载透明性"><a href="#特殊点：负载透明性" class="headerlink" title="特殊点：负载透明性"></a>特殊点：负载透明性</h2><p>ESS，即Extra Spatial Sounding，是802.11n提出的一个长训练字段，位置在每一个packet的帧头：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921013.png" alt="Img">  </p><p>该字段用于MIMO系统中对空间流进行信道探测从而更好的进行信道信息估计，在WiFi中该字段没有使用，因此影响该字段即不影响帧头，也不影响payload，实现了传输的”透明性”。</p><p>因为有两段，一个是DLTF，另一个是ELTF，两个字段结构上相邻因此<strong>时间上可以认为是同时</strong>的，传输过程中经过的<strong>信道也相同</strong>，所以只需要定位到ELTF并切换反射系数，在接收端通过比较DLTF和ELTF的区别便可以得到调制的数据。</p><p>对整个包做信道估计，除去ELTF的部分称为参考部分，对应的CSI称为参考CSI；而ELTF则作为嵌入部分，对应的CSI为参考CSI，比较两者CSI对应的相位差可以得到只有Tag的影响（环境CSI在参考中消除了）。</p><p>由于环境中存在多个信号传输路径，因此存在没有被Tag影响的packet，如此在接收端容易导致自干扰，所以采取频谱搬移的手段，将反射的信号搬移20MHz到相邻信道。得益于负载和调制信号的交织，接收端只需要监听相邻信道不仅可以正常实现负载的接收，同时还能解调出Tag调制的信号。</p><p>问题是如何定位ELTF这部分呢？</p><p>文章提出的是通过时间进行定位。首先通过包检测电路判断是否有packet到达Tag，使用包络检波的手段同步数据帧，然后静默 $36 \mu s$，这是一个特定的事件，对应帧头ELTF前面部分的持续时间。等待静默后切换反射系数，嵌入数据，这个时间持续 $4 \mu s$。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921005.png" alt="Img">  </p><p>由于电感和电容组成的LC电路（阻直流），压控变容二极管的偏置电压并不会突发变化，而是缓慢的抖动上升。这种暂态过程可能会持续大概 $2\mu s$，影响帧的同步，从而影响通信的效果；</p><h2 id="信息解调"><a href="#信息解调" class="headerlink" title="信息解调"></a>信息解调</h2><p>接收机接受的调制信号对应CSI为：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921004.png" alt="Img">  </p><p>一个packet中除了HLTF部分是Hess​信道响应外，别的部分是常规CSI。</p><p>由于不同的电压值对应不同的反射系数，而CSI的估计存在误差，会对应表现在反射系数中，在通过相位反推电压时容易出现误差，因此我们将电压进行量化，分为不同的等级，给定了一定的相位误差阈值。</p><p>The number of segments determines the resolution of this sampling process. A higher segment number means higher throughput, but more errors may be introduced to digitization</p><p>为了防止自干扰，在Tag处添加了一个频谱搬移模块将调制的信号搬移到相邻信道；为了确定什么时候搬移信号，可以在接收机处发送一个激励信号（在原始信道中传输），告诉Tag搬移信号并且将接收机监听的信道调整为相邻信道；Tag接收到激励信号后使能频谱搬移，并按照调制的方式进行信号发送；</p>]]></content>
      
      
      <categories>
          
          <category> Reading and Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WiFi Backscatter </tag>
            
            <tag> Low-power consumption </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Densepose——基于UV坐标的高精度姿态估计</title>
      <link href="/2025/09/19/research/Densepose-from-wifi-By-jiaqi-gen/"/>
      <url>/2025/09/19/research/Densepose-from-wifi-By-jiaqi-gen/</url>
      
        <content type="html"><![CDATA[<h1 id="DensePose-From-WIFI-——-Jiaqi-Gen"><a href="#DensePose-From-WIFI-——-Jiaqi-Gen" class="headerlink" title="DensePose From WIFI —— Jiaqi Gen"></a>DensePose From WIFI —— Jiaqi Gen</h1><h3 id="文献综述：《DensePose-From-WiFi》"><a href="#文献综述：《DensePose-From-WiFi》" class="headerlink" title="文献综述：《DensePose From WiFi》"></a>文献综述：《DensePose From WiFi》</h3><p><strong>目的</strong>：论文旨在解决<strong>传统人体姿态估计</strong>方法面临的三大核心问题：</p><ol><li><strong>环境限制</strong>：RGB 相机在光照不佳或存在遮挡时性能会急剧下降；</li><li><strong>成本与功耗</strong>：LiDAR 和雷达等传感器价格昂贵且功耗高，难以在家庭等日常场景普及；</li><li><strong>隐私问题</strong>：在浴室、卧室等私密空间部署摄像头会引发严重的隐私担忧。<br>论文的最终目的是开发一种低成本、易于部署、保护隐私且对光照和遮挡鲁棒的新型人体感知技术，为智能家居、健康监护等应用铺平道路。</li></ol><p><strong>遇到的困难</strong>：   </p><ul><li>CSI是一维数据，与空间域的信息<strong>没有相关性</strong>，不像图片，每一个像素点都是是空间域的一个映射；   </li><li>前人没有相关研究，都是基于TOF、AOA的中心定位；</li></ul><p><strong>研究方法</strong>：<br>大致流程如下：首先采集信号的CSI，对CSI的幅值和相位进行预处理，包括采样、插值以及数据矫正。之后通过一个双支编码器，将幅值和相位vector编码为2D的feature maps，对应图像姿态识别中的原始图像（这里做了一个域转换：从WIFI信号域 → Feature Maps特征域； 1D → 2D）。最后类似于图像姿态识别，将2D的feature maps作为输入，得到最后的UV coordinates。   </p><ol><li><strong>数据预处理</strong>：对原始的信道状态信息（CSI）进行“相位净化”（Phase Sanitization），包括相位解包裹（unwrapping）、中值&#x2F;均值滤波去噪和线性拟合，以获得稳定可靠的相位信息。<br>      <img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921012.png" alt="Img">    </li><li><strong>模态转换网络</strong>（Modality Translation Network）：设计了一个双分支（幅度和相位）编码器-解码器网络。将CSI展平后输入编码器而不是通过卷积压缩，因为可能每一对收发天线的一个CSI都可以表征完整的空间信息。编码器使用MLP（而非CNN）将1D的CSI张量（150x3x3）映射到潜在空间，然后融合并重塑为2D特征图（24x24），再通过卷积和反卷积层上采样，最终输出一个模拟图像域的3x720x1280特征图。<br>      <img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921018.png" alt="Img">    </li><li><strong>WiFi-DensePose RCNN</strong>：将上述生成的2D特征图输入到一个修改版的 DensePose-RCNN 架构中。该架构采用 ResNet-FPN 作为骨干网络，并包含两个并行的预测头：一个用于预测24个身体部位的UV坐标（DensePose Head），另一个用于预测17个人体关键点的热力图（Keypoint Head），以提供额外的监督和约束。<br>      <img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921007.png" alt="Img">    </li><li><strong>迁移学习</strong>：为了加速训练并提升性能，论文采用了一种教师-学生框架。一个在COCO数据集上预训练的图像版 DensePose 模型作为“教师”，指导“学生”（即本文的WiFi模型）使其在多个层级的特征图上与教师模型的输出尽可能相似（通过MSE损失）。   </li><li><strong>损失函数</strong>：总损失包含目标检测损失（分类 <code>Lcls</code> 和边界框回归 <code>Lbox</code>）、DensePose损失 <code>Ldp</code>（分割和UV回归）、关键点损失 <code>Lkp</code> 和迁移学习损失 <code>Ltr</code>。</li></ol><p><strong>创新点</strong>   </p><ol><li><strong>首创性任务</strong>：首次提出并成功实现了<strong>仅使用WiFi信号进行稠密人体姿态估计</strong>的任务，将WiFi感知的粒度从稀疏关键点提升到了稠密表面级别。   </li><li><strong>突破物理限制</strong>：通过深度学习模型，成功地从理论上定位精度仅为0.5米的WiFi信号中，恢复出了远超此精度的稠密人体姿态，突破了传统ToF&#x2F;AoA方法的物理瓶颈。   </li><li><strong>新颖的网络架构</strong>：   <ul><li><strong>模态转换网络</strong>：创新性地使用MLP而非CNN来处理CSI数据的3x3维度，认为其代表的是全局场景摘要而非局部空间信息，并通过编码器-解码器结构将其转换为类图像的2D特征图。   </li><li><strong>相位净化方法</strong>：提出了一套有效的相位处理流程，充分挖掘了通常被忽视的CSI相位信息的价值。</li></ul></li><li><strong>有效的训练策略</strong>：通过引入关键点检测分支和从图像模型迁移学习，显著提升了模型的训练效率和最终性能，为解决数据匮乏问题提供了新思路。</li></ol><p><strong>研究结果</strong>：   </p><ul><li><strong>定量结果</strong>：在“相同布局”（Same Layout）的测试协议下，模型在人体检测（AP@50&#x3D;87.2）和稠密姿态估计（dpAP·GPS@50&#x3D;79.3）上取得了不错的效果，表明其能有效定位人体并估计大致姿态。但在更严格的指标（如AP@75, dpAP·GPS@75）上性能下降，说明对肢体等细节的估计仍有不足。   </li><li><strong>定性结果</strong>：可视化结果（图9, 10）显示，WiFi模型的预测结果与基于图像的DensePose结果在主体轮廓和主要关节位置上具有较高的一致性，验证了方法的可行性。   </li><li><strong>消融实验</strong>：证明了相位信息、关键点分支和迁移学习均能有效提升模型性能。特别是关键点分支对提升细节（如肢体）的估计效果显著。   </li><li><strong>跨域泛化</strong>：在“不同布局”（Different Layout）协议下，性能大幅下降（AP从43.5降至27.3），表明模型对环境变化非常敏感，泛化能力是当前的主要瓶颈。</li></ul><p><strong>可能的改进之处</strong>：   </p><ol><li><strong>泛化能力</strong>：最大的问题是模型在不同环境布局下的泛化性能差。未来工作需要收集更多样化的多布局数据，或研究更鲁棒的域自适应&#x2F;域泛化方法。   </li><li><strong>3D姿态与形状</strong>：论文目前输出的是2D UV坐标，未来可探索直接从WiFi信号恢复3D人体姿态甚至形状（如SMPL模型）。   </li><li><strong>实时性与轻量化</strong>：当前模型训练耗时长（约80小时），推理速度未提及。未来可研究模型压缩或设计更轻量级的网络以适应边缘设备。   </li><li><strong>多人场景与遮挡</strong>：论文指出在三人及以上或罕见姿态场景下性能会下降，需要更强大的网络或数据增强策略来解决。   </li><li><strong>数据依赖</strong>：模型依赖于用图像模型生成的伪标签进行训练，这引入了误差。未来可探索自监督或弱监督学习方法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Reading and Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WiFi Sensing </tag>
            
            <tag> AI </tag>
            
            <tag> Environment Generalization </tag>
            
            <tag> Pose Estimation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adapose——跨环境的人体关键点识别</title>
      <link href="/2025/09/18/research/Adapose-By-yunjiao-zhou/"/>
      <url>/2025/09/18/research/Adapose-By-yunjiao-zhou/</url>
      
        <content type="html"><![CDATA[<h1 id="AdaPose-——-Yunjiao-Zhou"><a href="#AdaPose-——-Yunjiao-Zhou" class="headerlink" title="AdaPose —— Yunjiao Zhou"></a>AdaPose —— Yunjiao Zhou</h1><h2 id="文献综述《AdaPose-Towards-Cross-Site-Device-Free-Human-Pose-Estimation-with-Commodity-WiFi》"><a href="#文献综述《AdaPose-Towards-Cross-Site-Device-Free-Human-Pose-Estimation-with-Commodity-WiFi》" class="headerlink" title="文献综述《AdaPose: Towards Cross-Site Device-Free Human Pose Estimation with Commodity WiFi》"></a>文献综述《AdaPose: Towards Cross-Site Device-Free Human Pose Estimation with Commodity WiFi》</h2><h3 id="独特的创新思想："><a href="#独特的创新思想：" class="headerlink" title="独特的创新思想："></a><strong>独特的创新思想：</strong></h3><ol><li><strong>不同域之间的差异如何泛化或者说对齐？</strong><ul><li>本篇论文不按照<strong>传统方式在特征空间分布上进行对齐</strong>，而是**提出从”映射规则”**上进行统一！</li><li>文章将整个模型分为三层：输入域中采集的CSI、中间层的特征空间、输出估计关键点的坐标，其中的映射规则包括<strong>将CSI信息映射成一个特征</strong>、<strong>将CSI信息映射成姿态关键点的坐标</strong>。</li><li>本文<strong>认可不同的域（源域、目标域）是存在本质差别</strong>的，文中通过 $D_{input}$、$D_{feature}$ 以及 $D_{output}$ 分别表示不同域最原始的差异（数据）、特征提取后的分布差异（缩放）、姿态估计的分布差异，且这些差异是必然存在的。<ul><li>传统方式：特征空间分布对齐，是通过调整 $D_{feature}$，将不同域采集的具有 $D_{input}$ 差异的CSI映射到相同的特征空间分布上 $D_{feature} &#x3D; 0$；</li><li>本文方式：由于<strong>强行修改特征空间的分布对于回归任务（坐标的估计）是不可取的（导致坐标的偏移、缩放）</strong>，因此定义两个比率 $R_{feat&#x2F;in} &#x3D; \frac{D_{feature}}{D_{input}}$ 和 $R_{out&#x2F;in} &#x3D; \frac{D_{output}}{D_{input}}$。可以理解为这个比率将不同域的差异（domain label）考虑了，但是又由于输入、特征、输出都有这个差异存在，因此<strong>不同域计算的比率是要相同</strong>的。</li></ul></li></ul></li></ol><h3 id="核心问题与挑战"><a href="#核心问题与挑战" class="headerlink" title="核心问题与挑战"></a>核心问题与挑战</h3><p>论文明确指出了当前WiFi姿态估计在跨域应用中面临的两大核心挑战：</p><ol><li><p><strong>任务本身的复杂性</strong>：姿态估计是一个<strong>细粒度的回归问题</strong>，需要从信息量有限且粗糙的CSI数据（相比图像的RGB三通道）中，精确预测出17个人体关节点的2D坐标。这要求模型必须能从CSI中提取出微妙而具有代表性的特征，而CSI数据本身在捕捉细微关节运动方面存在固有局限。</p></li><li><p><strong>环境干扰的主导性</strong>：在CSI数据中，由环境变化引起的干扰信号往往比由人体运动引起的有用信号<strong>强得多</strong>。这导致模型在进行领域自适应时，容易错误地去对齐环境噪声，而非真正的人体动态信息。现有的领域自适应方法大多在<strong>特征层面</strong>进行对齐，这对于分类任务有效，但对于回归任务却可能导致<strong>特征尺度（scale）的错位</strong>，从而破坏回归的准确性。</p></li></ol><h3 id="整体的实现流程："><a href="#整体的实现流程：" class="headerlink" title="整体的实现流程："></a>整体的实现流程：</h3><p>首先在一个确定的环境中进行训练，我们称这个环境为<strong>源域（Source domain）</strong>。训练的流程大致如下：</p><ul><li><p>采集源域中的WiFi CSI数据，并使用同步摄像头拍摄视频。利用视觉姿态估计模型（如HRNet）处理视频帧，自动生成精确的2D人体骨骼关键点坐标（17个关节点），作为CSI数据的”伪标签”，从而得到带标签的CSI-姿态对样本。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921020.png" alt="Img"></p></li><li><p>得到用于训练的样本后，首先训练一个端到端的WiFi姿态估计基线模型（如WPNet），该模型包含特征提取器（E）和回归器（R）。<strong>特征提取器将CSI数据映射到一个高维特征空间</strong>，回归器则<strong>将该特征映射为最终的17x2姿态坐标</strong>。通过计算预测姿态与伪标签之间的均方误差（MSE）损失，反向传播优化模型参数，使源域中任意CSI输入都能通过该模型准确预测出对应的人体姿态。</p></li></ul><p>在源域中能够进行高精度姿态估计后，下一步就是进行<strong>跨场景的泛化</strong>，实现步骤如下：</p><ul><li><p>采集目标域中少量带标签（弱监督）或完全无标签（无监督）的姿态对应CSI数据。AdaPose的核心不在于直接对齐源域和目标域的特征分布，而在于<strong>对齐它们从”输入(CSI)到输出(姿态)”的映射关系</strong>。</p></li><li><p>通过引入**”映射一致性损失”（Mapping Consistency Loss）<strong>来实现这一目标：该损失计算源域和目标域在</strong>“输入(CSI)”、”中间特征”和”输出(预测姿态)”三个层级<strong>上的分布差异（使用MMD度量），并约束</strong>“特征-输入”<strong>和</strong>“输出-输入”**的差异比率向预设的稳定值收敛。这个过程迫使模型学习一种不受环境动态影响的、内在一致的映射规则，从而在不改变特征尺度的前提下，实现跨域的姿态估计能力迁移。</p><ul><li>使用<strong>最大均值差异（Maximum Mean Discrepancy, MMD）</strong> 作为度量工具，分别计算源域（S）和目标域（T）在三个层级上的分布差异：</li><li><code>D_input</code>：源域和目标域<strong>输入CSI数据</strong>的分布差异。</li><li><code>D_feature</code>：源域和目标域<strong>中间特征</strong>的分布差异。</li><li><code>D_output</code>：源域和目标域<strong>最终预测姿态</strong>的分布差异。</li></ul><p>MMD是一种衡量两个分布之间距离的核方法，其值越大，表示两个分布差异越大。</p><p>不直接最小化 <code>D_feature</code> 或 <code>D_output</code>，而是计算它们与 <code>D_input</code> 的<strong>比率</strong>：</p><ul><li><strong>特征-输入一致性比率</strong>： <code>R_feat/in = D_feature / D_input</code></li><li><strong>输出-输入一致性比率</strong>： <code>R_out/in = D_output / D_input</code></li></ul><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250921028.png" alt="Img"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Reading and Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WiFi Sensing </tag>
            
            <tag> AI </tag>
            
            <tag> Environment Generalization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Simulink的通信系统仿真</title>
      <link href="/2025/09/09/study/Simulink%E4%BB%BF%E7%9C%9F/"/>
      <url>/2025/09/09/study/Simulink%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="通信原理——Simulink仿真"><a href="#通信原理——Simulink仿真" class="headerlink" title="通信原理——Simulink仿真"></a>通信原理——Simulink仿真</h1><h2 id="模拟调制"><a href="#模拟调制" class="headerlink" title="模拟调制"></a>模拟调制</h2><h3 id="FM-——-角度调制"><a href="#FM-——-角度调制" class="headerlink" title="FM —— 角度调制"></a>FM —— 角度调制</h3><h4 id="FM-发射机"><a href="#FM-发射机" class="headerlink" title="FM 发射机"></a>FM 发射机</h4><p>Simulink FM 调制框图展示：<br><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250909001.png" alt="image">    </p><p>上述框图是离散时间的调频调制器，主要框架及原理如下：<br><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250909004.png" alt="image">    </p><ol><li>来自 DSP 的基带消息信号，表示调制信号；通过一个增益块，乘上 $K_f$，表示每一伏电压对频率的影响因素。  </li><li>常量模块 <code>2π * 300</code>，表示载波的角频率部分。<br><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250909003.png" alt="image"></li></ol><p>将两个分量相加得到已调信号的瞬时频率，再通过离散时间域上的积分器实现调频：  </p><p>$$<br>H(z) &#x3D; \frac{K T_s}{z-1}<br>$$</p><p>已知调频信号的一般数学形式为：  </p><p>$$<br>s(t) &#x3D; A_c \cos \Big( 2 \pi f_c t + K_f \int m(t) , dt \Big)<br>$$  </p><p>已调信号的瞬时频率随着时间而改变。上述式子是以 $PM$ 的形式实现的 $FM$，对整个 $\phi (t)$ 求导可以发现瞬时频率与 $m(t)$ 有关：  </p><p>$$<br>f_s &#x3D; 2\pi f_c + K_f m(t)<br>$$  </p><ul><li><strong>载波频率</strong>： $f_c &#x3D; 300 ,\text{Hz}$  </li><li><strong>调制信号</strong>： $m(t)$，由 DSP 输出  </li><li><strong>调频灵敏度</strong>： $K_f &#x3D; 2\pi \cdot 300$  </li><li><strong>积分器</strong>：实现 $\int m(t) , dt$，相位与输入消息相关  </li><li><strong>余弦函数</strong>：生成调频信号  </li><li><strong>幅度调制</strong>：由系数 $A_c$ 控制</li></ul><p>因此，输出信号可以表示为：  </p><p>$$<br>s(t) &#x3D; A_c \cos \Big( 2\pi f_c t + K_f \int m(t) dt \Big)<br>$$  </p><hr><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250909002.png" alt="image">    </p><h4 id="FM-解调机"><a href="#FM-解调机" class="headerlink" title="FM 解调机"></a>FM 解调机</h4><ol><li><p><strong>差分运算</strong> $\dfrac{z-1}{z}$  </p><ul><li>实现输入信号的差分（类似微分器）。  </li><li>在离散时间中，$(z-1)&#x2F;z$ 对应：  </li><li>物理意义：从输入 FM 信号中提取相位的变化（即瞬时频率）。</li></ul></li><li><p><strong>取绝对值</strong> $|u|$  </p><ul><li>得到差分信号的幅度，避免相位正负变化带来的符号翻转。</li></ul></li><li><p><strong>平方</strong> ($u^v, v&#x3D;2$)  </p><ul><li>对信号平方，等价于能量检测。  </li><li>FM 的瞬时频率与信号相位的变化率有关，平方后可以稳定地恢复与消息信号成比例的包络。</li></ul></li><li><p><strong>低通滤波器 (Lowpass)</strong>  </p><ul><li>经过差分和平方后，信号中包含高频分量（载波分量）。  </li><li>低通滤波器去除高频，只保留基带分量，即解调出的消息信号 $m(t)$。</li></ul></li></ol><hr><p>FM 已调信号通过差分器后：  </p><p>$$<br>\dot{s}(t)&#x3D;\frac{d}{dt}\big[A_c\cos\theta(t)\big]<br>&#x3D; -A_c\sin\theta(t),\dot{\theta}(t)<br>&#x3D; -A_c,\omega_i(t),\sin\theta(t)<br>$$  </p><p>相位信息通过求导成功从余弦函数中提取出来。对输出的结果进行平方：  </p><p>$$<br>y^2(t) \propto A_c^2,\omega_i^2(t),\sin^2\theta(t)<br>&#x3D; \frac{A_c^2}{2},\omega_i^2(t),\big(1-\cos 2\theta(t)\big)<br>$$  </p><p>将平方后的信号通过低通滤波，可以滤去高频的信号，从而得到信息信号（带有直流偏置）：  </p><p>$$<br>u_{\text{LP}}(t);\propto;\omega_i^2(t)<br>&#x3D; \big(2\pi f_c + K_f m(t)\big)^2<br>&#x3D; (2\pi f_c)^2 + 2(2\pi f_c)K_f,m(t) + K_f^2 m^2(t)<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 通信原理 </category>
          
          <category> MATLAB </category>
          
          <category> Simulink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> Knowledge </tag>
            
            <tag> communication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通信原理——模拟调制</title>
      <link href="/2025/09/07/study/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86_%E6%A8%A1%E6%8B%9F%E8%B0%83%E5%88%B6/"/>
      <url>/2025/09/07/study/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86_%E6%A8%A1%E6%8B%9F%E8%B0%83%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="通信原理——MATLAB仿真"><a href="#通信原理——MATLAB仿真" class="headerlink" title="通信原理——MATLAB仿真"></a>通信原理——MATLAB仿真</h1><h2 id="Analog-Modulation-模拟调制"><a href="#Analog-Modulation-模拟调制" class="headerlink" title="Analog Modulation 模拟调制"></a>Analog Modulation 模拟调制</h2><h3 id="幅度调制-——-AM"><a href="#幅度调制-——-AM" class="headerlink" title="幅度调制 —— AM"></a>幅度调制 —— AM</h3><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250908005.png" alt="image"><br>上图为MATLAB仿真的AM波形，代码如下：   </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">f0 = <span class="number">50</span>;    <span class="comment">% Carrier Freq: 50Hz</span></span><br><span class="line">fm = <span class="number">15</span>;    <span class="comment">% Message Freq: 24Hz</span></span><br><span class="line"></span><br><span class="line">num_points = <span class="number">4096</span>;</span><br><span class="line">t0 = <span class="number">1</span> / f0;</span><br><span class="line">t = <span class="number">1</span>:t0:num_points*t0;</span><br><span class="line"></span><br><span class="line">Am = <span class="number">1</span>;     <span class="comment">% Amplitude of Message Signal</span></span><br><span class="line">Ac = <span class="number">1</span>;     <span class="comment">% Amplitude of Carrier Signal</span></span><br><span class="line"></span><br><span class="line">mt = Am * <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fm * t);</span><br><span class="line">st = Ac * (<span class="number">1</span> + mt) .* <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * f0 * t);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(t, st, <span class="string">&#x27;-ob&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (s)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Amplitude Modulated Signal&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><p>这里我们设置信息频率与载波频率分别为 $15Hz, 50Hz$，可以自行尝试不同的频率选择，不同的频率得到的调制信号不相同。   </p><p>AM的调制公式如下：   </p><p>$$S(t) &#x3D; A_{c} (1 + m(t)) \cos{2\pi f_{c}t}$$   </p><p>如果信息 $m(t)$ 的幅度超过 $1$，则会出现过调制的问题，详见下：   </p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250908009.png" alt="image"><br>对比两幅图片可以明显的发现红色方框处出现了过调制的问题。   </p><p>下面计算AM调制的功率、实际功率、调制效率以及功率谱：   </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">beta</span> = (<span class="built_in">max</span>(st) - Ac) / Ac;         <span class="comment">% Modulation Index</span></span><br><span class="line">mu = Am / Ac;                       <span class="comment">% Modulation Depth</span></span><br><span class="line">Ps = (<span class="number">1</span>/<span class="number">2</span>) * Ac^<span class="number">2</span> * <span class="built_in">mean</span>(<span class="number">1</span> + mt.^<span class="number">2</span>);<span class="comment">% Power of the Modulated Signal</span></span><br><span class="line">Pc = (<span class="number">1</span>/<span class="number">2</span>) * Ac^<span class="number">2</span>;                  <span class="comment">% Power of the Carrier Signal</span></span><br><span class="line">Pm = (<span class="number">1</span>/<span class="number">2</span>) * Ac^<span class="number">2</span> * <span class="built_in">mean</span>(mt.^<span class="number">2</span>);    <span class="comment">% Power of the Message Signal</span></span><br><span class="line">efficiency = (Pm / Ps) * <span class="number">100</span>;       <span class="comment">% Efficiency of the Modulated Signal</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=== AM信号功率分析 ===</span><br><span class="line">调制深度 (μ): 1.200</span><br><span class="line">载波功率: 0.500 W</span><br><span class="line">理论总功率: 0.860 W</span><br><span class="line">实际总功率: 0.360 W</span><br><span class="line">调制效率: 41.84%</span><br></pre></td></tr></table></figure><p>功率谱如下：   </p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250908003.png" alt="image">    </p><hr><h3 id="DSB-SC-——-双边带抑制载波"><a href="#DSB-SC-——-双边带抑制载波" class="headerlink" title="DSB-SC —— 双边带抑制载波"></a>DSB-SC —— 双边带抑制载波</h3><p>是一种<strong>线性幅度调制</strong>方式，属于 AM 调制家族，但与常规 AM 不同，它<strong>不发送载波分量</strong>，仅发送<strong>上下两个边带</strong>。   </p><p>从公式上观察，DSB-SC的调制信号没有直流偏置的存在：   </p><p>$$s_{DSB-SC}(t) &#x3D; m(t) \cos(2 \pi f_c t)$$   </p><p>对应的频域公式为：   </p><p>$$S_{DSB-SC}(f) &#x3D; \frac{1}{2} \left[ M(f - f_c) + M(f + f_c)  \right]$$   </p><p>这样的好处是，节省了载波的功率，从某种意义上来说等价于<strong>过调制</strong>的存在。   </p><p>但是由于过调制，导致DSB-SC的解调不能像AM一样通过简单的包络检波实现，因为此时的包络与调制信号不成正比；而是需要使用相干解调，这就需要接收端产生本振，节省的载波能量以另一种形式消耗了。   </p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250908004.png" alt="image">    </p><p>实现代码如下：   </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">num_points = <span class="number">16384</span>;</span><br><span class="line"></span><br><span class="line">Am = <span class="number">1</span>;</span><br><span class="line">fm = <span class="number">15</span>;</span><br><span class="line">Tm = <span class="number">1</span> / fm;</span><br><span class="line">t = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">4</span> * Tm, num_points);</span><br><span class="line"></span><br><span class="line">mt = Am * <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fm * t);</span><br><span class="line"></span><br><span class="line">fc = <span class="number">200</span>;</span><br><span class="line">Ac = <span class="number">1</span>;</span><br><span class="line">st = Ac * mt .* <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc * t);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, mt, <span class="string">&#x27;-k&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Message Signal&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, st, <span class="string">&#x27;-b&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (s)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;DSB-SC Modulated Signal&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><p>对应的频谱和功率谱如下：   </p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250908007.png" alt="image">    </p><p>纵轴的数值异常是由于没有功率归一化导致的，具体脚本如下：   </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">num_spectrum = num_points;</span><br><span class="line"></span><br><span class="line">fs = num_points / (<span class="number">4</span> * Tm);</span><br><span class="line">f = <span class="built_in">linspace</span>(-fs/<span class="number">2</span>, fs/<span class="number">2</span>, num_spectrum);</span><br><span class="line">St_fft = fftshift(fft(st));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(f, <span class="built_in">abs</span>(St_fft), <span class="string">&#x27;r-&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;频率 (Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;幅度&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;DSB-SC信号频谱&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(f, <span class="built_in">abs</span>(St_fft).^<span class="number">2</span>/<span class="built_in">length</span>(st), <span class="string">&#x27;r-&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;频率 (Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;功率谱密度&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;DSB-SC信号功率谱&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><p>通过对调制信号和已调信号的功率分析，发现所有的功率全部用于调制信号并发送，<strong>调制效率理论上是100%</strong>！   </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BW_before = fm;</span><br><span class="line">BW_after = <span class="number">2</span> * fm;</span><br><span class="line">Ps = (<span class="number">1</span>/<span class="number">2</span>) * Ac^<span class="number">2</span> * <span class="built_in">mean</span>(mt.^<span class="number">2</span>);    <span class="comment">% Power of the Modulated Signal</span></span><br><span class="line">Pc = <span class="number">0</span>;                              <span class="comment">% Power of the Carrier Signal</span></span><br><span class="line">Pm = (<span class="number">1</span>/<span class="number">2</span>) * Ac^<span class="number">2</span> * <span class="built_in">mean</span>(mt.^<span class="number">2</span>);    <span class="comment">% Power of the Message Signal</span></span><br><span class="line">efficiency = (Pm / Ps) * <span class="number">100</span>;       <span class="comment">% Efficiency of the Modulated</span></span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;=== DSB-SC信号功率分析 ===\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;载波功率: %.3f W\n&#x27;</span>, Pc);</span><br><span class="line">fprintf(<span class="string">&#x27;理论总功率: %.3f W\n&#x27;</span>, Ps);</span><br><span class="line">fprintf(<span class="string">&#x27;实际总功率: %.3f W\n&#x27;</span>, Pm);</span><br><span class="line">fprintf(<span class="string">&#x27;调制效率: %.2f%%\n&#x27;</span>, efficiency);</span><br></pre></td></tr></table></figure><h3 id="SSB-SC-——-单边带抑制载波"><a href="#SSB-SC-——-单边带抑制载波" class="headerlink" title="SSB-SC —— 单边带抑制载波"></a>SSB-SC —— 单边带抑制载波</h3><p>基本原理与DSB-SC相同，只不过DSB-SC调制完后包含有两个边带，上边带（USB）和下边带（LSB），而SSB-SC就是只保留其中一个边带，节省带宽。   </p><p>原来的DSB-SC频谱如下：   </p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250908010.png" alt="image">    </p><p>如何实现SSB-SC呢？我们一般从频域入手：   </p><ol><li>滤波法（最直观）</li></ol><ul><li>先生成 DSB-SC 信号   </li><li>用<strong>理想边带滤波器</strong>滤除一个边带   </li><li>⚠️ 缺点：当 $f_m$很小（如语音信号 $300Hz$）而 $f_c$很大（如 $1MHz$），边带靠得太近，物理滤波器难以实现陡峭截止</li></ul><ol start="2"><li>相移法（Hilbert 变换法）<br>利用 Hilbert 变换构造解析信号：<br>$$s_{SSB}(t)&#x3D;\frac{1}{2}[m(t)cos(2πf_c t) ∓ \hat{m}(t)sin(2πf_c t)]$$</li></ol><ul><li>上边带（USB）取 “−”   </li><li>下边带（LSB）取 “+”   </li><li>$\hat{m}(t)$是 $m(t)$的 $Hilbert$变换（相移 $-90°$）</li></ul><p>📌 优点：无需陡峭滤波器，适合宽带&#x2F;低频基带信号   </p><p>知识点补充——希尔伯特变换得到解析信号：   </p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250908002.png" alt="image">    </p><p>通过上述可以得到单边带信号；   </p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250908008.png" alt="image">    </p><p>上图是基于相移法得到的单边带调制，实现代码如下：   </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">num_points = <span class="number">16384</span>;</span><br><span class="line"></span><br><span class="line">Am = <span class="number">1</span>;</span><br><span class="line">fm = <span class="number">15</span>;</span><br><span class="line">Tm = <span class="number">1</span> / fm;</span><br><span class="line">t = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">4</span> * Tm, num_points);</span><br><span class="line">mt = Am * <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fm * t);</span><br><span class="line"></span><br><span class="line">mt_hilbert = hilbert(mt);</span><br><span class="line">mt_hat = <span class="built_in">imag</span>(mt_hilbert);  <span class="comment">% Hilbert Transform</span></span><br><span class="line"></span><br><span class="line">fc = <span class="number">300</span>;</span><br><span class="line">Ac = <span class="number">1</span>;</span><br><span class="line">st_USB = (<span class="number">1</span> / <span class="number">2</span>) * Ac * (mt .* <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc * t) - mt_hat .* <span class="built_in">sin</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc * t));</span><br><span class="line">st_LSB = (<span class="number">1</span> / <span class="number">2</span>) * Ac * (mt .* <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc * t) + mt_hat .* <span class="built_in">sin</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc * t));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, st_USB, <span class="string">&#x27;-b&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(t, st_LSB, <span class="string">&#x27;--r&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (s)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;SSB-SC Modulated Signal (USB &amp; LSB)&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;USB&#x27;</span>, <span class="string">&#x27;LSB&#x27;</span>);</span><br><span class="line"></span><br><span class="line">num_spectrum = num_points;</span><br><span class="line">fs = num_spectrum / (<span class="number">4</span> * Tm);</span><br><span class="line">f = <span class="built_in">linspace</span>(-fs/<span class="number">2</span>, fs/<span class="number">2</span>, num_spectrum);</span><br><span class="line">St_USB_fft = fftshift(fft(st_USB));</span><br><span class="line">St_LSB_fft = fftshift(fft(st_LSB));</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(f, <span class="built_in">abs</span>(St_USB_fft) / num_spectrum, <span class="string">&#x27;b-&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.5</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Magnitude&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;SSB-SC Signal Spectrum (USB)&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(f, <span class="built_in">abs</span>(St_LSB_fft) / num_spectrum, <span class="string">&#x27;r-&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;频率 (Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Magnitude&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;SSB-SC Signal Spectrum (LSB)&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><h3 id="角度调制-——-FM"><a href="#角度调制-——-FM" class="headerlink" title="角度调制 —— FM"></a>角度调制 —— FM</h3><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250908006.png" alt="image">    </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">num_points = <span class="number">16384</span>;</span><br><span class="line"></span><br><span class="line">fm = <span class="number">60</span>;</span><br><span class="line">Tm = <span class="number">1</span> / fm;</span><br><span class="line">t = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">4</span> * Tm, num_points);</span><br><span class="line"></span><br><span class="line">Am = <span class="number">1</span>;</span><br><span class="line">Kf = <span class="number">100</span>;        <span class="comment">% Hz/Volt 每伏特对应多少的频率偏移</span></span><br><span class="line">mt = Am * <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fm * t);</span><br><span class="line"></span><br><span class="line">fc = <span class="number">300</span>;</span><br><span class="line">Ac = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">integral_mt = cumtrapz(t, mt);</span><br><span class="line">phi = <span class="number">2</span> * <span class="built_in">pi</span> * fc * t + <span class="number">2</span> * <span class="built_in">pi</span> * Kf * integral_mt;  <span class="comment">% 相位 以PM的方式调制FM</span></span><br><span class="line">st = Ac * <span class="built_in">cos</span>(phi);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, mt, <span class="string">&#x27;-k&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Message Signal&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, st, <span class="string">&#x27;-r&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time (s)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Frequency Modulated Signal&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><p>计算功率谱（频谱）可以看到有多个边带：   </p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250908001.png" alt="image">    </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">num_spectrum = num_points;</span><br><span class="line">fs = num_spectrum / (<span class="number">4</span> * Tm);</span><br><span class="line">f = <span class="built_in">linspace</span>(-fs/<span class="number">2</span>, fs/<span class="number">2</span>, num_spectrum);</span><br><span class="line">St_fft = fftshift(fft(st));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(f, <span class="built_in">abs</span>(St_fft)/<span class="built_in">max</span>(<span class="built_in">abs</span>(St_fft)), <span class="string">&#x27;r-&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.5</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Magnitude&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;FM信号频谱&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(f, <span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(St_fft)/<span class="built_in">max</span>(<span class="built_in">abs</span>(St_fft))), <span class="string">&#x27;r-&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;频率 (Hz)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;功率谱密度&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;FM信号功率谱&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><p>这是因为<strong>FM 是非线性调制，会导致在频谱上出现频偏</strong>，导致<strong>带宽的扩展</strong>以及<strong>无限多的频谱</strong>！   </p><p>与 AM（幅度调制）不同，FM 是一种<strong>非线性调制方式</strong>，其已调信号可以展开为一个<strong>无穷级数</strong>，包含载波和无数对边频分量。   </p><p>对于单音 FM 信号：   </p><p>$$s(t) &#x3D; A_c \cos{(2 \pi f_c t + \beta \sin{2 \pi f_m t})}$$   </p><p>对于上述FM调制信号来说，其傅里叶展开为无穷级数：   </p><p>$$s(t) &#x3D; A_c \sum_{n&#x3D;-\infty}^{\infty} J_n(\beta) \cos\left[2\pi (f_c + n f_m)t\right]$$   </p><p>其中：   </p><ul><li>$Jn(β)$：<strong>第$n$阶第一类贝塞尔函数</strong>（Bessel function）   </li><li>$β$：调制指数（代码中约为 0.67）   </li><li>$fm$：调制信号频率（30 Hz）   </li><li>$fc$：载波频率（100 Hz）</li></ul><p>因为参数的设定（1000Hz采样率，4096个点，频谱分辨率0.24Hz），因此可以清晰的看到不同的峰值。   </p><ul><li>$Kf&#x3D;20Hz&#x2F;V, Am&#x3D;1⇒Δf&#x3D;20Hz$   </li><li>$β&#x3D;\frac{fm}{Δf}&#x3D;\frac{30}{20}≈0.67$</li></ul><p>所以计算第一类贝塞尔曲线函数可得：   </p><ul><li>$J0(0.67)≈0.8$→ 主载波较强   </li><li>$J1(0.67)≈0.32$→ 第一阶边带明显   </li><li>$J2(0.67)≈0.06$→ 第二阶较弱但仍可见   </li><li>更高阶迅速衰减</li></ul><p>因此设置不同的参数可以有很明显的频谱差异。   </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 最大频偏 (Maximum Frequency Deviation)</span></span><br><span class="line">delta_f = Kf * Am;  <span class="comment">% Hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 最大相偏 (Maximum Phase Deviation)</span></span><br><span class="line">delta_phi = delta_f / fm;  <span class="comment">% rad</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 调频指数 (Modulation Index)</span></span><br><span class="line">beta_fm = delta_f / fm;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 带宽计算</span></span><br><span class="line"><span class="comment">% Carson带宽规则: BW = 2(Δf + fm)</span></span><br><span class="line">BW_carson = <span class="number">2</span> * (delta_f + fm);  <span class="comment">% Hz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 近似带宽 (当β &gt; 1时)</span></span><br><span class="line"><span class="keyword">if</span> beta_fm &gt; <span class="number">1</span></span><br><span class="line">    BW_approx = <span class="number">2</span> * delta_f;  <span class="comment">% 宽带FM</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    BW_approx = <span class="number">2</span> * fm;       <span class="comment">% 窄带FM</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 瞬时频率计算</span></span><br><span class="line">dt = t(<span class="number">2</span>) - t(<span class="number">1</span>);</span><br><span class="line">inst_freq = fc + Kf * mt;  <span class="comment">% 瞬时频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 功率计算</span></span><br><span class="line">P_fm = <span class="built_in">mean</span>(st.^<span class="number">2</span>);         <span class="comment">% FM信号功率</span></span><br><span class="line">P_carrier = Ac^<span class="number">2</span> / <span class="number">2</span>;       <span class="comment">% 理论载波功率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 结果显示</span></span><br><span class="line">fprintf(<span class="string">&#x27;=== FM信号参数分析 ===\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;载波频率 (fc): %.1f Hz\n&#x27;</span>, fc);</span><br><span class="line">fprintf(<span class="string">&#x27;调制频率 (fm): %.1f Hz\n&#x27;</span>, fm);</span><br><span class="line">fprintf(<span class="string">&#x27;频率灵敏度 (Kf): %.1f Hz/V\n&#x27;</span>, Kf);</span><br><span class="line">fprintf(<span class="string">&#x27;调制信号幅度 (Am): %.1f V\n&#x27;</span>, Am);</span><br><span class="line">fprintf(<span class="string">&#x27;最大频偏 (Δf): %.1f Hz\n&#x27;</span>, delta_f);</span><br><span class="line">fprintf(<span class="string">&#x27;最大相偏 (Δφ): %.2f rad\n&#x27;</span>, delta_phi);</span><br><span class="line">fprintf(<span class="string">&#x27;调频指数 (β): %.2f\n&#x27;</span>, beta_fm);</span><br><span class="line">fprintf(<span class="string">&#x27;Carson带宽: %.1f Hz\n&#x27;</span>, BW_carson);</span><br><span class="line">fprintf(<span class="string">&#x27;近似带宽: %.1f Hz\n&#x27;</span>, BW_approx);</span><br><span class="line">fprintf(<span class="string">&#x27;信号功率: %.3f W\n&#x27;</span>, P_fm);</span><br><span class="line">fprintf(<span class="string">&#x27;理论功率: %.3f W\n&#x27;</span>, P_carrier);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> beta_fm &gt; <span class="number">1</span></span><br><span class="line">    fprintf(<span class="string">&#x27;调制类型: 宽带FM\n&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    fprintf(<span class="string">&#x27;调制类型: 窄带FM\n&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>相关的参数计算如上，本脚本的参数如下：   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">=== FM信号参数分析 ===</span><br><span class="line">载波频率 (fc): 300.0 Hz</span><br><span class="line">调制频率 (fm): 60.0 Hz</span><br><span class="line">频率灵敏度 (Kf): 100.0 Hz/V</span><br><span class="line">调制信号幅度 (Am): 1.0 V</span><br><span class="line">最大频偏 (Δf): 100.0 Hz</span><br><span class="line">最大相偏 (Δφ): 1.67 rad</span><br><span class="line">调频指数 (β): 1.67</span><br><span class="line">Carson带宽: 320.0 Hz</span><br><span class="line">近似带宽: 200.0 Hz</span><br><span class="line">信号功率: 0.500 W</span><br><span class="line">理论功率: 0.500 W</span><br><span class="line">调制类型: 宽带FM</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 通信原理 </category>
          
          <category> MATLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> Knowledge </tag>
            
            <tag> communication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Ubuntu22.04的UHD安装指引</title>
      <link href="/2025/06/06/research/usrp_uhd_download/"/>
      <url>/2025/06/06/research/usrp_uhd_download/</url>
      
        <content type="html"><![CDATA[<h2 id="！！！本指引是基于以下环境实现的！！！"><a href="#！！！本指引是基于以下环境实现的！！！" class="headerlink" title="！！！本指引是基于以下环境实现的！！！"></a>！！！本指引是基于以下环境实现的！！！</h2><ol><li>Ubuntu22.04</li><li>注意：英语系统</li><li>需要Linux系统支持的VPN，涉及到网络环境</li></ol><p>如果对uhd驱动的版本没有要求的话，推荐直接使用默认安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:ettusresearch/uhd</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install libuhd-dev uhd-host</span><br></pre></td></tr></table></figure><p>上述指令想要不报错的运行就需要系统在安装时选择英文系统，这就跟window系统的中文路径一样；</p><hr><p>上述指令后uhd驱动就已经安装好了！如果你使用的USRP跟我一样是B210或者B200mini，B200系列的话，你还需要以下指令给这些USRP安装额外的驱动，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /lib/uhd/utils</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> uhd-usrp.rules /etc/udev/rules.d/</span><br><span class="line"><span class="built_in">sudo</span> udevadm control --reload-rules</span><br><span class="line"><span class="built_in">sudo</span> udevadm trigger</span><br></pre></td></tr></table></figure><p>在运行上述第一条指令时推荐到桌面的上级目录开始执行，只需要在前面加一句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure><p>即可输入后续的指令：</p><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>给设备下载固件镜像，不然你的电脑很可能识别不到你的设备；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">sudo</span> uhd_images_downloader</span><br></pre></td></tr></table></figure><p>上述指令中的第一句是我个人自己添加的，不清楚是否可行；</p><p>如果你是一步一步按照上面来的话，在运行完安装驱动的指令后，你所处的目录应该是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/lib/uhd/utils</span><br></pre></td></tr></table></figure><p>本人验证过，在这个目录下可以直接运行固件的下载指令，后续运行也没有问题，如果担心目录改变导致运行报错的话，请自行忽略 <code>cd ~</code> 这一句。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USRP </tag>
            
            <tag> UHD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能基础复习笔记</title>
      <link href="/2025/06/01/study/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
      <url>/2025/06/01/study/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h1><h1 id="聚类分析——无监督"><a href="#聚类分析——无监督" class="headerlink" title="聚类分析——无监督"></a>聚类分析——无监督</h1><h2 id="什么是聚类分析："><a href="#什么是聚类分析：" class="headerlink" title="什么是聚类分析："></a>什么是聚类分析：</h2><p><strong>问题：给你一堆样本，如何通过样本间可能存在的联系将这些样本分为不同的类别？</strong><br>这些样本没有原本<strong>正确</strong>的类别，这种我们称为无监督（无标记的样本），希望寻找样本中存在的<strong>自然</strong>的聚类。</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(5).png" alt="001"></p><p>而对于原本就<strong>有标记</strong>的聚类行为我们称为分类，希望能够将混在一起的不同样本区分开来，这些样本的某写特征可能很相似，但是因为是不同标记，因此我们需要分开这些样本，这里与聚类的行为<strong>完全不同！</strong></p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(2).png" alt="002"></p><p>对于一个详细的实物，我们如何使用计算机对他们进行处理，这就要求我们对实物的本体或者特征抽象为一个个特征向量，通过<strong>特征向量的距离</strong>来表征相似性！所以，如何抽象出特征向量决定了聚类的准确性。</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(17).png" alt="003"></p><p>上面的例子就体现出了特征的选取在聚类中起到至关重要的作用！</p><h2 id="特征相似性的测度和聚类准则"><a href="#特征相似性的测度和聚类准则" class="headerlink" title="特征相似性的测度和聚类准则"></a>特征相似性的测度和聚类准则</h2><p>最常见的，我们使用欧氏距离表征两个特征向量之间的距离：</p><p>$$<br>d(x, y) &#x3D; \sqrt{(x - y)^T (x - y)} &#x3D; \sqrt{\sum_{i&#x3D;1}^n (x_i - y_i)^2}<br>$$</p><p>注意，这里的计算需要在同一个量纲下。</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(3).png" alt="004"></p><p>在第一种情况下，你会发现学生身高对欧氏距离的影响在体重面前完全不值一提，就算此时身高相差1m对于两个学生对应特征向量之间的欧氏距离影响也微乎其微；而第二种，两种特征对欧氏距离都有较大的影响因子（用于表征该特征对欧氏距离的影响力）。</p><hr><p>对于上面的这个问题，推出了马氏距离归一化样本特征之间的相关性：</p><p>$$<br>d(x, y) &#x3D; \sqrt{(x - y)^T S^{-1} (x - y)}<br>$$</p><p>欧式距离中，完全是<strong>特征向量中对应分量相乘</strong>，再相加得到，如果某一项的值非常大，那么其值就会掩盖值小的一项所起到的作用，这是欧式距离的不足；当采用马氏距离，就可以屏蔽这一点，因为相关性强的一个分量，对应于<strong>协方差矩阵C中对角线上的那一项的值就会大</strong>一些。再将这一项<strong>取倒数</strong>，减小该影响。</p><p>通过上面的描述你也可以发现，马氏距离对特征向量中每一个分量都做了归一化，并且由于协方差的量纲与原始分量相同，所以马氏距离的结果<strong>与原始数据的量纲无关</strong>。</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(1).png" alt="005"></p><p>左图是欧氏距离，右图是马氏距离。左图中，A, B到均值的距离相同，因此都在同一个圆上，忽略了数据的分布（量纲）的不同；右图中，通过协方差矩阵调整了$X_{1}, X_{2}$从而使得虽然A, B之间的马氏距离不同但是更符合数据的分布。</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(19).png" alt="006"></p><p>上图中更是反映出，欧氏距离的等高线是以原点为中心的圆分布，右边的马氏距离等高线与数据的分布相似。</p><hr><p>除了上述两种相似性的测量方式，还有：</p><p>角度相似性函数</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(16).png" alt="007"></p><p>用于表征两个特征向量之间的夹角大小，这样表述相似性有两个好处：</p><ol><li>当特征空间进行尺度变换，如放大缩小时，夹角保持不变；   </li><li>当坐标系旋转，或者坐标变换，如仿射变换，双线性变换，平方变换、双平方变换时，夹角不变；</li></ol><p>Tanimoto测度：</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(21).png" alt="008"></p><p>其中x和z的分量用二值来表示，0表示不具有某种特征，1表示具有某种特征。这样就可以表示为所有特征中共有的特征占比了。<br>表示出两个特征向量之间的相似度后，我们需要定义一个聚类准则函数，使聚类问题变成一个最优化问题，比如说误差平方和：</p><p>$$<br>J &#x3D; \sum_{j&#x3D;1}^{c} \sum_{x \in S} |x - m_j|^2<br>$$</p><p>$m_{j}$是定义的质心，使聚类后的同类之间到质心的距离和最小，质心通过平均求得。</p><h2 id="分级聚类"><a href="#分级聚类" class="headerlink" title="分级聚类"></a>分级聚类</h2><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(9).png" alt="009"></p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(10).png" alt="0010"></p><p>类间距离准则：</p><ol><li>最近邻域：<br>两个不同的类别之间最近的两个样本之间的距离代表两个类别之间的距离；   </li><li>最远邻域：<br>两个不同的类别之间最远的两个样本之间的距离代表两个类别之间的距离；</li><li>平均邻域：<br>两个类别的质心间的距离表示两个类别之间的距离</li></ol><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(8).png" alt="0011"></p><p>以最近邻域为例（右上），先初始化所有样本各为一个聚类，然后计算不同类之间的距离，将距离最近的两个类进行<strong>合并</strong>，之后重新计算类之间的距离，合并后的类计算距离时取类内样本最小距离；按照如此继续聚类合并直到只剩下需求的类别数量；</p><p>通过上面的聚类结果可视化能发现，由于样本中<strong>存在一个噪声</strong>，即距离较远的样本，无论如何计算最近距离该样本都会被判定为一个类，而相距较近的不同类反而被误判为同类。</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(18).png" alt="0012"></p><p>举个例子🤓 ：</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(4).png" alt="0013"></p><p>答案见P43。</p><h2 id="K均值聚类法"><a href="#K均值聚类法" class="headerlink" title="K均值聚类法"></a>K均值聚类法</h2><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(15).png" alt="0014"></p><p>一个比较明显跟分级聚类不同的地方是，类间的距离不是取样本间距离作为判断依据，而是取样本的均值定义为类别重心，求样本到重心的距离来判断该样本属于哪个类别；</p><p>问题:   </p><ul><li>如果k值的选取不正确，那么聚类错误；   </li><li>高度依赖于初始值选取；   </li><li>更适用“球形”分布的数据，难处理非球形聚类；</li></ul><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(14).png" alt="0015"></p><p>如果一开始的中心取在上下两端则会出现右图的分类情况，因此Kmeans聚类对初始值的选择较敏感；</p><p>尝试下面题目：</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(6).png" alt="0016"></p><h2 id="基于密度峰值的聚类方式"><a href="#基于密度峰值的聚类方式" class="headerlink" title="基于密度峰值的聚类方式"></a>基于密度峰值的聚类方式</h2><p>由于Kmeans只适合球状分布，因此针对非球状分布推出了密度峰值聚类；</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(11).png" alt="0017"></p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(12).png" alt="0018"></p><p>局部密度定义为$\rho_i &#x3D; \sum_j \chi(d_{ij} - d_c)$，其中$d_{ij}$表示数据对之间的距离，$d_{c}$为距离阈值，如果距离小于阈值则$\rho_{i}$加一，这样可以计算出局部的密度；</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(20).png" alt="0019"></p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(13).png" alt="0020"></p><p>试着解决以下问题吧🤓</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250601%20(7).png" alt="0021"></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Knowledge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicoScenes学习日志</title>
      <link href="/2025/05/30/research/picoscenes_use_instruction/"/>
      <url>/2025/05/30/research/picoscenes_use_instruction/</url>
      
        <content type="html"><![CDATA[<h1 id="PicoScenes——使用指南"><a href="#PicoScenes——使用指南" class="headerlink" title="PicoScenes——使用指南"></a>PicoScenes——使用指南</h1><p>Description：这是一篇快速上手的PicoScenes食用指南，我将从打开、查看配置、配置、以及抓包入手，对完整使用PicoScenes的流程进行一个快速的上手介绍;</p><h2 id="指定位置打开终端"><a href="#指定位置打开终端" class="headerlink" title="指定位置打开终端"></a>指定位置打开终端</h2><p>在你想要保存CSI得文件夹位置，右键空白位置，选择在终端中打开，之后就会在你想要的位置开启终端，并帮你cd到打开时的文件夹位置。</p><h2 id="查看信道配置"><a href="#查看信道配置" class="headerlink" title="查看信道配置"></a>查看信道配置</h2><p>第一步：先查看网卡的物理ID：</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/e19de6014f384fedfc52c1c78f7191ef.png" alt="array_status"></p><p>第二步：查看到物理ID后先将网卡配置为监听模式，这时候默认配置即可；</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/5f28ef35aeb55e65f49f36906c6d89cd.png" alt="prepare"></p><p>这里是给了一个配置，但是不影响，可以直接去掉双引号中的内容</p><p>第三步：查看监听模式下的网卡支持什么配置，包括信道以及带宽信息；</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/8eba8c837ec696a9c2d5c739a45bbf06.png" alt="array_eval"></p><p><code>-h</code> 查看支持的指令，我们选择框起来的指令：<br><code>array_eval phyid iw PHY info</code> 将phyid改成你的网卡即可；</p><p>第四步：查看支持的信道以及带宽；</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/f76f2165d0e2c66f68fdfd52640d4181.png" alt="Band"></p><p>可以看到，当前支持HT20以及HT40;</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/fb9c4ff0cd53dbc38b9ee8f6d09bb29a.png" alt="Band"></p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/8bc9cf5c47f4cea7dcab830440c8d384.png" alt="Band"></p><p>以上便是支持的信道中心频率了，由此我们便可以重新对网卡的监听信道进行配置</p><h2 id="对PicoScenes进行配置"><a href="#对PicoScenes进行配置" class="headerlink" title="对PicoScenes进行配置"></a>对PicoScenes进行配置</h2><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/5f28ef35aeb55e65f49f36906c6d89cd.png" alt="prepare"></p><p>重新使用该指令 <code>array_prepare_for_picoscenes phyid</code> 后面用双引号加上你需要的配置，这里我们设置为中心频率为5240MHz以及带宽为40MHz，注意40MHz带宽设置为 <code>HT40+</code> ；</p><h2 id="使用PicoScenes进行抓包并且保存"><a href="#使用PicoScenes进行抓包并且保存" class="headerlink" title="使用PicoScenes进行抓包并且保存"></a>使用PicoScenes进行抓包并且保存</h2><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/de616e970c83e30d82a204d4d8bc12e2.png" alt="Band"></p><p>只需要调用该指令，便可以实现CSI的抓取</p><p><code>PicoScenes&quot;-d debug -i 3 --mode logger --plot&quot;</code> 注意要修改为对应的phyid</p><h2 id="终止PicoScenes抓包"><a href="#终止PicoScenes抓包" class="headerlink" title="终止PicoScenes抓包"></a>终止PicoScenes抓包</h2><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/15813146a5b431a40489f9fa8abe75eb.png" alt="Band"></p><p>只需要ctrl+C便可以终止抓包，此时抓取的CSI便会出现在你打开终端时的文件夹中。如果是在桌面中打开的终端，则会保存到文件的一级目录里。</p><h2 id="使用中出现的现象："><a href="#使用中出现的现象：" class="headerlink" title="使用中出现的现象："></a>使用中出现的现象：</h2><p>当你配置完信道并开始抓取CSI时，有可能会出现没有plot的图像，或者plot图像更新很慢的问题，这是因为当前的信道WiFi活动比较弱，或者没有AP在这个信道中活动，是正常现象。</p><h1 id="PicoScenes监听与重启后的抓包来源"><a href="#PicoScenes监听与重启后的抓包来源" class="headerlink" title="PicoScenes监听与重启后的抓包来源"></a>PicoScenes监听与重启后的抓包来源</h1><p>已知，PicoScenes有内置的指令可以开启监听模式，在监听模式下可以抓取环境中WIFI的CSI，这一点可以通过观察802.11.ac的MAC帧头结构得到：</p><blockquote><p>开启监听模式后的源地址（5200HT20）<br><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/25053005.png" alt="Mon"></p></blockquote><p>可以观察到多个不同的地址；</p><p>监听模式下可以接收到环境中的CSI</p><p>开启监听指令: array_prepare_for_picoscenes PhyPath（网卡的id）   </p><blockquote><p>重启电脑后的源地址（2422-40BW）<br><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/25053002.png" alt="Non-Mon"></p></blockquote><p>只有一个源地址的CSI，重启可以关闭监听模式；   </p><blockquote><p>开启监听模式（2422-20BW）<br><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/25053001.png" alt="Mon-2422"></p></blockquote><blockquote><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/25053004.png" alt="Mon-2422"></p></blockquote><p>不同的源地址的CSI；   </p><blockquote><p>使用airmon-ng工具手动关闭mon并且重启（2422-40BW）<br><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/25053002.png" alt="Mon-2422"></p></blockquote><p>只有一个源地址的CSI，重启可以关闭监听模式；   </p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Linux </tag>
            
            <tag> CSI </tag>
            
            <tag> Positioning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fisher——Fisher投影分类</title>
      <link href="/2025/05/29/study/Fisher/"/>
      <url>/2025/05/29/study/Fisher/</url>
      
        <content type="html"><![CDATA[<h1 id="Fisher投影加速分类"><a href="#Fisher投影加速分类" class="headerlink" title="Fisher投影加速分类"></a>Fisher投影加速分类</h1><h2 id="线性判别分析（LDA）详解：从理论到代码实现"><a href="#线性判别分析（LDA）详解：从理论到代码实现" class="headerlink" title="线性判别分析（LDA）详解：从理论到代码实现"></a>线性判别分析（LDA）详解：从理论到代码实现</h2><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>线性判别分析（Linear Discriminant Analysis, LDA）是一种经典的监督学习降维与分类方法。其核心思想是通过最大化类间散度、最小化类内散度，将高维数据投影到低维空间并实现高效分类。本文以鸢尾花数据集为例，详解LDA的数学原理，并逐行解析代码实现。</p><h3 id="二、LDA的核心原理"><a href="#二、LDA的核心原理" class="headerlink" title="二、LDA的核心原理"></a>二、LDA的核心原理</h3><h4 id="1-核心目标"><a href="#1-核心目标" class="headerlink" title="1. 核心目标"></a>1. 核心目标</h4><p>LDA的目标是找到一个最优投影方向 $ W $，使得以下准则成立：</p><ul><li>类内散度最小：同一类样本在投影后的空间尽可能紧凑。</li><li>类间散度最大：不同类样本在投影后的空间尽可能分离。</li></ul><p>数学表达式为：</p><p>$$<br>J(W) &#x3D; \frac{W^T S_B W}{W^T S_W W}<br>$$</p><p>其中：</p><ul><li>$ S_W $：类内散度矩阵（Within-class Scatter Matrix）</li><li>$ S_B $：类间散度矩阵（Between-class Scatter Matrix）</li></ul><h4 id="2-数学推导"><a href="#2-数学推导" class="headerlink" title="2. 数学推导"></a>2. 数学推导</h4><h4 id="1-类均值向量"><a href="#1-类均值向量" class="headerlink" title="(1) 类均值向量"></a>(1) 类均值向量</h4><p>对每个类别 $ c $，计算其特征均值向量 $ \mu_c $：</p><p>$$<br>\mu_c &#x3D; \frac{1}{N_c} \sum_{x \in C_c} x<br>$$</p><p>其中 $ N_c $ 是类别 $ c $ 的样本数。</p><h4 id="2-类内散度矩阵-S-W"><a href="#2-类内散度矩阵-S-W" class="headerlink" title="(2) 类内散度矩阵 $ S_W $"></a>(2) 类内散度矩阵 $ S_W $</h4><p>衡量同一类样本的离散程度：</p><p>$$<br>S_W &#x3D; \sum_{c} \sum_{x \in C_c} (x - \mu_c)(x - \mu_c)^T<br>$$</p><h4 id="3-类间散度矩阵-S-B"><a href="#3-类间散度矩阵-S-B" class="headerlink" title="(3) 类间散度矩阵 $ S_B $"></a>(3) 类间散度矩阵 $ S_B $</h4><p>衡量不同类中心之间的距离：</p><p>$$<br>S_B &#x3D; \sum_{c} N_c (\mu_c - \mu)(\mu_c - \mu)^T<br>$$</p><p>其中 $ \mu $ 是全局均值向量。</p><h4 id="4-投影矩阵计算"><a href="#4-投影矩阵计算" class="headerlink" title="(4) 投影矩阵计算"></a>(4) 投影矩阵计算</h4><p>通过广义特征值问题求解最优投影方向：</p><p>$$<br>S_W^{-1} S_B w &#x3D; \lambda w<br>$$</p><p>选择最大特征值对应的特征向量 $ w $ 作为投影方向。</p><h3 id="三、代码详解与实现"><a href="#三、代码详解与实现" class="headerlink" title="三、代码详解与实现"></a>三、代码详解与实现</h3><h4 id="1-数据准备与预处理"><a href="#1-数据准备与预处理" class="headerlink" title="1. 数据准备与预处理"></a>1. 数据准备与预处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data[y != <span class="number">2</span>]  <span class="comment"># 筛选前两类（0和1）</span></span><br><span class="line">y = y[y != <span class="number">2</span>]</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br></pre></td></tr></table></figure><ul><li>功能：加载鸢尾花数据集并筛选前两类，构造二分类任务。</li><li>原理：LDA适用于多分类，但二分类更简单直观。</li></ul><h4 id="2-类均值计算"><a href="#2-类均值计算" class="headerlink" title="2. 类均值计算"></a>2. 类均值计算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">class_means</span>(<span class="params">X, y</span>):</span><br><span class="line">    classes = np.unique(y)</span><br><span class="line">    means = [np.mean(X[y == c], axis=<span class="number">0</span>) <span class="keyword">for</span> c <span class="keyword">in</span> classes]</span><br><span class="line">    <span class="keyword">return</span> np.array(means)</span><br></pre></td></tr></table></figure><ul><li>功能：计算每个类别的均值向量。</li><li>数学对应：实现公式 $ \mu_c $ 的计算。</li></ul><h4 id="3-类内散度矩阵"><a href="#3-类内散度矩阵" class="headerlink" title="3. 类内散度矩阵"></a>3. 类内散度矩阵</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">within_class_scatter</span>(<span class="params">X, y</span>):</span><br><span class="line">    means = class_means(X, y)</span><br><span class="line">    num_features = X.shape[<span class="number">1</span>]</span><br><span class="line">    S_w = np.zeros((num_features, num_features))</span><br><span class="line">    <span class="keyword">for</span> c, mean <span class="keyword">in</span> <span class="built_in">zip</span>(np.unique(y), means):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> X[y == c]:</span><br><span class="line">            x = x.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">            mean = mean.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">            S_w += (x - mean).dot((x - mean).T)</span><br><span class="line">    <span class="keyword">return</span> S_w</span><br></pre></td></tr></table></figure><ul><li>功能：计算类内散度矩阵 $ S_W $。</li><li>关键点：通过外积累加每个样本与类均值的偏差。</li></ul><h4 id="4-类间散度矩阵"><a href="#4-类间散度矩阵" class="headerlink" title="4. 类间散度矩阵"></a>4. 类间散度矩阵</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">between_class_scatter</span>(<span class="params">X, y</span>):</span><br><span class="line">    means = class_means(X, y)</span><br><span class="line">    mean1, mean2 = means[<span class="number">0</span>].reshape(-<span class="number">1</span>, <span class="number">1</span>), means[<span class="number">1</span>].reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> (mean1 - mean2).dot((mean1 - mean2).T)</span><br></pre></td></tr></table></figure><ul><li>功能：计算类间散度矩阵 $ S_B $。</li><li>局限性：仅适用于二分类，多分类需扩展。</li></ul><h4 id="5-投影矩阵求解"><a href="#5-投影矩阵求解" class="headerlink" title="5. 投影矩阵求解"></a>5. 投影矩阵求解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">projection_matrix</span>(<span class="params">X, y</span>):</span><br><span class="line">    S_w = within_class_scatter(X, y)</span><br><span class="line">    S_b = between_class_scatter(X, y)</span><br><span class="line">    eig_vals, eig_vecs = np.linalg.eig(np.linalg.inv(S_w).dot(S_b))</span><br><span class="line">    <span class="keyword">return</span> eig_vecs[:, np.argsort(eig_vals)[::-<span class="number">1</span>][:<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><ul><li>功能：求解广义特征值问题，取最大特征值对应的特征向量作为投影方向。</li><li>数学对应：求解 $ S_W^{-1} S_B $ 的最大特征值对应的特征向量。</li></ul><h4 id="6-数据投影与分类"><a href="#6-数据投影与分类" class="headerlink" title="6. 数据投影与分类"></a>6. 数据投影与分类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">W = projection_matrix(X_train, y_train)</span><br><span class="line">X_train_lda = X_train.dot(W)  <span class="comment"># 降维后的训练数据</span></span><br><span class="line">X_test_lda = X_test.dot(W)    <span class="comment"># 降维后的测试数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算阈值并分类</span></span><br><span class="line">threshold = (X_train_lda[y_train == <span class="number">0</span>].mean() + X_train_lda[y_train == <span class="number">1</span>].mean()) / <span class="number">2</span></span><br><span class="line">y_pred = (X_test_lda &gt;= threshold).astype(<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure><ul><li>决策规则：使用两类均值的中点作为阈值进行分类。</li></ul><h3 id="四、实验结果与可视化"><a href="#四、实验结果与可视化" class="headerlink" title="四、实验结果与可视化"></a>四、实验结果与可视化</h3><h4 id="1-可视化设计"><a href="#1-可视化设计" class="headerlink" title="1. 可视化设计"></a>1. 可视化设计</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fig, (ax1, ax2, ax3) = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">18</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 绘制训练集、测试集及合并结果</span></span><br><span class="line"><span class="keyword">for</span> ax, X_lda, y_true, title <span class="keyword">in</span> <span class="built_in">zip</span>([ax1, ax2, ax3], </span><br><span class="line">                                   [X_train_lda, X_test_lda, X_train_lda], </span><br><span class="line">                                   [y_train, y_test, y_train], </span><br><span class="line">                                   [<span class="string">&quot;Train&quot;</span>, <span class="string">&quot;Test&quot;</span>, <span class="string">&quot;Combined&quot;</span>]):</span><br><span class="line">    <span class="keyword">for</span> cls, color <span class="keyword">in</span> <span class="built_in">zip</span>(np.unique(y), [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]):</span><br><span class="line">        ax.scatter(X_lda[y_true == cls], np.zeros(np.<span class="built_in">sum</span>(y_true == cls)), </span><br><span class="line">                   c=color, label=<span class="string">f&#x27;Class <span class="subst">&#123;cls&#125;</span>&#x27;</span>)</span><br><span class="line">    ax.axvline(x=threshold, c=<span class="string">&#x27;g&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">    ax.set_title(<span class="string">f&quot;<span class="subst">&#123;title&#125;</span> (Acc: <span class="subst">&#123;accuracy_score(y_true, y_pred):<span class="number">.2</span>%&#125;</span>)&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li>图形说明：<ul><li>横轴：投影后的特征值；纵轴：辅助可视化（固定为0）。</li><li>绿色虚线：分类阈值。</li><li>颜色区分类别，散点分布反映分离效果。</li></ul></li></ul><h4 id="2-输出示例"><a href="#2-输出示例" class="headerlink" title="2. 输出示例"></a>2. 输出示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Train Accuracy: <span class="number">0.9875</span></span><br><span class="line">Test Accuracy: <span class="number">1.0</span></span><br></pre></td></tr></table></figure><ul><li>结果分析：在鸢尾花二分类任务中，LDA通常能达到95%以上的准确率。</li></ul><h3 id="四、关键问题与改进建议"><a href="#四、关键问题与改进建议" class="headerlink" title="四、关键问题与改进建议"></a>四、关键问题与改进建议</h3><h4 id="1-类间散度矩阵的改进"><a href="#1-类间散度矩阵的改进" class="headerlink" title="1. 类间散度矩阵的改进"></a>1. 类间散度矩阵的改进</h4><ul><li>当前实现：仅使用两类均值差的外积，未考虑样本数比例。</li><li>改进建议：</li></ul><p>对于二分类问题，正确的 $ S_B $ 应为：</p><p>$$<br>S_B &#x3D; \frac{n_1 n_2}{n} (\mu_1 - \mu_2)(\mu_1 - \mu_2)^T<br>$$</p><h4 id="2-特征值问题的稳定性"><a href="#2-特征值问题的稳定性" class="headerlink" title="2. 特征值问题的稳定性"></a>2. 特征值问题的稳定性</h4><ul><li>潜在问题：若 $ S_W $ 奇异（如高维小样本），求逆会导致数值不稳定。</li><li>改进建议：添加正则化项 $ \lambda I $ 到 $ S_W $。</li></ul><h4 id="3-阈值选择的优化"><a href="#3-阈值选择的优化" class="headerlink" title="3. 阈值选择的优化"></a>3. 阈值选择的优化</h4><ul><li>当前方法：固定阈值为均值中点。</li><li>改进建议：通过交叉验证选择最优阈值。</li></ul><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><ul><li>核心贡献：本文从数学公式到代码实现，完整解析了LDA的原理与应用。</li><li>代码特点：基于NumPy实现，无需依赖 sklearn.discriminant_analysis.LinearDiscriminantAnalysis，适合理解底层机制。</li><li>扩展方向：可推广到多分类任务，结合非线性核函数处理复杂分布。</li></ul><p>完整的工程请见<img src="https://github.com/" alt="Github"></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVM——Python代码实现以及解析</title>
      <link href="/2025/05/29/study/SVM/"/>
      <url>/2025/05/29/study/SVM/</url>
      
        <content type="html"><![CDATA[<h2 id="支持向量机-SVM-原理详解与代码解析"><a href="#支持向量机-SVM-原理详解与代码解析" class="headerlink" title="支持向量机(SVM)原理详解与代码解析"></a>支持向量机(SVM)原理详解与代码解析</h2><h3 id="一、SVM算法原理详解"><a href="#一、SVM算法原理详解" class="headerlink" title="一、SVM算法原理详解"></a>一、SVM算法原理详解</h3><h4 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h4><p>支持向量机通过最大化分类间隔实现最优分类，其数学本质是求解一个凸二次优化问题。核心思想包括：</p><ul><li>最大间隔原则：寻找使类别间距离最大的分类超平面</li><li>支持向量：决定分类边界的关键样本点</li><li>核技巧：通过核函数将低维不可分数据映射到高维空间</li></ul><h4 id="2-数学基础"><a href="#2-数学基础" class="headerlink" title="2. 数学基础"></a>2. 数学基础</h4><h4 id="1-线性可分情况"><a href="#1-线性可分情况" class="headerlink" title="(1) 线性可分情况"></a>(1) 线性可分情况</h4><p>$$<br>\min_{w,b} \frac{1}{2}||w||^2 \quad \text{s.t.} \quad y_i(w^T x_i + b) \geq 1<br>$$</p><ul><li>$ w $：超平面法向量</li><li>$ b $：偏置项</li><li>$ y_i \in {-1,1} $：类别标签</li></ul><h4 id="2-非线性情况（使用核函数）"><a href="#2-非线性情况（使用核函数）" class="headerlink" title="(2) 非线性情况（使用核函数）"></a>(2) 非线性情况（使用核函数）</h4><p>$$<br>K(x_i,x_j) &#x3D; \phi(x_i)^T\phi(x_j)<br>$$</p><p>常用核函数：</p><ul><li>线性核：$ K(x,y) &#x3D; x^Ty $</li><li>多项式核：$ K(x,y) &#x3D; (x^Ty + c)^d $</li><li>RBF核：$ K(x,y) &#x3D; e^{-\gamma ||x-y||^2} $</li></ul><h4 id="3-正则化参数C"><a href="#3-正则化参数C" class="headerlink" title="(3) 正则化参数C"></a>(3) 正则化参数C</h4><p>$$<br>\min_{w,b,\xi} \frac{1}{2}||w||^2 + C\sum_{i&#x3D;1}^n \xi_i<br>$$</p><ul><li>$ C $：控制误分类惩罚强度</li><li>$ \xi_i $：松弛变量，允许一定程度的误分类</li></ul><h3 id="二、代码逐句解析"><a href="#二、代码逐句解析" class="headerlink" title="二、代码逐句解析"></a>二、代码逐句解析</h3><h4 id="1-数据预处理阶段"><a href="#1-数据预处理阶段" class="headerlink" title="1. 数据预处理阶段"></a>1. 数据预处理阶段</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Iris_label</span>(<span class="params">s</span>):</span><br><span class="line">    it = &#123;<span class="string">b&#x27;Iris-setosa&#x27;</span>:<span class="number">0</span>, <span class="string">b&#x27;Iris-versicolor&#x27;</span>:<span class="number">1</span>, <span class="string">b&#x27;Iris-virginica&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> it[s]</span><br></pre></td></tr></table></figure><ul><li>功能：将原始文本标签转换为数字编码</li><li>原理：机器学习模型需要数值输入，将类别标签转换为0-1编码</li><li>改进建议：使用LabelEncoder更通用的标签编码方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;iris.txt&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">df[<span class="number">4</span>] = df[<span class="number">4</span>].<span class="built_in">map</span>(&#123;<span class="string">&#x27;Iris-setosa&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;Iris-versicolor&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Iris-virginica&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line">data = df.values</span><br></pre></td></tr></table></figure><ul><li>功能：读取数据并转换标签</li><li>关键点：使用pandas进行数据清洗，替代np.loadtxt更灵活</li><li>注意：原始数据集包含5列（4个特征+1个标签），索引0-4，因此不存在列越界问题</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, y = np.split(data, (<span class="number">4</span>,), axis=<span class="number">1</span>)</span><br><span class="line">x = x[:, :<span class="number">2</span>]</span><br><span class="line">y = y.ravel()</span><br></pre></td></tr></table></figure><ul><li>功能：特征与标签分离</li><li>原理：np.split按列分割数据，x[:, :2]选择前两个特征用于可视化</li><li>注意：ravel()确保标签为1D数组，符合scikit-learn输入要求</li></ul><h4 id="2-数据集划分"><a href="#2-数据集划分" class="headerlink" title="2. 数据集划分"></a>2. 数据集划分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>功能：按7:3划分训练集和测试集</li><li>原理：train_test_split内部执行数据打乱和分割</li><li>参数说明：<ul><li>test_size&#x3D;0.3：测试集占比30%</li><li>random_state&#x3D;1：确保结果可复现</li></ul></li></ul><h4 id="3-SVM模型构建"><a href="#3-SVM模型构建" class="headerlink" title="3. SVM模型构建"></a>3. SVM模型构建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = svm.SVC(C=<span class="number">2</span>, kernel=<span class="string">&#x27;rbf&#x27;</span>, gamma=<span class="number">10</span>, decision_function_shape=<span class="string">&#x27;ovo&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>参数详解：<ul><li>C&#x3D;2：正则化参数，值越大对误分类的惩罚越强</li><li>kernel&#x3D;’rbf’：使用径向基函数(RBF)作为核函数</li><li>gamma&#x3D;10：核函数系数，值越大模型复杂度越高</li><li>decision_function_shape&#x3D;’ovo’：采用一对一的多分类策略</li></ul></li></ul><h4 id="4-模型训练"><a href="#4-模型训练" class="headerlink" title="4. 模型训练"></a>4. 模型训练</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit(x_train, y_train.ravel())</span><br></pre></td></tr></table></figure><ul><li>功能：训练SVM模型</li><li>原理：内部调用SMO算法求解优化问题</li><li>数学对应：优化目标是最大化分类间隔同时最小化分类误差</li></ul><h4 id="5-模型评估"><a href="#5-模型评估" class="headerlink" title="5. 模型评估"></a>5. 模型评估</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_score = model.score(x_train, y_train)</span><br><span class="line">test_score = model.score(x_test, y_test)</span><br></pre></td></tr></table></figure><ul><li>功能：计算分类准确率</li><li>原理：准确率公式 $ Accuracy &#x3D; \frac{TP+TN}{TP+FP+TN+FN} $</li><li>训练集准确率：98.57%; 测试集准确率：95.56%</li></ul><h3 id="三、关键概念与代码对应关系"><a href="#三、关键概念与代码对应关系" class="headerlink" title="三、关键概念与代码对应关系"></a>三、关键概念与代码对应关系</h3><table><thead><tr><th align="left">代码实现</th><th align="left">数学原理</th></tr></thead><tbody><tr><td align="left"><code>kernel=&#39;rbf&#39;</code></td><td align="left">核技巧 $ K(x,y) &#x3D; e^{-\gamma} $</td></tr><tr><td align="left"><code>C=2</code></td><td align="left">正则化参数 $ \min \frac{1}{2} $</td></tr><tr><td align="left"><code>gamma=10</code></td><td align="left">核函数参数 $ \gamma $ 控制模型复杂度</td></tr><tr><td align="left"><code>decision\_function\_shape=&#39;ovo&#39;</code></td><td align="left">一对一多分类策略</td></tr><tr><td align="left"><code>train\_test\_split(...)</code></td><td align="left">数据集划分保证泛化性</td></tr></tbody></table><h3 id="四、模型可视化实现（补充）"><a href="#四、模型可视化实现（补充）" class="headerlink" title="四、模型可视化实现（补充）"></a>四、模型可视化实现（补充）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot_decision_regions</span>(<span class="params">X, y, classifier</span>):</span><br><span class="line">    <span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">    X1, X2 = np.meshgrid(np.arange(X[:,<span class="number">0</span>].<span class="built_in">min</span>()-<span class="number">1</span>, X[:,<span class="number">0</span>].<span class="built_in">max</span>()+<span class="number">1</span>, <span class="number">0.02</span>),</span><br><span class="line">                           np.arange(X[:,<span class="number">1</span>].<span class="built_in">min</span>()-<span class="number">1</span>, X[:,<span class="number">1</span>].<span class="built_in">max</span>()+<span class="number">1</span>, <span class="number">0.02</span>))</span><br><span class="line">    Z = classifier.predict(np.c_[X1.ravel(), X2.ravel()])</span><br><span class="line">    Z = Z.reshape(X1.shape)</span><br><span class="line">    plt.contourf(X1, X2, Z, alpha=<span class="number">0.4</span>, cmap=ListedColormap([<span class="string">&#x27;lightcoral&#x27;</span>,<span class="string">&#x27;lightblue&#x27;</span>,<span class="string">&#x27;lightgreen&#x27;</span>]))</span><br><span class="line">    plt.scatter(X[y==<span class="number">0</span>,<span class="number">0</span>], X[y==<span class="number">0</span>,<span class="number">1</span>], c=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;Setosa&#x27;</span>)</span><br><span class="line">    plt.scatter(X[y==<span class="number">1</span>,<span class="number">0</span>], X[y==<span class="number">1</span>,<span class="number">1</span>], c=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;Versicolor&#x27;</span>)</span><br><span class="line">    plt.scatter(X[y==<span class="number">2</span>,<span class="number">0</span>], X[y==<span class="number">2</span>,<span class="number">1</span>], c=<span class="string">&#x27;green&#x27;</span>, label=<span class="string">&#x27;Virginica&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;SVM Result&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Sepal Length&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Sepal Width&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_decision_regions(x_test, y_test, model)</span><br></pre></td></tr></table></figure><ul><li>功能：绘制决策边界</li><li>原理：<ol><li>生成网格点作为测试点</li><li>对每个点进行预测</li><li>将预测结果可视化为背景颜色</li></ol></li><li>可视化要素：<ul><li>背景色：表示模型的决策区域</li><li>散点：实际测试集样本分布</li><li>标题：显示模型名称</li></ul></li></ul><h3 id="五、参数调优建议"><a href="#五、参数调优建议" class="headerlink" title="五、参数调优建议"></a>五、参数调优建议</h3><ol><li>核函数选择：<ul><li>线性可分数据使用linear核</li><li>非线性数据使用rbf核（默认）</li><li>多项式核适用于特定场景</li></ul></li><li>参数调优： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">param_grid = &#123;<span class="string">&#x27;C&#x27;</span>: [<span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>], <span class="string">&#x27;gamma&#x27;</span>: [<span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>]&#125;</span><br><span class="line">grid = GridSearchCV(svm.SVC(), param_grid, cv=<span class="number">5</span>)</span><br><span class="line">grid.fit(x_train, y_train)</span><br></pre></td></tr></table></figure></li><li>多分类策略：<ul><li>decision_function_shape&#x3D;’ovo’：一对一（适合小数据集）</li><li>decision_function_shape&#x3D;’ovr’：一对多（适合大数据集）</li></ul></li></ol><h3 id="六、完整工作流程图"><a href="#六、完整工作流程图" class="headerlink" title="六、完整工作流程图"></a>六、完整工作流程图</h3><figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据预处理 → 特征选择 → 模型初始化 → 参数调优 → 模型训练 → 可视化 → 性能评估</span><br></pre></td></tr></table></figure><h3 id="七、注意事项"><a href="#七、注意事项" class="headerlink" title="七、注意事项"></a>七、注意事项</h3><ol><li>特征标准化： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">x_train = sc.fit_transform(x_train)</span><br></pre></td></tr></table></figure><ul><li>原因：SVM对特征尺度敏感</li><li>方法：Z-score标准化</li></ul></li><li>特征选择：<ul><li>仅使用前两个特征会损失部分信息</li><li>建议使用PCA降维代替人工选择</li></ul></li><li>过拟合预防：<ul><li>当gamma过大时可能导致过拟合</li><li>可通过交叉验证选择最优参数</li></ul></li></ol><h3 id="八、扩展应用"><a href="#八、扩展应用" class="headerlink" title="八、扩展应用"></a>八、扩展应用</h3><ol><li>多分类问题：<ul><li>鸢尾花有3个类别</li><li>SVM原生支持多分类（非二分类扩展）</li></ul></li><li>非线性分类：<ul><li>RBF核处理非线性可分问题</li><li>决策边界可以是非线性的</li></ul></li><li>软间隔：<ul><li>C&#x3D;2允许部分样本位于间隔带内</li><li>平衡分类精度和泛化能力</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于CIFAR数据集实现的图像分类</title>
      <link href="/2025/05/29/study/%E5%9F%BA%E4%BA%8ECIFAR%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
      <url>/2025/05/29/study/%E5%9F%BA%E4%BA%8ECIFAR%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="CIFAR-10数据集介绍"><a href="#CIFAR-10数据集介绍" class="headerlink" title="CIFAR-10数据集介绍"></a>CIFAR-10数据集介绍</h2><p>CIFAR10包含有一共60000张32x32的彩色图像，这些图片中一共有10类不同的事物，每一类有6000张样本。这些图片按照5:1的比例随机分为训练集以及测试集。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/25060103.png" alt="CIFAR-10"></p><p>下面将在这个开源的数据集上实现图像的分类，目前计划通过ResNet-18模型实现上述的分类功能；</p><h2 id="Python代码实现以及详解"><a href="#Python代码实现以及详解" class="headerlink" title="Python代码实现以及详解"></a>Python代码实现以及详解</h2><h3 id="导入必要的库以及依赖"><a href="#导入必要的库以及依赖" class="headerlink" title="导入必要的库以及依赖"></a>导入必要的库以及依赖</h3><p>我们这里使用Pytorch框架实现模型的训练以及结果的预测；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn </span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm </span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms </span><br><span class="line"><span class="keyword">import</span> torchvision </span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br></pre></td></tr></table></figure><p>导入 <code>tdqm</code> 库将训练的过程可视化，该库能够将训练的进度以进度条的形式显示出来；由于我们要实现的是图片的识别分类功能，这里选择导入 <code>torchvision</code> 库并使用预训练的模型参数提高训练的正确率以及速度；</p><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">transform = transforms.Compose([ </span><br><span class="line">    transforms.ToTensor(), </span><br><span class="line">    transforms.Normalize((<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>), (<span class="number">0.2023</span>, <span class="number">0.1994</span>, <span class="number">0.2010</span>)), </span><br><span class="line">    <span class="comment"># CIFAR-10 数据集的均值和标准差 </span></span><br><span class="line">]) </span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">train_set = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./CIFAR&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=transform)  <span class="comment">#root根据实际进行修改 </span></span><br><span class="line">train_loader = DataLoader(train_set, batch_size=batch_size, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>) </span><br><span class="line"> </span><br><span class="line">val_dataset = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./CIFAR&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>, transform=transform)  <span class="comment">#root根据实际进行修改 </span></span><br><span class="line">val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先我们先定义了一个图片变换结构，作用是将图片，向量矩阵转换为Pytorch中定义的一个全新的数据结构——张量（Tensor）；之后根据该数据集的标准差对所有张量标准化归一化；</p><p>之后定义了训练集数据以及验证集数据的加载器，能够设置一定的 <code>batch\_size</code> 每一次取数据进行训练或者验证的时候取一整个 <code>batch</code> ，提高训练的速度；同时还能够设置是否随机选择样本，以及线程数量；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(device)</span><br></pre></td></tr></table></figure><p>定义设备，如果当前支持CUDA则使用CUDA作为训练的设备，否则为CPU；CUDA的训练速度要比CPU的训练速度快，而且训练的效果会更好一些；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net = torchvision.models.resnet18(pretrained=<span class="literal">True</span>)  <span class="comment"># 加载预训练的模型参数</span></span><br><span class="line">num_ftrs = net.fc.in_features                       <span class="comment"># 全连接层的特征</span></span><br><span class="line"><span class="comment"># 修改全连接层的输出维度为10 </span></span><br><span class="line">net.fc = nn.Linear(num_ftrs, <span class="number">10</span>)                    <span class="comment"># 人为修改连接层的输出</span></span><br><span class="line">net = net.to(device)</span><br></pre></td></tr></table></figure><p>这里我们使用 <code>ResNet-18</code> 模型进行训练以及识别，为了加快训练的速度以及提高训练的准确率，选择导入Pytorch中预训练的模型参数；由于该数据集中只有10个类别，网络只需要10个输出，因此我们单独对网络的最后一层进行修改，将全连接层的输出修改为10；最后将模型导入到设备在。</p><p>注意：CUDA与CPU不互通，模型以及数据到需要在同一个设备中；</p><p>Net的结构如下：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/25060104.png" alt="ResNet-18"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">criterion = nn.CrossEntropyLoss() </span><br><span class="line">optimizer = torch.optim.AdamW(lr=<span class="number">0.0001</span>, params=net.parameters()) </span><br><span class="line">epochs = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>定义比较常见的两个函数作为赏罚函数，损失函数为<strong>交叉损失</strong>，优化函数定义为<strong>AdamW函数</strong>，想详细了解可以去参考一下文章：</p><p><a href="https://arxiv.org/abs/1711.05101">[1711.05101] Decoupled Weight Decay Regularization</a></p><p>训练轮数为10轮，训练轮数的选取比较有讲究，如果训练次数过少则模型的性能没有到最优；如果训练次数过多，则又会导致<strong>过拟合</strong>，训练效果下降。因此通常选择一个适中的次数，或者对每次训练的准确率进行判断，发现如果准确率的优化减缓时，意味着当前模型接近收敛，便提前结束训练并保存模型参数；</p><hr><p>下面是训练代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;--------------------Epoch: <span class="subst">&#123;epoch&#125;</span>--------------------\n&#x27;</span>) </span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 训练阶段 </span></span><br><span class="line">    net.train() </span><br><span class="line">    running_loss = <span class="number">0.0</span> </span><br><span class="line">    correct_train = <span class="number">0</span> </span><br><span class="line">    total_train = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> tqdm(train_loader): </span><br><span class="line">        inputs = inputs.to(device) </span><br><span class="line">        labels = labels.to(device) </span><br><span class="line"> </span><br><span class="line">        optimizer.zero_grad()   <span class="comment"># 清空梯度</span></span><br><span class="line">        outputs = net(inputs)   <span class="comment"># 预测输出</span></span><br><span class="line">        loss = criterion(outputs, labels) </span><br><span class="line">        loss.backward()         <span class="comment"># 梯度下降</span></span><br><span class="line">        optimizer.step()        <span class="comment"># 优化</span></span><br><span class="line"> </span><br><span class="line">        running_loss += loss.item() </span><br><span class="line">        _, predicted = torch.<span class="built_in">max</span>(outputs.data, <span class="number">1</span>) </span><br><span class="line">        total_train += labels.size(<span class="number">0</span>) </span><br><span class="line">        correct_train += (predicted == labels).<span class="built_in">sum</span>().item() </span><br><span class="line">        train_loss = running_loss / <span class="built_in">len</span>(train_loader) </span><br><span class="line"></span><br><span class="line">    train_acc = correct_train / total_train </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;训练损失：&#123;:.4f&#125;，训练准确率：&#123;:.4f&#125;%&#x27;</span>.<span class="built_in">format</span>(train_loss, train_acc * <span class="number">100</span>)) </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 验证阶段 </span></span><br><span class="line">    net.<span class="built_in">eval</span>() </span><br><span class="line">    correct_val = <span class="number">0</span> </span><br><span class="line">    total_val = <span class="number">0</span> </span><br><span class="line">    val_loss = <span class="number">0.0</span> </span><br><span class="line">    <span class="comment"># 不更新梯度</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad(): </span><br><span class="line">        <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> tqdm(val_loader): </span><br><span class="line">            inputs = inputs.to(device) </span><br><span class="line">         </span><br><span class="line">            labels = labels.to(device) </span><br><span class="line"> </span><br><span class="line">            outputs = net(inputs) </span><br><span class="line">            loss = criterion(outputs, labels) </span><br><span class="line">            val_loss += loss.item() </span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(outputs.data, <span class="number">1</span>) </span><br><span class="line">            total_val += labels.size(<span class="number">0</span>) </span><br><span class="line">            correct_val += (predicted == labels).<span class="built_in">sum</span>().item() </span><br><span class="line"> </span><br><span class="line">    val_loss /= <span class="built_in">len</span>(val_loader) </span><br><span class="line">    val_acc = correct_val / total_val </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;验证损失：&#123;:.4f&#125;，验证准确率：&#123;:.4f&#125;%&#x27;</span>.<span class="built_in">format</span>(val_loss, val_acc * <span class="number">100</span>)) </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/25060101.png" alt="CIFAR-10"></p><p>以上就是输出的结果。</p><h2 id="在CIFAR-100上实现图像的识别分类"><a href="#在CIFAR-100上实现图像的识别分类" class="headerlink" title="在CIFAR-100上实现图像的识别分类"></a>在CIFAR-100上实现图像的识别分类</h2><p>CIFAR-100，同CIFAR-10一样，不同的是该数据集包含有100种不同的实物，要对100个样本类别进行区分，对应的数据量也水涨船高；</p><p>理论上两者的模型都差不多，但是ResNet-18对100个任务的区分效率低、效果差，因此我们这里尝试使用MobileNet_v2模型对CIFAR-100数据集进行训练，在损失函数以及优化函数的配置上略有不同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义损失函数和优化器</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"><span class="comment"># 使用不同的学习率</span></span><br><span class="line">optimizer = torch.optim.AdamW([</span><br><span class="line">    &#123;<span class="string">&#x27;params&#x27;</span>: model.features.parameters(), <span class="string">&#x27;lr&#x27;</span>: <span class="number">1e-4</span>&#125;,    <span class="comment"># 特征提取层使用较小的学习率</span></span><br><span class="line">    &#123;<span class="string">&#x27;params&#x27;</span>: model.classifier.parameters(), <span class="string">&#x27;lr&#x27;</span>: <span class="number">1e-3</span>&#125;   <span class="comment"># 分类层使用较大的学习率</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学习率调度器</span></span><br><span class="line">scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode=<span class="string">&#x27;min&#x27;</span>, factor=<span class="number">0.1</span>, patience=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">epochs = <span class="number">20</span>  <span class="comment"># 增加训练轮数</span></span><br></pre></td></tr></table></figure><p>损失函数仍然使用交叉损失函数，但是我们在不同的阶段使用不同的学习率，在特征提取阶段使用小的学习率，分类时使用大的学习率。分类的损失直接与模型的表现有关，因此较高的学习率可以更快的收敛；</p><p>使用**分层学习率（layer-wise learning rate decay）**的策略，它的好处包括：</p><ol><li><strong>保留预训练特征</strong>：较小的学习率用于 <code>features</code>，可保持预训练模型学到的通用特征。</li><li><strong>快速适应新任务</strong>：较大的学习率用于 <code>classifier</code>，有利于快速适应 CIFAR-100 新任务。</li><li><strong>训练更稳定、收敛更快</strong>：尤其在轻量网络中，更能体现训练灵活性。</li></ol><hr><p>下面是训练代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">best_val_acc = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;\nEpoch <span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;epochs&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">30</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练阶段</span></span><br><span class="line">    model.train()</span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    correct_train = <span class="number">0</span></span><br><span class="line">    total_train = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> tqdm(train_loader, desc=<span class="string">&#x27;Training&#x27;</span>):</span><br><span class="line">        inputs = inputs.to(device)</span><br><span class="line">        labels = labels.to(device)</span><br><span class="line">        </span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        </span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        _, predicted = torch.<span class="built_in">max</span>(outputs.data, <span class="number">1</span>)</span><br><span class="line">        total_train += labels.size(<span class="number">0</span>)</span><br><span class="line">        correct_train += (predicted == labels).<span class="built_in">sum</span>().item()</span><br><span class="line">    </span><br><span class="line">    train_loss = running_loss / <span class="built_in">len</span>(train_loader)</span><br><span class="line">    train_acc = correct_train / total_train</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Train Loss: <span class="subst">&#123;train_loss:<span class="number">.4</span>f&#125;</span> | Train Acc: <span class="subst">&#123;train_acc*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span>%&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 验证阶段</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    val_loss = <span class="number">0.0</span></span><br><span class="line">    correct_val = <span class="number">0</span></span><br><span class="line">    total_val = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> tqdm(val_loader, desc=<span class="string">&#x27;Validation&#x27;</span>):</span><br><span class="line">            inputs = inputs.to(device)</span><br><span class="line">            labels = labels.to(device)</span><br><span class="line">            </span><br><span class="line">            outputs = model(inputs)</span><br><span class="line">            loss = criterion(outputs, labels)</span><br><span class="line">            val_loss += loss.item()</span><br><span class="line">            </span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(outputs.data, <span class="number">1</span>)</span><br><span class="line">            total_val += labels.size(<span class="number">0</span>)</span><br><span class="line">            correct_val += (predicted == labels).<span class="built_in">sum</span>().item()</span><br><span class="line">    </span><br><span class="line">    val_loss = val_loss / <span class="built_in">len</span>(val_loader)</span><br><span class="line">    val_acc = correct_val / total_val</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Val Loss: <span class="subst">&#123;val_loss:<span class="number">.4</span>f&#125;</span> | Val Acc: <span class="subst">&#123;val_acc*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span>%&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新学习率</span></span><br><span class="line">    scheduler.step(val_loss)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保存最佳模型</span></span><br><span class="line">    <span class="keyword">if</span> val_acc &gt; best_val_acc:</span><br><span class="line">        best_val_acc = val_acc</span><br><span class="line">        torch.save(model.state_dict(), <span class="string">&#x27;best_mobilenetv2_cifar100.pth&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Best validation accuracy: <span class="subst">&#123;best_val_acc*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span>%&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/25060102.png" alt="CIFAR-10"></p><h2 id="✅-MobileNetV2-相对于-ResNet-18-的优势与适用场景"><a href="#✅-MobileNetV2-相对于-ResNet-18-的优势与适用场景" class="headerlink" title="✅ MobileNetV2 相对于 ResNet-18 的优势与适用场景"></a>✅ MobileNetV2 相对于 ResNet-18 的优势与适用场景</h2><table><thead><tr><th align="left">方面</th><th align="left">ResNet-18</th><th align="left">MobileNetV2</th><th align="left">对比与解释</th></tr></thead><tbody><tr><td align="left"><strong>模型大小</strong></td><td align="left">约 44.6M 参数</td><td align="left">约 3.5M 参数</td><td align="left">MobileNetV2 轻量很多，适合部署在资源受限设备（如嵌入式、手机端）。</td></tr><tr><td align="left"><strong>计算效率</strong></td><td align="left">中等</td><td align="left">更快（低 FLOPs）</td><td align="left">MobileNetV2 使用 <strong>深度可分离卷积</strong>，大大降低计算复杂度。</td></tr><tr><td align="left"><strong>推理速度</strong></td><td align="left">中</td><td align="left">更快</td><td align="left">推理延迟更低，尤其在 CPU 或边缘设备上。</td></tr><tr><td align="left"><strong>准确率（ImageNet）</strong></td><td align="left">Top-1: ~69.8%</td><td align="left">Top-1: ~71.8%</td><td align="left">MobileNetV2 有更优的参数效率。微调后在 CIFAR-100 上表现差距不大。</td></tr><tr><td align="left"><strong>结构深度</strong></td><td align="left">ResNet 残差结构</td><td align="left">Inverted Residual + Linear Bottleneck</td><td align="left">MobileNetV2 更现代、结构紧凑，有利于特征传递与训练。</td></tr><tr><td align="left"><strong>训练稳定性</strong></td><td align="left">非常稳定</td><td align="left">稍敏感于学习率、调度器</td><td align="left">MobileNetV2 结构浅，过大学习率容易震荡，但你设置了合理的 <code>lr</code> 和 <code>scheduler</code>，可以很好控制。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于贝叶斯决策的分类器</title>
      <link href="/2025/05/24/study/Bayes/"/>
      <url>/2025/05/24/study/Bayes/</url>
      
        <content type="html"><![CDATA[<h1 id="最小错误率贝叶斯决策分类器实战：代码解析与理论详解"><a href="#最小错误率贝叶斯决策分类器实战：代码解析与理论详解" class="headerlink" title="最小错误率贝叶斯决策分类器实战：代码解析与理论详解"></a>最小错误率贝叶斯决策分类器实战：代码解析与理论详解</h1><h2 id="一、背景与应用场景"><a href="#一、背景与应用场景" class="headerlink" title="一、背景与应用场景"></a>一、背景与应用场景</h2><p>贝叶斯决策分类器是一种基于**贝叶斯定理**的统计分类方法，其核心思想是通过最大化后验概率来最小化分类错误率。该方法广泛应用于医学诊断、金融风控等场景，尤其适合特征分布符合正态分布的小规模数据集。本文以鸢尾花（Iris）数据集为例，详解如何实现一个基于贝叶斯决策的分类器 。  </p><h2 id="二、核心代码解析"><a href="#二、核心代码解析" class="headerlink" title="二、核心代码解析"></a>二、核心代码解析</h2><h2 id="1-数据准备与划分"><a href="#1-数据准备与划分" class="headerlink" title="1. 数据准备与划分"></a>1. 数据准备与划分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from sklearn import datasets</span><br><span class="line">X, y = datasets.load_iris().data, datasets.load_iris().target</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：加载鸢尾花数据集，包含4个特征（花萼&#x2F;花瓣长度和宽度）和3个类别（Setosa, Versicolor, Virginica）。   </li><li><strong>理论基础</strong>：数据集需满足<strong>独立同分布</strong>假设，即样本间相互独立且特征分布一致 。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：按7:3比例划分训练集和测试集，<code>random\_state</code>确保实验可复现 。</li></ul><hr><h3 id="2-先验概率与类别条件概率估计"><a href="#2-先验概率与类别条件概率估计" class="headerlink" title="2. 先验概率与类别条件概率估计"></a>2. 先验概率与类别条件概率估计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class_counts = np.bincount(y_train)</span><br><span class="line">priors = class_counts / len(y_train)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>原理</strong>：先验概率 $ P(Y) $ 反映类别在训练集中的分布比例。例如，若某类别占30%样本，则 $ P(Y&#x3D;\text{class}) &#x3D; 0.3 $ 。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class_conditional_probs = []</span><br><span class="line">for class_idx in range(3):</span><br><span class="line">    class_data = X_train[y_train == class_idx]</span><br><span class="line">    class_mean = np.mean(class_data, axis=0)</span><br><span class="line">    class_cov = np.cov(class_data, rowvar=False)</span><br><span class="line">    class_conditional_probs.append(multivariate_normal(mean=class_mean, cov=class_cov))</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>关键步骤</strong>：   <ol><li><strong>类别条件概率建模</strong>：假设每个类别的特征服从多元正态分布，通过均值向量（<code>class\_mean</code>）和协方差矩阵（<code>class\_cov</code>）描述分布特性。   </li><li><strong>参数估计</strong>：使用最大似然估计（MLE）计算均值和协方差矩阵，这是参数化方法的核心 。</li></ol></li></ul><hr><h3 id="3-贝叶斯决策分类器实现"><a href="#3-贝叶斯决策分类器实现" class="headerlink" title="3. 贝叶斯决策分类器实现"></a>3. 贝叶斯决策分类器实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MinimumErrorRateBayesianDecision:</span><br><span class="line">    def classify(self, features):</span><br><span class="line">        posterior_probs = [self.priors[i] * prob.pdf(features) for i, prob in enumerate(self.class_conditional_probs)]</span><br><span class="line">        return np.argmax(posterior_probs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>决策逻辑</strong>：   <ul><li><strong>后验概率计算</strong>：根据贝叶斯公式 $ P(Y|X) \propto P(Y) \cdot P(X|Y) $，计算每个类别的后验概率。   </li><li><strong>最小错误率决策</strong>：选择后验概率最大的类别作为预测结果，此决策规则理论上最小化分类错误率 。</li></ul></li></ul><hr><h3 id="4-模型评估"><a href="#4-模型评估" class="headerlink" title="4. 模型评估"></a>4. 模型评估</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">correct_predictions = 0</span><br><span class="line">class_correct_predictions = [0]*3</span><br><span class="line">class_total_samples = [0]*3</span><br><span class="line"></span><br><span class="line">for i in range(len(X_test)):</span><br><span class="line">    predicted_class = classifier.classify(X_test[i])</span><br><span class="line">    class_total_samples[y_test[i]] += 1</span><br><span class="line">    if predicted_class == y_test[i]:</span><br><span class="line">        correct_predictions += 1</span><br><span class="line">        class_correct_predictions[y_test[i]] += 1</span><br><span class="line"></span><br><span class="line">accuracy = correct_predictions / len(X_test)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>评估指标</strong>：计算整体准确率和类别级别的准确率，验证分类器性能 。</li></ul><hr><h2 id="三、数学原理详解"><a href="#三、数学原理详解" class="headerlink" title="三、数学原理详解"></a>三、数学原理详解</h2><h3 id="1-贝叶斯定理"><a href="#1-贝叶斯定理" class="headerlink" title="1. 贝叶斯定理"></a>1. 贝叶斯定理</h3><p>贝叶斯公式定义为：<br>$$<br>P(Y|X) &#x3D; \frac{P(X|Y) \cdot P(Y)}{P(X)}<br>$$   </p><ul><li><strong>先验概率</strong> $ P(Y) $：类别在训练集中的分布比例。   </li><li><strong>似然</strong> $ P(X|Y) $：类别条件概率密度，通过多元正态分布建模。   </li><li><strong>证据</strong> $ P(X) $：常数项（对所有类别相同），不影响比较后验概率大小 。</li></ul><h3 id="2-多元正态分布假设"><a href="#2-多元正态分布假设" class="headerlink" title="2. 多元正态分布假设"></a>2. 多元正态分布假设</h3><p>假设特征向量 $ X \sim \mathcal{N}(\mu, \Sigma) $，其概率密度函数为：<br>$$<br>f(X) &#x3D; \frac{1}{\sqrt{(2\pi)^k |\Sigma|}} \exp\left( -\frac{1}{2}(X-\mu)^T \Sigma^{-1}(X-\mu) \right)<br>$$   </p><ul><li><strong>均值向量</strong> $ \mu $：反映特征的集中趋势。   </li><li><strong>协方差矩阵</strong> $ \Sigma $：描述特征间的相关性 。</li></ul><h3 id="3-决策边界"><a href="#3-决策边界" class="headerlink" title="3. 决策边界"></a>3. 决策边界</h3><h2 id="当两类的后验概率相等时，即：-P-Y-1-cdot-P-X-Y-1-P-Y-2-cdot-P-X-Y-2-此时对应的超平面即为决策边界，用于划分不同类别的样本空间-。"><a href="#当两类的后验概率相等时，即：-P-Y-1-cdot-P-X-Y-1-P-Y-2-cdot-P-X-Y-2-此时对应的超平面即为决策边界，用于划分不同类别的样本空间-。" class="headerlink" title="当两类的后验概率相等时，即：$$P(Y_1) \cdot P(X|Y_1) &#x3D; P(Y_2) \cdot P(X|Y_2)$$此时对应的超平面即为决策边界，用于划分不同类别的样本空间 。   "></a>当两类的后验概率相等时，即：<br>$$<br>P(Y_1) \cdot P(X|Y_1) &#x3D; P(Y_2) \cdot P(X|Y_2)<br>$$<br>此时对应的超平面即为决策边界，用于划分不同类别的样本空间 。   </h2><h2 id="四、实验结果与分析"><a href="#四、实验结果与分析" class="headerlink" title="四、实验结果与分析"></a>四、实验结果与分析</h2><h3 id="1-分类准确率"><a href="#1-分类准确率" class="headerlink" title="1. 分类准确率"></a>1. 分类准确率</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 输出示例（实际运行结果可能不同）</span><br><span class="line">print(&quot;Setosa准确率: 1.0&quot;)</span><br><span class="line">print(&quot;Versicolor准确率: 0.93&quot;)</span><br><span class="line">print(&quot;整体准确率: 0.95&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>结果分析</strong>：模型在测试集上表现优异，尤其对Setosa类别实现完美分类，表明正态分布假设在该数据集上成立 。</li></ul><h3 id="2-可视化决策边界"><a href="#2-可视化决策边界" class="headerlink" title="2. 可视化决策边界"></a>2. 可视化决策边界</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">plt.scatter(X_test[:, 0], X_test[:, 1], c=y_test, cmap=&#x27;viridis&#x27;)</span><br><span class="line">plt.xlabel(&quot;Sepal Length&quot;)</span><br><span class="line">plt.ylabel(&quot;Sepal Width&quot;)</span><br><span class="line">plt.title(&quot;Bayesian Decision Boundary&quot;)</span><br><span class="line">plt.colorbar(label=&quot;Class&quot;)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250524_02.png" alt="Agglomerative Clustering"><br><em>图2：基于贝叶斯决策的分类边界可视化（示例）</em>   </p><hr><h2 id="五、总结与扩展"><a href="#五、总结与扩展" class="headerlink" title="五、总结与扩展"></a>五、总结与扩展</h2><h3 id="1-优势与局限性"><a href="#1-优势与局限性" class="headerlink" title="1. 优势与局限性"></a>1. 优势与局限性</h3><ul><li><strong>优势</strong>：   <ul><li>理论基础扎实，适用于小规模数据。   </li><li>通过参数估计可解释性强 。</li></ul></li><li><strong>局限性</strong>：   <ul><li>依赖正态分布假设，若实际数据分布偏离较大可能导致性能下降。   </li><li>协方差矩阵可能因样本不足而奇异，需正则化处理 。</li></ul></li></ul><h3 id="2-改进方向"><a href="#2-改进方向" class="headerlink" title="2. 改进方向"></a>2. 改进方向</h3><ul><li><strong>非参数化方法</strong>：使用核密度估计替代正态分布假设。   </li><li><strong>正则化技术</strong>：在协方差矩阵中加入微小扰动（如 <code>class\_cov += 1e-6 \* np.eye(dim)</code>）防止奇异 。</li></ul><blockquote><p>完整代码仓库：[GitHub链接]   </p></blockquote><h1 id="🎃-朴素贝叶斯实现决策分类"><a href="#🎃-朴素贝叶斯实现决策分类" class="headerlink" title="🎃 朴素贝叶斯实现决策分类"></a>🎃 朴素贝叶斯实现决策分类</h1><h3 id="1-导入库"><a href="#1-导入库" class="headerlink" title="1. 导入库"></a>1. 导入库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.datasets import make_classification </span><br><span class="line">import matplotlib.pyplot as plt </span><br><span class="line">import numpy as np </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：导入所需的库。   <ul><li><code>make\_classification</code>：用于生成合成的分类数据集 。   </li><li><code>matplotlib.pyplot</code>：用于可视化结果。   </li><li><code>numpy</code>：进行数值计算。</li></ul></li></ul><hr><h3 id="2-定义高斯概率密度函数"><a href="#2-定义高斯概率密度函数" class="headerlink" title="2. 定义高斯概率密度函数"></a>2. 定义高斯概率密度函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def gaussian_pdf(x, mean, std_dev): </span><br><span class="line">    return (1 / (np.sqrt(2 * np.pi) * std_dev)) * np.exp(-0.5 * ((x - mean) / std_dev)**2) </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：计算单个特征值在高斯分布下的概率密度。   </li><li><strong>公式解释</strong>：</li></ul><p>高斯分布（正态分布）的概率密度函数公式为：<br>$$<br>f(x) &#x3D; \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{(x-\mu)^2}{2\sigma^2}}<br>$$<br>其中 <code>mean</code> 是均值 $ \mu $，<code>std\_dev</code> 是标准差 $ \sigma $。   </p><ul><li><strong>应用场景</strong>：在朴素贝叶斯分类器中，假设每个特征在给定类别下服从高斯分布。</li></ul><hr><h3 id="3-自定义数据集划分函数"><a href="#3-自定义数据集划分函数" class="headerlink" title="3. 自定义数据集划分函数"></a>3. 自定义数据集划分函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def train_test_split(X, y, test_size=0.2, random_state=None): </span><br><span class="line">    if random_state is not None: </span><br><span class="line">        np.random.seed(random_state)    </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：将数据集划分为训练集和测试集。   </li><li><strong>参数说明</strong>：   <ul><li><code>X</code>：特征数据。   </li><li><code>y</code>：目标标签。   </li><li><code>test\_size</code>：测试集比例（默认 20%）。   </li><li><code>random\_state</code>：随机种子，确保结果可复现 。</li></ul></li><li><strong>实现逻辑</strong>：   <ul><li>使用 <code>np.random.permutation</code> 打乱数据索引。   </li><li>按比例划分测试集和训练集。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m = X.shape[0]                              # 获取数据集的大小 </span><br><span class="line">permutation = np.random.permutation(m)      # 随机生成打乱的数组 对应为打乱的索引</span><br><span class="line">test_size = int(m * test_size)              # 计算测试集的大小 </span><br><span class="line">test_indices = permutation[:test_size]      # 取test_size个打乱的索引</span><br><span class="line">train_indices = permutation[test_size:]     # 取后面所有索引作为训练集    </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>关键步骤</strong>：   <ul><li><code>X.shape[0]</code>：获取样本总数。   </li><li><code>permutation</code>：生成随机索引。   </li><li><code>test\_indices</code>：前 <code>test\_size</code> 个索引作为测试集。   </li><li><code>train\_indices</code>：剩余索引作为训练集。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X_train = X[train_indices] </span><br><span class="line">X_test = X[test_indices] </span><br><span class="line">y_train = y[train_indices] </span><br><span class="line">y_test = y[test_indices] </span><br><span class="line"> </span><br><span class="line">return X_train, X_test, y_train, y_test </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>输出</strong>：返回划分后的训练集和测试集。</li></ul><hr><h3 id="4-贝叶斯分类器的预测函数"><a href="#4-贝叶斯分类器的预测函数" class="headerlink" title="4. 贝叶斯分类器的预测函数"></a>4. 贝叶斯分类器的预测函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def predict_bayes(x, means, variances, priors): </span><br><span class="line">    posteriors = [] </span><br><span class="line">    for i in range(len(means)): </span><br><span class="line">        likelihood = np.prod(gaussian_pdf(x, means[i], np.sqrt(variances[i])))      </span><br><span class="line">        posterior = likelihood * priors[i]                                          </span><br><span class="line">        posteriors.append(posterior)                                                </span><br><span class="line">    return np.argmax(posteriors) </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：基于朴素贝叶斯算法预测样本类别。   </li><li><strong>步骤解析</strong>：   <ol><li><strong>似然计算</strong>：对每个特征计算高斯概率密度，并通过 <code>np.prod</code> 连乘得到联合概率（假设特征条件独立）。   </li><li><strong>后验概率</strong>：似然乘以先验概率 <code>priors[i]</code>。   </li><li><strong>分类决策</strong>：选择后验概率最大的类别作为预测结果（<code>np.argmax</code>）。</li></ol></li></ul><hr><h3 id="5-生成合成数据集"><a href="#5-生成合成数据集" class="headerlink" title="5. 生成合成数据集"></a>5. 生成合成数据集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X, y = make_classification(n_samples=1500, n_features=2, </span><br><span class="line">                            n_informative=2, n_redundant=0,  </span><br><span class="line">                            n_clusters_per_class=1, random_state=6) </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：生成一个二维二分类数据集。   </li><li><strong>参数解释</strong>：   <ul><li><code>n\_samples=1500</code>：生成 1500 个样本。   </li><li><code>n\_features=2</code>：每个样本有 2 个特征（x1, x2）。   </li><li><code>n\_informative=2</code>：两个特征均为信息性特征（用于分类）。   </li><li><code>n\_redundant=0</code>：无冗余特征。   </li><li><code>n\_clusters\_per\_class=1</code>：每个类别有 1 个聚类中心。   </li><li><code>random\_state=6</code>：确保数据生成可复现 。</li></ul></li></ul><hr><h3 id="6-数据集划分"><a href="#6-数据集划分" class="headerlink" title="6. 数据集划分"></a>6. 数据集划分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将数据集按 80%&#x2F;20% 划分为训练集和测试集。</li></ul><hr><h3 id="7-计算类别均值和方差"><a href="#7-计算类别均值和方差" class="headerlink" title="7. 计算类别均值和方差"></a>7. 计算类别均值和方差</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unique_classes = np.unique(y_train) </span><br><span class="line"></span><br><span class="line">means = []          </span><br><span class="line">variances = []      </span><br><span class="line">for i in unique_classes: </span><br><span class="line">    X_train_class_i = X_train[y_train == i]                 </span><br><span class="line">    mean_class_i = np.mean(X_train_class_i, axis=0)         </span><br><span class="line">    variance_class_i = np.var(X_train_class_i, axis=0)     </span><br><span class="line">    means.append(mean_class_i) </span><br><span class="line">    variances.append(variance_class_i) </span><br><span class="line"> </span><br><span class="line">means = np.array(means) </span><br><span class="line">variances = np.array(variances) </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：对每个类别计算特征的均值和方差。   </li><li><strong>关键点</strong>：   <ul><li><code>np.unique(y\_train)</code>：获取训练集中所有类别标签。   </li><li><code>X\_train[y\_train == i]</code>：筛选当前类别的样本。   </li><li><code>np.mean</code> 和 <code>np.var</code>：计算均值和方差。</li></ul></li></ul><hr><h3 id="8-计算先验概率"><a href="#8-计算先验概率" class="headerlink" title="8. 计算先验概率"></a>8. 计算先验概率</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priors = [np.mean(y_train == i) for i in np.unique(y_train)] </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：计算每个类别的先验概率 $ P(Y) $。   </li><li><strong>实现原理</strong>：</li></ul><h2 id="对于布尔数组-y-train-i，np-mean-返回-True（即类别-i-的样本）的比例。"><a href="#对于布尔数组-y-train-i，np-mean-返回-True（即类别-i-的样本）的比例。" class="headerlink" title="对于布尔数组 y\_train == i，np.mean 返回 True（即类别 i 的样本）的比例。   "></a>对于布尔数组 <code>y\_train == i</code>，<code>np.mean</code> 返回 <code>True</code>（即类别 i 的样本）的比例。   </h2><h3 id="9-预测与评估"><a href="#9-预测与评估" class="headerlink" title="9. 预测与评估"></a>9. 预测与评估</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y_pred = [predict_bayes(x, means, variances, priors) for x in X_test] </span><br><span class="line">correct = np.sum(y_pred == y_test) / len(y_test)                            </span><br><span class="line">print(&quot;Accuracy: &#123;:.2f&#125;%&quot;.format(correct * 100)) </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：   <ul><li>对测试集逐样本预测类别。   </li><li>计算准确率：预测正确的样本数占总样本数的比例。</li></ul></li></ul><hr><h3 id="10-可视化结果"><a href="#10-可视化结果" class="headerlink" title="10. 可视化结果"></a>10. 可视化结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(16, 8))</span><br><span class="line">scatter_true = plt.scatter(X_test[:, 0], X_test[:, 1], c=y_test,  </span><br><span class="line">                           s=30, cmap=&#x27;coolwarm&#x27;,label=&#x27;True class&#x27;) </span><br><span class="line">scatter_pred = plt.scatter(X_test[:, 0], X_test[:, 1], s=30,  </span><br><span class="line">                           facecolors=&#x27;none&#x27;,  </span><br><span class="line">                           edgecolors=np.array([&#x27;b&#x27;, &#x27;r&#x27;])[y_pred], </span><br><span class="line">                           label = &#x27;Predicted class&#x27;) </span><br><span class="line">plt.legend(handles=[scatter_true, scatter_pred]) </span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：可视化测试集的真实标签和预测结果。   </li><li><strong>图形说明</strong>：   <ul><li><code>c=y\_test</code>：颜色表示真实类别（红&#x2F;蓝）。   </li><li><code>edgecolors=np.array([&#39;b&#39;, &#39;r&#39;])[y\_pred]</code>：边缘颜色表示预测类别。   </li><li><code>facecolors=&#39;none&#39;</code>：仅显示边缘，便于对比预测与真实标签。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250524_03.png" alt="Accuracy&#x3D;95%"> </p><hr><h3 id="关键知识点总结"><a href="#关键知识点总结" class="headerlink" title="关键知识点总结"></a>关键知识点总结</h3><ol><li><strong>朴素贝叶斯假设</strong>：特征之间条件独立，通过连乘计算联合概率 。   </li><li><strong>高斯分布建模</strong>：假设每个特征在给定类别下服从正态分布。   </li><li><strong>先验概率估计</strong>：通过训练集中类别的频率计算 $ P(Y) $。   </li><li><strong>决策规则</strong>：最大化后验概率 $ P(Y|X) \propto P(X|Y)P(Y) $。</li></ol><hr><h1 id="核函数估计概率密度函数的朴素贝叶斯"><a href="#核函数估计概率密度函数的朴素贝叶斯" class="headerlink" title="核函数估计概率密度函数的朴素贝叶斯"></a>核函数估计概率密度函数的朴素贝叶斯</h1><h3 id="1-predict-bayes-函数：基于损失矩阵的贝叶斯决策"><a href="#1-predict-bayes-函数：基于损失矩阵的贝叶斯决策" class="headerlink" title="1. predict_bayes 函数：基于损失矩阵的贝叶斯决策"></a>1. predict_bayes 函数：基于损失矩阵的贝叶斯决策</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def predict_bayes(x, parzen_estimations, priors, loss_matrix): </span><br><span class="line">    expected_losses = []                                        # 初始化期望损失列表 </span><br><span class="line">    for j in range(len(parzen_estimations)): </span><br><span class="line">        expected_loss = 0                                       # 初始化期望损失 </span><br><span class="line">        for i in range(len(parzen_estimations)): </span><br><span class="line">            posterior = priors[i] * parzen_estimations[i]       # 计算后验概率     </span><br><span class="line">            expected_loss += loss_matrix[i][j] * posterior      # 计算期望损失 </span><br><span class="line">        expected_losses.append(expected_loss)                   # 将期望损失添加到列表中 </span><br><span class="line">    return np.argmin(expected_losses, axis=0)                   # 返回期望损失最小的类别作为预测结果</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：根据<strong>期望损失最小化</strong>原则，将输入样本 <code>x</code> 分类到某个类别。   </li><li><strong>关键步骤解析</strong>：   <ol><li><strong>后验概率计算</strong>：    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">posterior = priors[i] * parzen_estimations[i]</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>公式</strong>：</li></ul></li></ol><ul><li><strong>理论依据</strong>：贝叶斯定理 $ P(Y|X) &#x3D; \frac{P(Y) \cdot P(X|Y)}{P(X)} $，分母 $ P(X) $ 对所有类别相同，可忽略 。</li></ul></li></ul><ol><li><strong>期望损失计算</strong>：    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expected_loss += loss_matrix[i][j] * posterior</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>公式</strong>：</li></ul></li></ol><ul><li><strong>理论依据</strong>：贝叶斯决策的目标是最小化<strong>条件风险</strong>（即期望损失），而非单纯最大化后验概率 。</li></ul><ol start="2"><li><strong>决策规则</strong>：    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return np.argmin(expected_losses, axis=0)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：选择期望损失最小的类别 <code>j</code> 作为预测结果，而非直接选择后验概率最大的类别。   </li><li><strong>对比普通贝叶斯</strong>：普通朴素贝叶斯仅比较后验概率（即损失矩阵为单位矩阵时的情况），而此代码通过自定义 <code>loss\_matrix</code> 实现<strong>风险敏感决策</strong> 。</li></ul></li></ol><hr><h3 id="2-Parzen窗口估计：非参数概率密度估计"><a href="#2-Parzen窗口估计：非参数概率密度估计" class="headerlink" title="2. Parzen窗口估计：非参数概率密度估计"></a>2. Parzen窗口估计：非参数概率密度估计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def parzen_window_estimation(x, data, h=1, window_func=squ_window): </span><br><span class="line">    N, d = data.shape                           # 获取数据的数量和维度</span><br><span class="line">    k_n = window_func(cdist(x, data) / h)       # 计算每个样本到x的距离并应用窗口函数限制权重</span><br><span class="line">    return np.sum(k_n, axis=1) / (N * h**d)     # 返回Parzen窗口估计的结果 shape=[N, ] h是窗大小</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：通过Parzen窗口法估计样本 <code>x</code> 的概率密度。   </li><li><strong>关键步骤解析</strong>：   <ol><li><strong>距离计算</strong>：    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cdist(x, data) / h</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：计算测试样本 <code>x</code> 与所有训练样本 <code>data</code> 的欧氏距离，并除以带宽 <code>h</code> 进行归一化。   </li><li><strong>理论依据</strong>：Parzen窗口是一种非参数密度估计方法，通过核函数（窗口函数）加权邻域内的样本点 。</li></ul></li><li><strong>窗口函数应用</strong>：    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window_func(...)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>窗口函数类型</strong>：   <ul><li><strong>方窗</strong>（<code>squ\_window</code>）：仅统计距离在 <code>[-h/2, h/2]</code> 内的样本。   </li><li><strong>正态窗</strong>（<code>nor\_window</code>）：使用高斯分布权重（权重随距离指数衰减）。   </li><li><strong>指数窗</strong>（<code>exp\_window</code>）：权重随距离线性衰减。   </li><li><strong>三角窗</strong>（<code>tri\_window</code>）：权重随距离线性衰减至零。</li></ul></li><li><strong>理论依据</strong>：不同窗口函数对密度估计的平滑性有影响，正态窗适合连续分布，方窗适合离散分布 。</li></ul></li><li><strong>密度估计值</strong>：    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.sum(...) / (N * h**d)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>公式</strong>：</li></ul></li></ol><ul><li><strong>理论依据</strong>：Parzen窗口通过核密度估计逼近真实分布，无需假设数据服从特定分布 。</li></ul></li></ul><hr><h3 id="3-代码整体流程与贝叶斯决策的关系"><a href="#3-代码整体流程与贝叶斯决策的关系" class="headerlink" title="3. 代码整体流程与贝叶斯决策的关系"></a>3. 代码整体流程与贝叶斯决策的关系</h3><ol><li><strong>训练阶段</strong>：   <ul><li>对每个类别 <code>i</code>，使用训练数据 <code>X\_train[y\_train == i]</code> 计算 Parzen 窗口密度估计 <code>parzen\_estimations[i]</code>。   </li><li>计算每个类别的先验概率 <code>priors[i] = P(Y=i)</code>。</li></ul></li><li><strong>预测阶段</strong>：   <ul><li>对每个测试样本 <code>x</code>：   <ul><li>使用 Parzen 窗口法计算其在每个类别下的概率密度 <code>parzen\_estimations</code>。   </li><li>结合先验概率和损失矩阵，计算每个可能决策的期望损失。   </li><li>选择期望损失最小的类别作为预测结果。</li></ul></li></ul></li><li><strong>与普通朴素贝叶斯的区别</strong>：   <ul><li><strong>普通朴素贝叶斯</strong>：假设特征服从特定分布（如高斯分布），且特征条件独立，直接计算后验概率。   </li><li><strong>本代码实现</strong>：   <ul><li>使用非参数方法（Parzen窗口）估计概率密度，无需假设分布形式。   </li><li>引入损失矩阵，允许自定义误分类代价（如医疗诊断中误诊癌症的代价更高）。</li></ul></li></ul></li></ol><hr><h3 id="4-关键参数的作用"><a href="#4-关键参数的作用" class="headerlink" title="4. 关键参数的作用"></a>4. 关键参数的作用</h3><ul><li>带宽 <code>**h**</code>：   <ul><li><code>h</code> 越大，密度估计越平滑（可能欠拟合），<code>h</code> 越小，密度估计越尖锐（可能过拟合）。</li></ul></li><li><strong>窗口函数</strong>：   <ul><li>方窗（<code>squ\_window</code>）适合离散分布，正态窗（<code>nor\_window</code>）适合连续分布。</li></ul></li><li>损失矩阵 <code>**loss\_matrix**</code>：   <ul><li>单位矩阵（<code>[[0,1],[1,0]]</code>）对应最小错误率决策，非单位矩阵对应最小风险决策 。</li></ul></li></ul><hr><h3 id="5-示例说明"><a href="#5-示例说明" class="headerlink" title="5. 示例说明"></a>5. 示例说明</h3><p>假设 <code>loss\_matrix = [[0, 2], [1, 0]]</code>：   </p><ul><li>将实际类别为 0 的样本误判为 1 的代价是 2，而将实际类别为 1 的样本误判为 0 的代价是 1。   </li><li>分类器会更倾向于避免将类别 0 误判为 1，从而在代价敏感场景下优化决策 。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>核心思想</strong>：通过非参数密度估计（Parzen窗口）和风险最小化（损失矩阵）实现灵活的贝叶斯决策。   </li><li><strong>适用场景</strong>：   <ul><li>数据分布未知或非高斯分布。   </li><li>不同类别的误分类代价不一致（如医疗、金融风控）。</li></ul></li><li><strong>改进方向</strong>：   <ul><li>使用交叉验证选择最优带宽 <code>h</code>。   </li><li>替换更复杂的核函数（如高斯混合核）。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250524_01.png" alt="Accuracy&#x3D;97%"></p><p>➡️ 通过加窗以及损失矩阵补偿错误判断，可以发现对于同一个数据在分类的正确性上有一定的增强；   </p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> Python </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚类分类—算法以及python实现</title>
      <link href="/2025/05/23/study/K_Means/"/>
      <url>/2025/05/23/study/K_Means/</url>
      
        <content type="html"><![CDATA[<h1 id="🧠-使用-Python-实现高效凝聚层次聚类（Agglomerative-Clustering）"><a href="#🧠-使用-Python-实现高效凝聚层次聚类（Agglomerative-Clustering）" class="headerlink" title="🧠 使用 Python 实现高效凝聚层次聚类（Agglomerative Clustering）"></a>🧠 使用 Python 实现高效凝聚层次聚类（Agglomerative Clustering）</h1><h2 id="在本篇博客中，我们将一起探索如何使用-Python-实现一个高效的-凝聚层次聚类（Agglomerative-Hierarchical-Clustering）算法，并支持三种不同的簇间距离度量方式：single-linkage-complete-linkage-和-average-linkage。我们还将通过可视化展示不同方法的效果，并分析其优劣。"><a href="#在本篇博客中，我们将一起探索如何使用-Python-实现一个高效的-凝聚层次聚类（Agglomerative-Hierarchical-Clustering）算法，并支持三种不同的簇间距离度量方式：single-linkage-complete-linkage-和-average-linkage。我们还将通过可视化展示不同方法的效果，并分析其优劣。" class="headerlink" title="在本篇博客中，我们将一起探索如何使用 Python 实现一个高效的 凝聚层次聚类（Agglomerative Hierarchical Clustering）算法，并支持三种不同的簇间距离度量方式：single linkage, complete linkage 和 average linkage。我们还将通过可视化展示不同方法的效果，并分析其优劣。   "></a>在本篇博客中，我们将一起探索如何使用 Python 实现一个高效的 <strong>凝聚层次聚类（Agglomerative Hierarchical Clustering）算法</strong>，并支持三种不同的簇间距离度量方式：<code>single linkage</code>, <code>complete linkage</code> 和 <code>average linkage</code>。我们还将通过可视化展示不同方法的效果，并分析其优劣。   </h2><h2 id="📚-一、什么是凝聚层次聚类？"><a href="#📚-一、什么是凝聚层次聚类？" class="headerlink" title="📚 一、什么是凝聚层次聚类？"></a>📚 一、什么是凝聚层次聚类？</h2><p>凝聚层次聚类是一种 <strong>自底向上的无监督聚类算法</strong>，它的核心思想是：   </p><blockquote><p>每个数据点初始时都是一个独立的簇，然后逐步合并最相似的两个簇，直到达到预设的簇数。   </p></blockquote><h2 id="与-K-Means-不同，它不需要提前指定簇的数量即可构建整个聚类树（dendrogram），因此非常适合探索性数据分析。"><a href="#与-K-Means-不同，它不需要提前指定簇的数量即可构建整个聚类树（dendrogram），因此非常适合探索性数据分析。" class="headerlink" title="与 K-Means 不同，它不需要提前指定簇的数量即可构建整个聚类树（dendrogram），因此非常适合探索性数据分析。   "></a>与 K-Means 不同，它不需要提前指定簇的数量即可构建整个聚类树（dendrogram），因此非常适合探索性数据分析。   </h2><h2 id="⚙️-二、代码概述"><a href="#⚙️-二、代码概述" class="headerlink" title="⚙️ 二、代码概述"></a>⚙️ 二、代码概述</h2><h3 id="🔍-功能亮点："><a href="#🔍-功能亮点：" class="headerlink" title="🔍 功能亮点："></a>🔍 功能亮点：</h3><ul><li>支持三种 <strong>linkage 方法</strong>：   <ul><li><code>&#39;single&#39;</code>: 最短距离法（最近邻）   </li><li><code>&#39;complete&#39;</code>: 最长距离法（最远邻）   </li><li><code>&#39;average&#39;</code>: 平均距离法</li></ul></li><li>使用 <strong>最小堆（heapq）</strong> 加速查找最近簇对   </li><li>对 Iris 数据集进行特征选择后聚类   </li><li>绘制原始标签与不同 linkage 聚类结果对比图</li></ul><hr><h2 id="📦-三、依赖库介绍"><a href="#📦-三、依赖库介绍" class="headerlink" title="📦 三、依赖库介绍"></a>📦 三、依赖库介绍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import heapq</span><br><span class="line">from scipy.spatial.distance import squareform, pdist</span><br><span class="line">from collections import defaultdict</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">库</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left"><code>numpy</code></td><td align="left">高效数组操作</td></tr><tr><td align="left"><code>pandas</code></td><td align="left">数据读取与处理</td></tr><tr><td align="left"><code>matplotlib</code></td><td align="left">可视化绘图</td></tr><tr><td align="left"><code>heapq</code></td><td align="left">最小堆实现优先队列</td></tr><tr><td align="left"><code>scipy.spatial.distance</code></td><td align="left">计算成对距离</td></tr></tbody></table><hr><h2 id="📐-四、核心函数详解"><a href="#📐-四、核心函数详解" class="headerlink" title="📐 四、核心函数详解"></a>📐 四、核心函数详解</h2><h3 id="1-簇间距离计算函数"><a href="#1-簇间距离计算函数" class="headerlink" title="1. 簇间距离计算函数"></a>1. 簇间距离计算函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def cluster_distance(c1, c2, dist_matrix, method=&#x27;single&#x27;):</span><br><span class="line">    if method == &#x27;single&#x27;:</span><br><span class="line">        return np.min(dist_matrix[np.ix_(c1, c2)])</span><br><span class="line">    elif method == &#x27;complete&#x27;:</span><br><span class="line">        return np.max(dist_matrix[np.ix_(c1, c2)])</span><br><span class="line">    elif method == &#x27;average&#x27;:</span><br><span class="line">        return np.mean(dist_matrix[np.ix_(c1, c2)])</span><br><span class="line">    else:</span><br><span class="line">        raise ValueError(&quot;Unknown method&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：根据指定的 <code>linkage</code> 方法计算两个簇之间的距离。   </li><li><strong>使用场景</strong>：   <ul><li><code>&#39;single&#39;</code>: 用于识别链状分布的数据。   </li><li><code>&#39;complete&#39;</code>: 更关注簇内紧密性。   </li><li><code>&#39;average&#39;</code>: 两者折中，适合大多数情况 。</li></ul></li></ul><hr><h3 id="2-初始化距离矩阵"><a href="#2-初始化距离矩阵" class="headerlink" title="2. 初始化距离矩阵"></a>2. 初始化距离矩阵</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dist_matrix = squareform(pdist(features[:, feature_indices]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>pdist</code>：计算所有样本两两之间的欧氏距离。   </li><li><code>squareform</code>：将压缩的距离向量转换为 N×N 的距离矩阵 。</li></ul><hr><h3 id="3-初始化每个样本为独立簇"><a href="#3-初始化每个样本为独立簇" class="headerlink" title="3. 初始化每个样本为独立簇"></a>3. 初始化每个样本为独立簇</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init_clusters = [[i] for i in range(numberOfsamples)]</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>初始时每个样本是一个簇，用索引表示。</li></ul><hr><h3 id="4-构建最小堆维护簇对距离"><a href="#4-构建最小堆维护簇对距离" class="headerlink" title="4. 构建最小堆维护簇对距离"></a>4. 构建最小堆维护簇对距离</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in range(len(clusters)):</span><br><span class="line">    for j in range(i+1, len(clusters)):</span><br><span class="line">        dist = cluster_distance(clusters[i], clusters[j], dist_matrix, method)</span><br><span class="line">        heapq.heappush(heap, (dist, i, j))</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用 <code>heapq</code> 构建最小堆，每次取出当前最近的簇对进行合并。   </li><li>时间复杂度从 O(N³) 降低至 O(N² log N) 。</li></ul><hr><h3 id="5-合并簇并更新堆"><a href="#5-合并簇并更新堆" class="headerlink" title="5. 合并簇并更新堆"></a>5. 合并簇并更新堆</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while sum(valid) &gt; numberOfcluster:</span><br><span class="line">    while True:</span><br><span class="line">        dist, i, j = heapq.heappop(heap)</span><br><span class="line">        if valid[i] and valid[j]:</span><br><span class="line">            break</span><br><span class="line">    clusters[i].extend(clusters[j])</span><br><span class="line">    valid[j] = False</span><br><span class="line">    for k in range(len(clusters)):</span><br><span class="line">        if k != i and valid[k]:</span><br><span class="line">            dist = cluster_distance(clusters[i], clusters[k], dist_matrix, method)</span><br><span class="line">            heapq.heappush(heap, (dist, i, k))</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>有效簇标记</strong>：使用 <code>valid</code> 数组记录哪些簇是有效的。   </li><li><strong>动态更新距离</strong>：合并后重新计算新簇与其他簇的距离并插入堆中。</li></ul><hr><h2 id="📊-六、可视化展示"><a href="#📊-六、可视化展示" class="headerlink" title="📊 六、可视化展示"></a>📊 六、可视化展示</h2><p>我们绘制了四种图像：   </p><ol><li>原始数据按真实标签显示   </li><li><code>&#39;single&#39;</code> linkage 聚类结果   </li><li><code>&#39;complete&#39;</code> linkage 聚类结果   </li><li><code>&#39;average&#39;</code> linkage 聚类结果</li></ol><p>每种方法都使用不同颜色和形状的标记来区分簇。   </p><h3 id="示例代码片段："><a href="#示例代码片段：" class="headerlink" title="示例代码片段："></a>示例代码片段：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(</span><br><span class="line">    features[clu, feature_indices[0]],</span><br><span class="line">    features[clu, feature_indices[1]],</span><br><span class="line">    color=[color],</span><br><span class="line">    marker=marker,</span><br><span class="line">    label=f&#x27;Cluster &#123;idx+1&#125;&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250523191326805.png" alt="Agglomerative Clustering"></p><hr><h2 id="🧩-七、三种-Linkage-方法对比"><a href="#🧩-七、三种-Linkage-方法对比" class="headerlink" title="🧩 七、三种 Linkage 方法对比"></a>🧩 七、三种 Linkage 方法对比</h2><table><thead><tr><th align="left">Linkage 方法</th><th align="left">特点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><code>&#39;single&#39;</code></td><td align="left">容易形成“链式”簇</td><td align="left">适用于流形型数据</td></tr><tr><td align="left"><code>&#39;complete&#39;</code></td><td align="left">强调簇内紧凑性</td><td align="left">适用于球形分布数据</td></tr><tr><td align="left"><code>&#39;average&#39;</code></td><td align="left">折中方案，平衡表现</td><td align="left">通用性强</td></tr></tbody></table><hr><h2 id="📚-参考资料"><a href="#📚-参考资料" class="headerlink" title="📚 参考资料"></a>📚 参考资料</h2><ul><li>[1] Scipy pdist &amp; squareform 文档   </li><li>[2] NumPy 与 Pandas 简介   </li><li>[3] 密度峰值聚类算法综述   </li><li>[4] 自适应密度峰值聚类算法   </li><li>[5] 层次聚类与 DPC 算法对比</li></ul><hr><h1 id="🧠-使用-Python-实现向量化-K-Means-聚类算法"><a href="#🧠-使用-Python-实现向量化-K-Means-聚类算法" class="headerlink" title="🧠 使用 Python 实现向量化 K-Means 聚类算法"></a>🧠 使用 Python 实现向量化 K-Means 聚类算法</h1><h2 id="K-Means-是一种经典的无监督聚类算法，广泛应用于数据挖掘、图像压缩、客户分群等领域。本文将带你一步步理解并实现一个高效的向量化-K-Means-算法，并通过-sklearn-加载-Iris-数据集进行实战演示。"><a href="#K-Means-是一种经典的无监督聚类算法，广泛应用于数据挖掘、图像压缩、客户分群等领域。本文将带你一步步理解并实现一个高效的向量化-K-Means-算法，并通过-sklearn-加载-Iris-数据集进行实战演示。" class="headerlink" title="K-Means 是一种经典的无监督聚类算法，广泛应用于数据挖掘、图像压缩、客户分群等领域。本文将带你一步步理解并实现一个高效的向量化 K-Means 算法，并通过 sklearn 加载 Iris 数据集进行实战演示。   "></a>K-Means 是一种经典的无监督聚类算法，广泛应用于数据挖掘、图像压缩、客户分群等领域。本文将带你一步步理解并实现一个<strong>高效的向量化 K-Means 算法</strong>，并通过 <code>sklearn</code> 加载 Iris 数据集进行实战演示。   </h2><h2 id="📦-一、环境依赖与数据准备"><a href="#📦-一、环境依赖与数据准备" class="headerlink" title="📦 一、环境依赖与数据准备"></a>📦 一、环境依赖与数据准备</h2><p>我们使用如下库：   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">from sklearn.cluster import KMeans</span><br><span class="line">from sklearn import datasets</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="✅-数据加载"><a href="#✅-数据加载" class="headerlink" title="✅ 数据加载"></a>✅ 数据加载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iris = datasets.load_iris()</span><br><span class="line">X = iris.data[:, :4]</span><br><span class="line">numberOfcluster = len(iris.target_names)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>X</code>: 特征矩阵（150 × 4）   </li><li><code>numberOfcluster</code>: 类别数为 3</li></ul><hr><h2 id="⚙️-二、使用-sklearn-的-KMeans-进行聚类"><a href="#⚙️-二、使用-sklearn-的-KMeans-进行聚类" class="headerlink" title="⚙️ 二、使用 sklearn 的 KMeans 进行聚类"></a>⚙️ 二、使用 sklearn 的 KMeans 进行聚类</h2><p>我们先调用 <code>sklearn.cluster.KMeans</code> 快速完成聚类任务：   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">estimator = KMeans(n_clusters=numberOfcluster)</span><br><span class="line">estimator.fit(X)</span><br><span class="line">label_pred = estimator.labels_</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后绘制原始数据和聚类后的结果图：   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(12, 8))</span><br><span class="line">plt.subplot(121)</span><br><span class="line">plt.scatter(X[:, 1], X[:, 2], c=&quot;red&quot;, marker=&#x27;o&#x27;, label=&#x27;data&#x27;) </span><br><span class="line">plt.xlabel(&#x27;sepal length&#x27;) </span><br><span class="line">plt.ylabel(&#x27;sepal width&#x27;) </span><br><span class="line">plt.legend(loc=2) </span><br><span class="line"></span><br><span class="line">plt.subplot(122)</span><br><span class="line">x0 = X[label_pred == 0] </span><br><span class="line">x1 = X[label_pred == 1] </span><br><span class="line">x2 = X[label_pred == 2] </span><br><span class="line">plt.scatter(x0[:, 1], x0[:, 2], c=&quot;red&quot;, marker=&#x27;o&#x27;, label=&#x27;label0&#x27;) </span><br><span class="line">plt.scatter(x1[:, 1], x1[:, 2], c=&quot;green&quot;, marker=&#x27;*&#x27;, label=&#x27;label1&#x27;) </span><br><span class="line">plt.scatter(x2[:, 1], x2[:, 2], c=&quot;blue&quot;, marker=&#x27;+&#x27;, label=&#x27;label2&#x27;) </span><br><span class="line">plt.xlabel(&#x27;sepal length&#x27;) </span><br><span class="line">plt.ylabel(&#x27;sepal width&#x27;) </span><br><span class="line">plt.legend(loc=2) </span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>✅ 使用 sklearn 可以快速完成聚类，但了解其内部实现更有助于深入理解算法原理 。   </p></blockquote><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250523191344622.png" alt="K-Means"></p><hr><h2 id="🧩-三、手动实现向量化-K-Means"><a href="#🧩-三、手动实现向量化-K-Means" class="headerlink" title="🧩 三、手动实现向量化 K-Means"></a>🧩 三、手动实现向量化 K-Means</h2><p>为了更深入理解 K-Means 的工作原理，我们实现了<strong>向量化版本的 K-Means 算法</strong>，避免了传统的嵌套循环，提高了计算效率。   </p><h3 id="1-向量化计算距离矩阵"><a href="#1-向量化计算距离矩阵" class="headerlink" title="1. 向量化计算距离矩阵"></a>1. 向量化计算距离矩阵</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def compute_distances(dataSet, centroids):</span><br><span class="line">    m = dataSet.shape[0]</span><br><span class="line">    k = centroids.shape[0]</span><br><span class="line">    diff = dataSet[:, np.newaxis, :] - centroids[np.newaxis, :, :]</span><br><span class="line">    distances = np.sum(diff**2, axis=2)</span><br><span class="line">    return distances</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>利用 NumPy 广播机制一次性计算所有点到质心的距离。   </li><li>避免双重 for 循环，提升性能 。</li></ul><hr><h3 id="2-分配样本到最近质心"><a href="#2-分配样本到最近质心" class="headerlink" title="2. 分配样本到最近质心"></a>2. 分配样本到最近质心</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def assign_clusters(distances):</span><br><span class="line">    return np.argmin(distances, axis=1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>沿列方向取最小值索引，确定每个样本所属簇。</li></ul><hr><h3 id="3-随机初始化质心"><a href="#3-随机初始化质心" class="headerlink" title="3. 随机初始化质心"></a>3. 随机初始化质心</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def randomCenter(dataSet, k): </span><br><span class="line">    m, n = dataSet.shape  </span><br><span class="line">    centroids = np.zeros((k, n))  </span><br><span class="line">    for i in range(k):  </span><br><span class="line">        index = int(np.random.uniform(0, m))   </span><br><span class="line">        centroids[i, :] = dataSet[index, :]  </span><br><span class="line">    return centroids</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>从数据集中随机选择 <code>k</code> 个样本作为初始质心 。</li></ul><hr><h3 id="4-更新质心"><a href="#4-更新质心" class="headerlink" title="4. 更新质心"></a>4. 更新质心</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def update_centroids(dataSet, cluster_indices, k):</span><br><span class="line">    centroids = np.zeros((k, dataSet.shape[1]))</span><br><span class="line">    for j in range(k):</span><br><span class="line">        mask = (cluster_indices == j)</span><br><span class="line">        if np.any(mask):</span><br><span class="line">            centroids[j] = np.mean(dataSet[mask], axis=0)</span><br><span class="line">    return centroids</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>对每个簇计算均值作为新质心。</li></ul><hr><h3 id="5-主函数：向量化-K-Means"><a href="#5-主函数：向量化-K-Means" class="headerlink" title="5. 主函数：向量化 K-Means"></a>5. 主函数：向量化 K-Means</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def KMeans_vectorized(dataSet, k, max_iter=100):</span><br><span class="line">    centroids = randomCenter(dataSet, k)</span><br><span class="line">    </span><br><span class="line">    for iter_num in range(max_iter):</span><br><span class="line">        distances = compute_distances(dataSet, centroids)</span><br><span class="line">        cluster_indices = assign_clusters(distances)</span><br><span class="line">        new_centroids = update_centroids(dataSet, cluster_indices, k)</span><br><span class="line"></span><br><span class="line">        if np.allclose(centroids, new_centroids):</span><br><span class="line">            break</span><br><span class="line">        centroids = new_centroids</span><br><span class="line">    return centroids, cluster_indices, iter_num</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>收敛条件：新旧质心几乎相等时停止迭代。   </li><li>最终返回质心、簇标签和迭代次数。</li></ul><hr><h2 id="📊-四、可视化聚类结果"><a href="#📊-四、可视化聚类结果" class="headerlink" title="📊 四、可视化聚类结果"></a>📊 四、可视化聚类结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(12, 8))</span><br><span class="line">colors_list = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]</span><br><span class="line">markers_list = [&#x27;o&#x27;, &#x27;s&#x27;, &#x27;^&#x27;]</span><br><span class="line"></span><br><span class="line">for i in range(k):</span><br><span class="line">    plt.scatter(</span><br><span class="line">        dataSet[clusterAssment == i, 1], </span><br><span class="line">        dataSet[clusterAssment == i, 3], </span><br><span class="line">        c=colors_list[i], </span><br><span class="line">        marker=markers_list[i], </span><br><span class="line">        label=f&#x27;Cluster &#123;i+1&#125;&#x27;</span><br><span class="line">    )</span><br><span class="line">    plt.scatter(</span><br><span class="line">        centroids[i, 1], </span><br><span class="line">        centroids[i, 3], </span><br><span class="line">        c=colors_list[i], </span><br><span class="line">        marker=&#x27;x&#x27;, </span><br><span class="line">        s=100, </span><br><span class="line">        label=&#x27;Centroids&#x27;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">plt.xlabel(&#x27;Feature 0&#x27;)</span><br><span class="line">plt.ylabel(&#x27;Feature 1&#x27;)</span><br><span class="line">plt.title(f&#x27;KMeans Clustering Result in iter num: &#123;iter_num&#125;&#x27;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>不同颜色代表不同簇。   </li><li>不同标记区分簇内点与质心。</li></ul><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250523191351498.png" alt="K-Means"></p><hr><h2 id="📌-五、总结"><a href="#📌-五、总结" class="headerlink" title="📌 五、总结"></a>📌 五、总结</h2><table><thead><tr><th align="left">功能</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">向量化实现</td><td align="left">提升聚类速度，适用于大规模数据</td></tr><tr><td align="left">随机初始化</td><td align="left">简单易懂，但可能陷入局部最优</td></tr><tr><td align="left">收敛判断</td><td align="left">使用 <code>np.allclose()</code> 避免无限迭代</td></tr><tr><td align="left">可视化支持</td><td align="left">帮助直观理解聚类效果</td></tr></tbody></table><hr><h2 id="📚-六、参考资料"><a href="#📚-六、参考资料" class="headerlink" title="📚 六、参考资料"></a>📚 六、参考资料</h2><ul><li>[1] Scikit-learn 官方文档：KMeans 聚类介绍   </li><li>[2] KMeans 初始化方法详解：<code>k-means++</code> vs <code>random</code>   </li><li>[3] NumPy 和 Matplotlib 在机器学习中的应用   </li><li>[4] 向量化计算提高效率的方法</li></ul><hr><h1 id="🧠-使用-Python-实现自定义-DBSCAN-聚类算法"><a href="#🧠-使用-Python-实现自定义-DBSCAN-聚类算法" class="headerlink" title="🧠 使用 Python 实现自定义 DBSCAN 聚类算法"></a>🧠 使用 Python 实现自定义 DBSCAN 聚类算法</h1><h2 id="DBSCAN（Density-Based-Spatial-Clustering-of-Applications-with-Noise）是一种基于密度的聚类算法，能够发现任意形状的簇，并且能识别出噪声点。本篇博客将带你一步步实现一个高效的-自定义-DBSCAN-算法，并使用极坐标方式生成测试样本数据集进行验证。"><a href="#DBSCAN（Density-Based-Spatial-Clustering-of-Applications-with-Noise）是一种基于密度的聚类算法，能够发现任意形状的簇，并且能识别出噪声点。本篇博客将带你一步步实现一个高效的-自定义-DBSCAN-算法，并使用极坐标方式生成测试样本数据集进行验证。" class="headerlink" title="DBSCAN（Density-Based Spatial Clustering of Applications with Noise）是一种基于密度的聚类算法，能够发现任意形状的簇，并且能识别出噪声点。本篇博客将带你一步步实现一个高效的 自定义 DBSCAN 算法，并使用极坐标方式生成测试样本数据集进行验证。   "></a>DBSCAN（Density-Based Spatial Clustering of Applications with Noise）是一种基于密度的聚类算法，能够发现任意形状的簇，并且能识别出噪声点。本篇博客将带你一步步实现一个高效的 <strong>自定义 DBSCAN 算法</strong>，并使用极坐标方式生成测试样本数据集进行验证。   </h2><h2 id="📦-一、环境依赖与数据准备-1"><a href="#📦-一、环境依赖与数据准备-1" class="headerlink" title="📦 一、环境依赖与数据准备"></a>📦 一、环境依赖与数据准备</h2><p>我们使用如下库：   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from scipy.spatial.distance import cdist</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="✅-生成测试样本"><a href="#✅-生成测试样本" class="headerlink" title="✅ 生成测试样本"></a>✅ 生成测试样本</h3><p>我们通过极坐标生成两个不同半径范围内的样本点，模拟环形分布的数据：   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def generate_sample():</span><br><span class="line">    number_of_samples = 1000</span><br><span class="line">    # 内部小圆：20% 数据</span><br><span class="line">    theta = np.random.uniform(0, 2*np.pi, int(0.2*number_of_samples))</span><br><span class="line">    r = np.sqrt(np.random.uniform(0, 4, int(0.2*number_of_samples)))</span><br><span class="line">    x = r * np.cos(theta)</span><br><span class="line">    y = r * np.sin(theta)</span><br><span class="line">    X_1 = np.column_stack((x, y))</span><br><span class="line"></span><br><span class="line">    # 外部大圆：80% 数据</span><br><span class="line">    theta = np.random.uniform(0, 2*np.pi, number_of_samples)</span><br><span class="line">    r = np.sqrt(np.random.uniform(25, 36, number_of_samples))</span><br><span class="line">    x = r * np.cos(theta)</span><br><span class="line">    y = r * np.sin(theta)</span><br><span class="line">    X_2 = np.column_stack((x, y))</span><br><span class="line"></span><br><span class="line">    # 可视化</span><br><span class="line">    plt.figure(figsize=(12, 8))</span><br><span class="line">    plt.scatter(X_1[:, 0], X_1[:, 1], color=&#x27;r&#x27;)</span><br><span class="line">    plt.scatter(X_2[:, 0], X_2[:, 1], color=&#x27;b&#x27;)</span><br><span class="line">    plt.title(&#x27;Generated Sample Data (Polar Coordinates)&#x27;)</span><br><span class="line">    plt.xlabel(&#x27;X&#x27;)</span><br><span class="line">    plt.ylabel(&#x27;Y&#x27;)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    return np.vstack((X_1, X_2))</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>✅ 该方法参考了随机采样策略，适用于测试和可视化分析。   </p></blockquote><hr><h2 id="⚙️-二、DBSCAN-类设计与实现"><a href="#⚙️-二、DBSCAN-类设计与实现" class="headerlink" title="⚙️ 二、DBSCAN 类设计与实现"></a>⚙️ 二、DBSCAN 类设计与实现</h2><h3 id="1-初始化参数"><a href="#1-初始化参数" class="headerlink" title="1. 初始化参数"></a>1. 初始化参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class DBSCAN:</span><br><span class="line">    def __init__(self, eps=3):</span><br><span class="line">        self.eps = eps</span><br><span class="line">        self.value_threshold = 750</span><br><span class="line">        self.labels = None</span><br><span class="line">        self.cluster_centers = []</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>eps</code></td><td align="left">邻域半径，用于判断邻近点</td></tr><tr><td align="left"><code>value\_threshold</code></td><td align="left">密度峰值选择阈值</td></tr></tbody></table><hr><h3 id="2-计算距离与密度"><a href="#2-计算距离与密度" class="headerlink" title="2. 计算距离与密度"></a>2. 计算距离与密度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">distances = cdist(X, X, metric=&#x27;euclidean&#x27;)</span><br><span class="line">density = np.sum(distances &lt; self.eps, axis=1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用 <code>cdist</code> 一次性计算所有点之间的欧氏距离   </li><li>每个点的局部密度是其邻域内点的数量</li></ul><hr><h3 id="3-计算最小距离"><a href="#3-计算最小距离" class="headerlink" title="3. 计算最小距离"></a>3. 计算最小距离</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">min_distances = []</span><br><span class="line">for i in range(n_samples):</span><br><span class="line">    greater_density_indices = np.where(density &gt; density[i])[0]</span><br><span class="line">    if len(greater_density_indices) &gt; 0:</span><br><span class="line">        min_distance = np.min(distances[i, greater_density_indices])</span><br><span class="line">        min_distances.append(min_distance)</span><br><span class="line">    else:</span><br><span class="line">        min_distances.append(np.max(distances[i]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>对每个点，找到比它密度高的点，并计算到这些点的最小距离</li></ul><hr><h3 id="4-选取聚类中心"><a href="#4-选取聚类中心" class="headerlink" title="4. 选取聚类中心"></a>4. 选取聚类中心</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">density_times_min_distance = density * np.array(min_distances)</span><br><span class="line">idx = np.argsort(density_times_min_distance)[::-1]</span><br><span class="line"></span><br><span class="line">mask = density_times_min_distance[idx] &gt; self.value_threshold</span><br><span class="line">selected_indices = idx[mask]</span><br><span class="line">self.labels[selected_indices] = selected_indices</span><br><span class="line">self.cluster_centers.extend(selected_indices.tolist())</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>通过 <code>density × min\_distance</code> 排序，结合阈值筛选聚类中心</li></ul><hr><h3 id="5-广度优先扩展聚类"><a href="#5-广度优先扩展聚类" class="headerlink" title="5. 广度优先扩展聚类"></a>5. 广度优先扩展聚类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Have_labeled = []</span><br><span class="line">for label in cluster_centers.keys():</span><br><span class="line">    queue_center = cluster_centers[label].copy()</span><br><span class="line">    Have_labeled.extend(queue_center)</span><br><span class="line"></span><br><span class="line">    while queue_center:</span><br><span class="line">        current = queue_center.pop(0)</span><br><span class="line">        neighbors = np.where(distances[current] &lt; self.eps)[0]</span><br><span class="line">        for neighbor in neighbors:</span><br><span class="line">            if neighbor not in Have_labeled:</span><br><span class="line">                self.labels[neighbor] = self.labels[current]</span><br><span class="line">                Have_labeled.append(neighbor)</span><br><span class="line">                queue_center.append(neighbor)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用 BFS 扩展簇，将邻域点标记为相同标签</li></ul><hr><h3 id="6-统一标签编号"><a href="#6-统一标签编号" class="headerlink" title="6. 统一标签编号"></a>6. 统一标签编号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final_labels = np.unique(self.labels)</span><br><span class="line">label_map = &#123;label: i for i, label in enumerate(final_labels)&#125;</span><br><span class="line">if -1 in label_map:</span><br><span class="line">    label_map[-1] = -1</span><br><span class="line">self.labels = np.array([label_map[label] for label in self.labels])</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>将原始索引标签映射为连续整数，便于后续处理</li></ul><hr><h2 id="📊-三、可视化聚类结果"><a href="#📊-三、可视化聚类结果" class="headerlink" title="📊 三、可视化聚类结果"></a>📊 三、可视化聚类结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unique_labels = np.unique(labels)</span><br><span class="line">colors = plt.get_cmap(&#x27;tab10&#x27;, len(unique_labels))</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(12, 8))</span><br><span class="line">for idx, label in enumerate(unique_labels):</span><br><span class="line">    mask = labels == label</span><br><span class="line">    plt.scatter(X[mask, 0], X[mask, 1], s=10, color=colors(idx),</span><br><span class="line">                label=f&#x27;Cluster &#123;label&#125;&#x27; if label != -1 else &#x27;Noise&#x27;)</span><br><span class="line"></span><br><span class="line">plt.title(&#x27;DBSCAN Clustering Result&#x27;)</span><br><span class="line">plt.xlabel(&#x27;X1&#x27;)</span><br><span class="line">plt.ylabel(&#x27;X2&#x27;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>不同颜色代表不同簇   </li><li><code>-1</code> 表示噪声点</li></ul><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250523191402097.png" alt="Raw division"><br><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250523191407495.png" alt="DBSCAN"></p><hr><h2 id="📌-四、总结与优化建议"><a href="#📌-四、总结与优化建议" class="headerlink" title="📌 四、总结与优化建议"></a>📌 四、总结与优化建议</h2><table><thead><tr><th align="left">功能</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">极坐标生成样本</td><td align="left">更适合环形或球形数据集</td></tr><tr><td align="left">向量化操作</td><td align="left">提升性能，避免双重循环</td></tr><tr><td align="left">支持噪声识别</td><td align="left">是 DBSCAN 的核心优势之一</td></tr><tr><td align="left">可视化清晰</td><td align="left">帮助理解聚类效果</td></tr></tbody></table><h3 id="✅-优化建议："><a href="#✅-优化建议：" class="headerlink" title="✅ 优化建议："></a>✅ 优化建议：</h3><ul><li>使用 <code>K-D Tree</code> 或 <code>Ball Tree</code> 加速邻域查询   </li><li>替换固定阈值为动态选择策略   </li><li>支持自动确定 <code>eps</code> 和 <code>min\_samples</code>   </li><li>使用 <code>numba</code> 或 <code>Cython</code> 加速核心循环部分</li></ul><hr><h2 id="📚-五、参考资料"><a href="#📚-五、参考资料" class="headerlink" title="📚 五、参考资料"></a>📚 五、参考资料</h2><ul><li>[1] <code>scipy.spatial.distance.cdist</code> 用法   </li><li>[2] 测试样本生成方法   </li><li>[3] 聚类算法在机器学习中的应用   </li><li>[4] DBSCAN 算法原理详解</li></ul><hr><p>🎉 感**谢阅读，希望这篇博客对你理解和实现 DBSCAN 聚类有所帮助！   </p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT+LuatOS学习日志</title>
      <link href="/2025/05/23/study/How_use_mqtt_in_LuatOS/"/>
      <url>/2025/05/23/study/How_use_mqtt_in_LuatOS/</url>
      
        <content type="html"><![CDATA[<h2 id="MQTT基础概念："><a href="#MQTT基础概念：" class="headerlink" title="MQTT基础概念："></a>MQTT基础概念：</h2><h2 id="MQTT是一种通信架构；MQTT是一个一对多的通信架构，一个服务端（Broker）可以有多个客户端（Client）；"><a href="#MQTT是一种通信架构；MQTT是一个一对多的通信架构，一个服务端（Broker）可以有多个客户端（Client）；" class="headerlink" title="MQTT是一种通信架构；MQTT是一个一对多的通信架构，一个服务端（Broker）可以有多个客户端（Client）；   "></a>MQTT是一种通信架构；<br>MQTT是一个一对多的通信架构，一个服务端（Broker）可以有多个客户端（Client）；   </h2><p>MQTT中有三个概念：   </p><ol><li>主题（Topic）   </li><li>发布（Publish）   </li><li>订阅（Subscribe）</li></ol><p>主题是一种寻址方式，类似于Window的文件夹多级目录<br><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image_2.png" alt="Topic"></p><h2 id="例如-factory-line1-machine3-temperature-等等，不同的Topic指向不同的内容以及类别；"><a href="#例如-factory-line1-machine3-temperature-等等，不同的Topic指向不同的内容以及类别；" class="headerlink" title="例如 factory/line1/machine3/temperature 等等，不同的Topic指向不同的内容以及类别；   "></a>例如 <code>factory/line1/machine3/temperature</code> 等等，不同的Topic指向不同的内容以及类别；   </h2><p>客户端Client可以即作为发布的来源也可以订阅发布的内容；<br><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image_b.png" alt="Client"></p><h2 id="而Broker作为信息的中转站，接收发布的信息并推送给订阅的用户端；"><a href="#而Broker作为信息的中转站，接收发布的信息并推送给订阅的用户端；" class="headerlink" title="而Broker作为信息的中转站，接收发布的信息并推送给订阅的用户端；   "></a>而Broker作为信息的中转站，接收发布的信息并推送给订阅的用户端；   </h2><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image_j.png" alt="Broker"></p><h2 id="发布者无需担心是否将信息发送给了订阅者，准确来说发布者与订阅者之间不是直连的！"><a href="#发布者无需担心是否将信息发送给了订阅者，准确来说发布者与订阅者之间不是直连的！" class="headerlink" title="发布者无需担心是否将信息发送给了订阅者，准确来说发布者与订阅者之间不是直连的！   "></a>发布者无需担心是否将信息发送给了订阅者，准确来说发布者与订阅者之间不是直连的！   </h2><h2 id="LuatOS中MQTT的API"><a href="#LuatOS中MQTT的API" class="headerlink" title="LuatOS中MQTT的API"></a>LuatOS中MQTT的API</h2><h3 id="常量："><a href="#常量：" class="headerlink" title="常量："></a>常量：</h3><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image.png" alt="const"></p><h3 id="订阅主题："><a href="#订阅主题：" class="headerlink" title="订阅主题："></a>订阅主题：</h3><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image_z.png" alt="subscribe"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 订阅单个topic, 且qos=0mqttc:subscribe(&quot;/luatos/123456&quot;, 0)</span></span><br><span class="line"><span class="comment">-- 订阅单个topic, 且qos=1mqttc:subscribe(&quot;/luatos/12345678&quot;, 1)</span></span><br><span class="line"><span class="comment">-- 订阅多个topic, 且使用不同的qos -&gt; &#123; , &#125;区分不同topic</span></span><br><span class="line">mqttc:subscribe(&#123;[<span class="string">&quot;/luatos/1234567&quot;</span>]=<span class="number">1</span>,[<span class="string">&quot;/luatos/12345678&quot;</span>]=<span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="创建Client："><a href="#创建Client：" class="headerlink" title="创建Client："></a>创建Client：</h3><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image_s.png" alt="Create Client"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 普通TCP链接</span></span><br><span class="line">mqttc = mqtt.<span class="built_in">create</span>(<span class="literal">nil</span>,<span class="string">&quot;120.55.137.106&quot;</span>, <span class="number">1884</span>)</span><br><span class="line"><span class="comment">-- 普通TCP链接,mqtt接收缓冲区4096</span></span><br><span class="line">mqttc = mqtt.<span class="built_in">create</span>(<span class="literal">nil</span>,<span class="string">&quot;120.55.137.106&quot;</span>, <span class="number">1884</span>, <span class="literal">nil</span>, &#123;rxSize = <span class="number">4096</span>&#125;)</span><br><span class="line"><span class="comment">-- 加密TCP链接,不验证服务器证书</span></span><br><span class="line">mqttc = mqtt.<span class="built_in">create</span>(<span class="literal">nil</span>,<span class="string">&quot;120.55.137.106&quot;</span>, <span class="number">8883</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">-- 加密TCPTCP链接,单服务器证书验证</span></span><br><span class="line">mqttc = mqtt.<span class="built_in">create</span>(<span class="literal">nil</span>,<span class="string">&quot;120.55.137.106&quot;</span>, <span class="number">8883</span>, &#123;server_cert=<span class="built_in">io</span>.readFile(<span class="string">&quot;/luadb/ca.crt&quot;</span>)&#125;)</span><br><span class="line"><span class="comment">-- 加密TCPTCP链接,单服务器证书验证, 但可选认证</span></span><br><span class="line">mqttc = mqtt.<span class="built_in">create</span>(<span class="literal">nil</span>,<span class="string">&quot;120.55.137.106&quot;</span>, <span class="number">8883</span>, &#123;server_cert=<span class="built_in">io</span>.readFile(<span class="string">&quot;/luadb/ca.crt&quot;</span>), verify=<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">-- 加密TCPTCP链接,双向证书验证</span></span><br><span class="line">mqttc = mqtt.<span class="built_in">create</span>(<span class="literal">nil</span>,<span class="string">&quot;120.55.137.106&quot;</span>, <span class="number">8883</span>, &#123;server_cert=<span class="built_in">io</span>.readFile(<span class="string">&quot;/luadb/ca.crt&quot;</span>),client_cert=<span class="built_in">io</span>.readFile(<span class="string">&quot;/luadb/client.pem&quot;</span>),client_key=<span class="built_in">io</span>.readFile(<span class="string">&quot;/luadb/client.key&quot;</span>),client_password=<span class="string">&quot;123456&quot;</span>,&#125;)</span><br></pre></td></tr></table></figure><p>上述MQTT的通信协议为TCP，官方文档说不支持Websocket！   </p><h3 id="设置登录Client的信息："><a href="#设置登录Client的信息：" class="headerlink" title="设置登录Client的信息："></a>设置登录Client的信息：</h3><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image_q.png" alt="auth"></p><h3 id="MQTT服务器连接："><a href="#MQTT服务器连接：" class="headerlink" title="MQTT服务器连接："></a>MQTT服务器连接：</h3><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image_1q.png" alt="connect"></p><h3 id="MQTT发布："><a href="#MQTT发布：" class="headerlink" title="MQTT发布："></a>MQTT发布：</h3><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image_r.png" alt="publish"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--   topic         data</span></span><br><span class="line">mqttc:publish(<span class="string">&quot;/luatos/123456&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="检测状态："><a href="#检测状态：" class="headerlink" title="检测状态："></a>检测状态：</h3><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image_m.png" alt="Check State"></p><h2 id="Lua语言的整体框架"><a href="#Lua语言的整体框架" class="headerlink" title="Lua语言的整体框架"></a>Lua语言的整体框架</h2><hr><p>在Lua中，通过调用 <code>require(&quot;sys&quot;)</code> 定义一个实例sys，可以通过这个实例来创建系统任务：<br><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image_h.png" alt="example"><br>可以同时创建多个任务，每个任务之间并行运行，且运行都限制在自己的上下文中，保障不同任务之间不会相互干扰。如果想要让不同的任务之间有先后执行的逻辑可以通过   </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sys.publish(<span class="string">&quot;net_ready&quot;</span>, device_IMEI)</span><br><span class="line">sys.waitUntil(<span class="string">&quot;net_ready&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这两句代码实现。一个用于发布一条事件，另一个等待该事件的完成，由此得到一个执行的先后顺序；   </p><h2 id="MQTT-Lua语言示例代码："><a href="#MQTT-Lua语言示例代码：" class="headerlink" title="MQTT+Lua语言示例代码："></a>MQTT+Lua语言示例代码：</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- LuaTools需要PROJECT和VERSION这两个信息</span></span><br><span class="line">PROJECT = <span class="string">&quot;mqttdemo&quot;</span></span><br><span class="line">VERSION = <span class="string">&quot;1.0.0&quot;</span></span><br></pre></td></tr></table></figure><p>.lua文件的开头必须要PROJECT的名称以及VERSION的版本；   </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--根据自己的服务器修改以下参数</span></span><br><span class="line"><span class="keyword">local</span> mqtt_host = <span class="string">&quot;lbsmqtt.airm2m.com&quot;</span></span><br><span class="line"><span class="keyword">local</span> mqtt_port = <span class="number">1884</span></span><br><span class="line"><span class="keyword">local</span> mqtt_isssl = <span class="literal">false</span></span><br><span class="line"><span class="keyword">local</span> ca_file = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--必须跟服务器的配置一样</span></span><br><span class="line"><span class="keyword">local</span> client_id = <span class="string">&quot;mqttx_b55c41b7&quot;</span></span><br><span class="line"><span class="keyword">local</span> user_name = <span class="string">&quot;user&quot;</span></span><br><span class="line"><span class="keyword">local</span> password = <span class="string">&quot;password&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> pub_topic = <span class="string">&quot;/luatos/pub/123&quot;</span><span class="comment">-- .. (mcu.unique_id():toHex())</span></span><br><span class="line"><span class="keyword">local</span> sub_topic = <span class="string">&quot;/luatos/sub/123&quot;</span><span class="comment">-- .. (mcu.unique_id():toHex())</span></span><br></pre></td></tr></table></figure><p>用户的参数配置：<br>host以及port是自己服务器的参数，isssl表示是否加密连接；   </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 结尾总是这一句</span></span><br><span class="line">sys.run()</span><br><span class="line"><span class="comment">-- sys.run()之后后面不要加任何语句!!!!!</span></span><br></pre></td></tr></table></figure><h2 id="结束的语句，启动sys并且循环运行任务列表里面的任务。"><a href="#结束的语句，启动sys并且循环运行任务列表里面的任务。" class="headerlink" title="结束的语句，启动sys并且循环运行任务列表里面的任务。   "></a>结束的语句，启动sys并且循环运行任务列表里面的任务。   </h2><p>整体的流程：   </p><ol><li>设置两个系统内部任务，任务一为联网，4G模块提供SIM卡成功联网并且返回设备的IMEI号；   </li><li>设置第二个任务，将设备的IMEI号分配给Client，并且设置发布、订阅的主题，确保独立性；   </li><li>创建mqtt连接（不一定正常连接上），以设备号以及预设置的user name和password配置mqtt，可以设置自动重连；   </li><li>编写mqtt回调函数，在mqtt回调函数中检测事件，当连接上mqtt时将数据打包并且通过publish发给broker；</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mqttc:on(<span class="function"><span class="keyword">function</span><span class="params">(mqtt_client, event, data, payload)</span></span></span><br><span class="line"><span class="built_in">log</span>.info(<span class="string">&quot;mqtt&quot;</span>, <span class="string">&quot;event&quot;</span>, event) <span class="comment">-- 可有</span></span><br><span class="line"><span class="keyword">if</span> event == <span class="string">&quot;conack&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- MQTT 连接成功</span></span><br><span class="line">    sys.publish(<span class="string">&quot;mqtt_conack&quot;</span>)</span><br><span class="line">    mqtt_client:subscribe(sub_topic)</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- 采集设备信息</span></span><br><span class="line">   <span class="keyword">local</span> imei = mobile.imei()</span><br><span class="line">   <span class="keyword">local</span> csq = mobile.csq()            <span class="comment">-- 信号强度</span></span><br><span class="line">    <span class="keyword">local</span> voltage = mobile.getVbatt()   <span class="comment">-- 电池电压（单位 mV）</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">-- 构造 JSON 格式的 payload 数据</span></span><br><span class="line">    <span class="keyword">local</span> device_data = json.encode(&#123;</span><br><span class="line">        imei = imei,</span><br><span class="line">        csq = csq,</span><br><span class="line">        voltage = voltage,</span><br><span class="line">        timestamp = <span class="built_in">os</span>.<span class="built_in">time</span>()</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="built_in">log</span>.info(<span class="string">&quot;mqtt&quot;</span>, <span class="string">&quot;publish data&quot;</span>, device_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 发布数据到 topic（发布一次）</span></span><br><span class="line">    mqtt_client:publish(pub_topic, device_data, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 可选：配置一个上网指示灯亮起</span></span><br><span class="line">   gpio.set(<span class="number">11</span>, <span class="number">1</span>)  <span class="comment">-- 设置 GPIO11 为高电平，表示联网成功</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一些Lua语言的细节：   </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- _G -&gt; GLOBAL VALUE</span></span><br><span class="line"><span class="built_in">_G</span>.sys = <span class="built_in">require</span>(<span class="string">&quot;sys&quot;</span>)</span><br><span class="line"><span class="built_in">_G</span>.sysplus = <span class="built_in">require</span>(<span class="string">&quot;sysplus&quot;</span>)</span><br><span class="line"><span class="built_in">_G</span>.mobile = <span class="built_in">require</span>(<span class="string">&quot;mobile&quot;</span>)</span><br><span class="line"><span class="built_in">_G</span>.uart = <span class="built_in">require</span>(<span class="string">&quot;uart&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- uart init</span></span><br><span class="line">uart.setup(</span><br><span class="line">    uart_id,</span><br><span class="line">    uart_baud,</span><br><span class="line">    uart_bitwidth,</span><br><span class="line">    uart_stopbit</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- system inner tasks</span></span><br><span class="line">sys.taskInit(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> device_id = mobile.imei() <span class="comment">-- read AIR780EG&#x27;s IMEI</span></span><br><span class="line">    <span class="comment">-- waiting for 4G connected</span></span><br><span class="line">    sys.waitUntil(<span class="string">&quot;IP_READY&quot;</span>)</span><br><span class="line"><span class="comment">-- system publish event</span></span><br><span class="line">    sys.publish(<span class="string">&quot;net_ready&quot;</span>, device_id)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是一个完整的脚本，具体的内容如下：   </p><ol><li>任务一：实现联网功能并在联网后发布事件；   </li><li>任务二：等待联网事件，并根据IMEI设置client-id以及发布、订阅主题；之后根据配置创建mqtt连接并尝试连接；在mqtt回调函数中，如果连接上了则通过串口向单片机发送信息，并发布mqtt连接事件；   </li><li>任务三：等待mqtt连接事件，之后开始接收单片传入的数据并且定位数据位置，将数据打包并通过mqtt上传云端；</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">PROJECT = <span class="string">&quot;AIR780EG_DEMO&quot;</span></span><br><span class="line">VERSION = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Setup instance</span></span><br><span class="line"><span class="built_in">_G</span>.sys = <span class="built_in">require</span>(<span class="string">&quot;sys&quot;</span>)</span><br><span class="line"><span class="built_in">_G</span>.sysplus = <span class="built_in">require</span>(<span class="string">&quot;sysplus&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> wdt = <span class="built_in">require</span>(<span class="string">&quot;wdt&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> <span class="built_in">log</span> = <span class="built_in">require</span>(<span class="string">&quot;log&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> uart = <span class="built_in">require</span>(<span class="string">&quot;uart&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> mobile = <span class="built_in">require</span>(<span class="string">&quot;mobile&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> mqtt = <span class="built_in">require</span>(<span class="string">&quot;mqtt&quot;</span>)    <span class="comment">-- 加载 mqtt 模块</span></span><br><span class="line"><span class="keyword">local</span> rtos = <span class="built_in">require</span>(<span class="string">&quot;rtos&quot;</span>)    <span class="comment">-- 加载 rtos 模块（用于识别平台）</span></span><br><span class="line"><span class="keyword">local</span> pm = <span class="built_in">require</span>(<span class="string">&quot;pm&quot;</span>)        <span class="comment">-- 加载电源管理模块（用于电源配置）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> wdt <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--添加硬狗防止程序卡死，在支持的设备上启用这个功能</span></span><br><span class="line">    wdt.init(<span class="number">9000</span>)<span class="comment">--初始化watchdog设置为9s</span></span><br><span class="line">    sys.timerLoopStart(wdt.feed, <span class="number">3000</span>)<span class="comment">--3s喂一次狗</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- uart configuration</span></span><br><span class="line"><span class="keyword">local</span> uart_id = <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> uart_baud = <span class="number">115200</span></span><br><span class="line"><span class="keyword">local</span> uart_bitwidth = <span class="number">8</span></span><br><span class="line"><span class="keyword">local</span> uart_stopbit = <span class="number">1</span></span><br><span class="line">uart.Setup(uart_id, uart_baud, uart_bitwidth, uart_stopbit)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- server configuration</span></span><br><span class="line"><span class="keyword">local</span> mqtt_host = <span class="string">&quot;lbsmqtt.airm2m.com&quot;</span></span><br><span class="line"><span class="keyword">local</span> mqtt_port = <span class="number">1884</span></span><br><span class="line"><span class="keyword">local</span> mqtt_isssl = <span class="literal">false</span></span><br><span class="line"><span class="keyword">local</span> ca_file = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- mqtt client configuration</span></span><br><span class="line"><span class="keyword">local</span> client_id = <span class="string">&quot;air780eg&quot;</span></span><br><span class="line"><span class="keyword">local</span> user_name = <span class="string">&quot;user&quot;</span></span><br><span class="line"><span class="keyword">local</span> password = <span class="string">&quot;password&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> mqttc = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">local</span> publish_topic = <span class="string">&quot;/air780eg/publish/123&quot;</span></span><br><span class="line"><span class="keyword">local</span> subscribe_topic = <span class="string">&quot;/air780eg/subscribe/123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> IsFirstConnect = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Task list</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Air780E的AT固件默认会为开机键防抖, 导致部分用户刷机很麻烦</span></span><br><span class="line"><span class="keyword">if</span> rtos.bsp() == <span class="string">&quot;EC618&quot;</span> <span class="keyword">and</span> pm <span class="keyword">and</span> pm.PWK_MODE <span class="keyword">then</span></span><br><span class="line">    pm.power(pm.PWK_MODE, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- network connect</span></span><br><span class="line">sys.taskInit(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> device_IMEI = mobile.imei()   <span class="comment">-- string </span></span><br><span class="line">    sys.waitUntil(<span class="string">&quot;IP_READY&quot;</span>)</span><br><span class="line">    sys.publish(<span class="string">&quot;net_ready&quot;</span>, device_IMEI)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mqtt connect</span></span><br><span class="line">sys.taskInit(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> ret, IMEI = sys.waitUntil(<span class="string">&quot;net_ready&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> ret <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- use IMEI to set unique topic</span></span><br><span class="line">        client_id = IMEI</span><br><span class="line">        publish_topic = client_id .. <span class="string">&quot;/publish&quot;</span></span><br><span class="line">        subscribe_topic = client_id .. <span class="string">&quot;/subscribe&quot;</span></span><br><span class="line">        <span class="keyword">if</span> IsFirstConnect <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- uart transmit logger to MCU</span></span><br><span class="line">            uart.<span class="built_in">write</span>(uart_id, <span class="string">&quot;IMEI: &quot;</span> .. IMEI .. <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">            uart.<span class="built_in">write</span>(uart_id, <span class="string">&quot;publish_topic:&quot;</span> .. publish_topic .. <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">            uart.<span class="built_in">write</span>(uart_id, <span class="string">&quot;subscribe_topic:&quot;</span> .. subscribe_topic .. <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">            IsFirstConnect = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- create mqtt client</span></span><br><span class="line">    mqttc = mqtt.<span class="built_in">create</span>(mqtt_host, mqtt_port, mqtt_isssl, ca_file)</span><br><span class="line">    mqttc:auth(client_id, user_name, password)  <span class="comment">-- set mqtt user-name and password(should be equal to the server setting)</span></span><br><span class="line">    mqttc:autoreconn(<span class="literal">true</span>, <span class="number">3000</span>)                <span class="comment">-- set auto-reconnect</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- define callback function</span></span><br><span class="line">    mqttc:on(<span class="function"><span class="keyword">function</span><span class="params">(mqtt_client, event, data, payload)</span></span></span><br><span class="line">        <span class="keyword">if</span> event == <span class="string">&quot;conack&quot;</span> <span class="keyword">then</span></span><br><span class="line">            uart.<span class="built_in">write</span>(uart_id, <span class="string">&quot;MQTT Connect\r\n&quot;</span>)</span><br><span class="line">            sys.publish(<span class="string">&quot;mqtt_ready&quot;</span>)</span><br><span class="line">        <span class="keyword">elseif</span> event == <span class="string">&quot;recv&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">&quot;mqtt&quot;</span>, <span class="string">&quot;收到消息&quot;</span>, data, payload)</span><br><span class="line">        <span class="keyword">elseif</span> event == <span class="string">&quot;sent&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">&quot;mqtt&quot;</span>, <span class="string">&quot;发送成功&quot;</span>, data)</span><br><span class="line">        <span class="keyword">elseif</span> event == <span class="string">&quot;disconnect&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">log</span>.warn(<span class="string">&quot;mqtt&quot;</span>, <span class="string">&quot;断开连接&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- start to conneect server</span></span><br><span class="line">    mqttc:connect()</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- UART 数据接收 + MQTT 上传</span></span><br><span class="line">sys.taskInit(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    sys.waitUntil(<span class="string">&quot;mqtt_ready&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">log</span>.info(<span class="string">&quot;uart&quot;</span>, <span class="string">&quot;开始监听 UART 数据上传&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> buffer = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- uart接收触发中断 从id端口接收len长度的数据</span></span><br><span class="line">    uart.on(uart_id, <span class="string">&quot;receive&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">(id, len)</span></span></span><br><span class="line">        <span class="keyword">local</span> data = uart.<span class="built_in">read</span>(id, <span class="built_in">len</span>)</span><br><span class="line">        buffer = buffer .. data</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 示例：以换行符作为一条完整数据的结束</span></span><br><span class="line">        <span class="keyword">while</span> buffer:<span class="built_in">find</span>(<span class="string">&quot;\r\n&quot;</span>) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">local</span> packet, remain = buffer:<span class="built_in">match</span>(<span class="string">&quot;^(.-)\r\n(.*)$&quot;</span>)</span><br><span class="line">            buffer = remain <span class="keyword">or</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">-- 打印接收到的串口数据</span></span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">&quot;uart&quot;</span>, <span class="string">&quot;收到数据&quot;</span>, packet)</span><br><span class="line">            uart.<span class="built_in">write</span>(uart_id, <span class="string">&quot;Receive Finish!\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">-- 发布到 MQTT（QoS=0）</span></span><br><span class="line">            <span class="keyword">if</span> mqttc <span class="keyword">then</span></span><br><span class="line">                mqttc:publish(publish_topic, packet, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    说明：</span></span><br><span class="line"><span class="comment">    1. 该代码示例展示了如何使用 UART 接收数据并通过 MQTT 上传。</span></span><br><span class="line"><span class="comment">    2. 使用了 sysplus 库来处理系统任务和事件。</span></span><br><span class="line"><span class="comment">    3. 使用了 mqtt 库来处理 MQTT 客户端的连接和消息发送。</span></span><br><span class="line"><span class="comment">    4. 使用了 log 库来记录日志信息。</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line">sys.run()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Communication </category>
          
          <category> LuatOS learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQTT </tag>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3D建模下的参数估计</title>
      <link href="/2025/05/20/research/3D_Positioning_estimation/"/>
      <url>/2025/05/20/research/3D_Positioning_estimation/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在信号处理领域，参数估计是实现目标识别与定位的核心技术之一。经典论文《ESPRIT: Estimation of Signal Parameters via Rotational Invariance Techniques》提出了基于旋转不变性的超分辨率参数估计算法，而《Multiple Emitter Location and Signal Parameter Estimation》则进一步拓展了多信号源定位的理论框架。本文结合原始思想与最新改进算法，探讨3D建模下的参数估计方法。</p><hr><h2 id="ESPRIT算法核心思想"><a href="#ESPRIT算法核心思想" class="headerlink" title="ESPRIT算法核心思想"></a>ESPRIT算法核心思想</h2><h3 id="旋转不变性原理"><a href="#旋转不变性原理" class="headerlink" title="旋转不变性原理"></a>旋转不变性原理</h3><p>ESPRIT算法的核心在于利用信号子空间的旋转不变性[[4]]。通过构建两个存在位移关系的传感器阵列，其接收信号满足：<br>$$<br>\mathbf{X}_2 &#x3D; \mathbf{X}_1 \mathbf{\Phi}<br>$$<br>其中 $\mathbf{\Phi}$ 为包含信号到达角（DOA）信息的对角矩阵。通过对信号子空间进行奇异值分解（SVD），可直接从矩阵 $\mathbf{\Phi}$ 中提取信号参数[[4]]。</p><h3 id="子空间分解"><a href="#子空间分解" class="headerlink" title="子空间分解"></a>子空间分解</h3><p>原始ESPRIT通过以下步骤实现参数估计：</p><ol><li>构造阵列协方差矩阵并进行特征值分解；</li><li>分离信号子空间与噪声子空间；</li><li>利用子阵列间的平移关系求解旋转矩阵 $\mathbf{\Psi}$；</li><li>通过特征分解获得信号的波达方向（DOA）[[4]]。</li></ol><hr><h2 id="MUSIC算法核心思想"><a href="#MUSIC算法核心思想" class="headerlink" title="MUSIC算法核心思想"></a>MUSIC算法核心思想</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ol><li><p><strong>信号子空间与噪声子空间分离</strong><br>论文提出利用协方差矩阵特征值分解，将信号空间划分为信号子空间（由大特征值对应特征向量张成）和噪声子空间（由小特征值对应特征向量张成）。两者正交的特性成为参数估计的关键 [[2]][[9]]。</p></li><li><p><strong>空间谱搜索</strong><br>通过构建如下MUSIC谱函数实现信号源定位：<br>$$<br>P_{\text{MUSIC}}(\theta) &#x3D; \frac{1}{\mathbf{a}(\theta)^H \mathbf{E}_n \mathbf{E}_n^H \mathbf{a}(\theta)}<br>$$<br>其中 $\mathbf{E}_n$ 为噪声子空间，$\mathbf{a}(\theta)$ 为阵列流形向量。当 $\theta$ 扫描到真实信号方向时，分母趋近于零，谱峰位置即对应信号源方向 [[3]][[9]]。</p></li></ol><hr><h2 id="扩展到三维空间下的估计"><a href="#扩展到三维空间下的估计" class="headerlink" title="扩展到三维空间下的估计"></a>扩展到三维空间下的估计</h2><p>随着5G通感一体化和智能感知的发展，实际应用中对三维空间（方位角、俯仰角、距离等）参数的高精度估计提出了更高要求。传统MUSIC和ESPRIT算法主要针对二维（如仅估计方位角），而三维场景下需要对信号的多个空间参数进行联合估计。</p><h3 id="三维ESPRIT算法"><a href="#三维ESPRIT算法" class="headerlink" title="三维ESPRIT算法"></a>三维ESPRIT算法</h3><p>三维ESPRIT算法需要平面或者立体的天线阵列流形，这里我们以平面阵列流形为例，且相邻的天线之间的间距相等，即均匀平面天线（UPA）；</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250520101247882.png" alt="UPA"></p><p>通过将信号的波达角分解为水平的方位角以及垂直的俯仰角，可以将信号到达不同天线的路程差通过天线间距$d$、方位角$\phi$以及俯仰角$\theta$联合表示：</p><p>$$<br>\Delta \lambda_{m,n} &#x3D; d \left[ (m-1)\sin\theta\cos\phi + (n-1)\sin\theta\sin\phi \right]<br>$$</p><p>由于天线之间的间隔以及波达角导致的信号到达天线阵列所经历的时间不同，意味着信号到达不同天线的相位也不一样。由于是均匀分布的天线，我们可以推测，相邻天线之间的相位差是一个定值，因此可以通过选择天线对，然后由ESPRIT的算法得到旋转不变性，从而计算得到两个参数：$\sin\theta\cos\phi$ 以及 $\sin\theta\sin\phi$，之后便可以轻松的计算出我们需要的方位角$\phi$以及俯仰角$\theta$。</p><h3 id="三维ESPRIT算法的难点"><a href="#三维ESPRIT算法的难点" class="headerlink" title="三维ESPRIT算法的难点"></a>三维ESPRIT算法的难点</h3><p>这里的难点在于，对接收到的信号做信道估计以及信道补偿一系列操作后得到的信道响应是所有天线阵列接收信道的叠加，从信道响应的形状上来说已经没有了天线阵列的形状信息，<strong>如何将信道响应$H$重新塑形</strong>则是一大难题。</p><p>对于如何获得信道响应，从感知的角度而言，将不同参数对应的导向矢量做克罗内克积便得到了信道响应：</p><p>$$<br>H &#x3D; a_{aoa} \otimes a_{zoa}<br>$$</p><p>这里的$\otimes$代表克罗内克积（kronecker product），$a_{x}$表示为某个参数的导向矢量。这里得到的是理想信道响应，可以添加加性高斯白噪声以模仿实际的信道响应。</p><h3 id="三维ESPRIT算法的具体实现"><a href="#三维ESPRIT算法的具体实现" class="headerlink" title="三维ESPRIT算法的具体实现"></a>三维ESPRIT算法的具体实现</h3><p>联合导向矢量的定义可以用x方向天线的导向矢量与y方向天线的导向矢量做克罗内克积得到</p><p>$$ A &#x3D; A_{x} \otimes A_{y} $$</p><p>也可以通过直接的定义得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建二维阵列响应</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">steering_vector_2d</span>(<span class="params">az_deg, el_deg</span>):</span><br><span class="line">    <span class="comment">#^ 角度值转弧度制</span></span><br><span class="line">    az = np.radians(az_deg) <span class="comment"># 方位角</span></span><br><span class="line">    el = np.radians(el_deg) <span class="comment"># 俯仰角</span></span><br><span class="line">    kx = np.sin(el) * np.cos(az)</span><br><span class="line">    ky = np.sin(el) * np.sin(az)</span><br><span class="line">    a = np.zeros((Mx, My), dtype=<span class="built_in">complex</span>)</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(Mx):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(My):</span><br><span class="line">            a[m, n] = np.exp(-<span class="number">1j</span> * <span class="number">2</span> * np.pi * (dx * m * kx + dy * n * ky) / wavelength)</span><br><span class="line">    <span class="keyword">return</span> a.flatten()</span><br></pre></td></tr></table></figure><p>接收信号矩阵可以具体表现为</p><p>$$ X &#x3D; AS + N $$</p><p>其中的$A_{M, K}$为接收矩阵的阵列响应，$S_{K, snapshots}$为$N$个信号源在接收天线的采样值，$N_{M, snapshots}$为噪声。</p><p>对接收信号直接做SVD，可以得到接收信号的协方差矩阵以及信号子空间和噪声子空间的基</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 协方差矩阵估计与SVD分解</span></span><br><span class="line">R = X @ X.conj().T / snapshots  <span class="comment">#^ [M, M]的协方差矩阵</span></span><br><span class="line">U, _, _ = svd(R)</span><br><span class="line">Us = U[:, :K]                   <span class="comment">#^ [M, K]的信号子空间矩阵</span></span><br></pre></td></tr></table></figure><p>其中特征向量的选择取决于信号源的个数，且形状为<strong>天线数X信号源数</strong>,对每一个特征向量进行重新塑形，具体思想为选择前$row - 1$天线阵元的响应和后$row - 1$天线阵元的响应，通过ESPRIT算法可以得到相位偏差，对应于x轴方向天线阵元之间的相位偏移$\sin\theta\cos\phi$。同理选择前$col - 1$天线阵元的响应和后$col - 1$天线阵元的响应可以计算出y轴方向天线阵元之间的相位偏移$\sin\theta\sin\phi$，从而得到波达角。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造移位子阵列索引</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shift_indices</span>(<span class="params">dim_x, dim_y, axis</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    函数作用: 先构建一个dim_x * dim_y的二维矩阵 索引从(0, 0)到(dim_x-1, dim_y-1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    如果传入axis=0 则将行进行删除操作 然后按照行的顺序 顺次存取为一个一维的index 如0、1、2、...或者6、7、8、...</span></span><br><span class="line"><span class="string">    如果传入axis=1 则将列进行删除操作 然后按照行的顺序 顺次存取为一个一维的index 如0、1、2、3、4、6、...或者1、2、3、4、5、7、...</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> axis == <span class="number">0</span>:  <span class="comment"># x 方向（垂直方向）移位</span></span><br><span class="line">        rows = np.arange(dim_x - <span class="number">1</span>)</span><br><span class="line">        idx1 = np.ravel_multi_index(np.meshgrid(rows, np.arange(dim_y), indexing=<span class="string">&#x27;ij&#x27;</span>), (dim_x, dim_y))</span><br><span class="line">        idx2 = np.ravel_multi_index(np.meshgrid(rows + <span class="number">1</span>, np.arange(dim_y), indexing=<span class="string">&#x27;ij&#x27;</span>), (dim_x, dim_y))</span><br><span class="line">    <span class="keyword">elif</span> axis == <span class="number">1</span>:  <span class="comment"># y 方向（水平方向）移位</span></span><br><span class="line">        cols = np.arange(dim_y - <span class="number">1</span>)</span><br><span class="line">        idx1 = np.ravel_multi_index(np.meshgrid(np.arange(dim_x), cols, indexing=<span class="string">&#x27;ij&#x27;</span>), (dim_x, dim_y))</span><br><span class="line">        idx2 = np.ravel_multi_index(np.meshgrid(np.arange(dim_x), cols + <span class="number">1</span>, indexing=<span class="string">&#x27;ij&#x27;</span>), (dim_x, dim_y))</span><br><span class="line">    <span class="keyword">return</span> idx1.flatten(), idx2.flatten()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取两个方向的子阵列</span></span><br><span class="line">Ux1_idx, Ux2_idx = shift_indices(Mx, My, axis=<span class="number">0</span>)</span><br><span class="line">Uy1_idx, Uy2_idx = shift_indices(Mx, My, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Ux1 = Us[Ux1_idx, :]</span><br><span class="line">Ux2 = Us[Ux2_idx, :]</span><br><span class="line">Uy1 = Us[Uy1_idx, :]</span><br><span class="line">Uy2 = Us[Uy2_idx, :]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别计算x方向和y方向的Psi矩阵</span></span><br><span class="line">Psi_x = pinv(Ux1) @ Ux2</span><br><span class="line">Psi_y = pinv(Uy1) @ Uy2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解特征值并估计方向余弦</span></span><br><span class="line">eigvals_x, _ = eig(Psi_x)</span><br><span class="line">eigvals_y, _ = eig(Psi_y)</span><br><span class="line"></span><br><span class="line">angles_x = np.angle(eigvals_x)</span><br><span class="line">angles_y = np.angle(eigvals_y)</span><br><span class="line"></span><br><span class="line">kx_est = angles_x * wavelength / (<span class="number">2</span> * np.pi * dx)</span><br><span class="line">ky_est = angles_y * wavelength / (<span class="number">2</span> * np.pi * dy)</span><br></pre></td></tr></table></figure><p>代码中定义的函数<code>shift_indices</code>中根据接收天线的形状定义每根天线的索引，x方向和y方向上分别取子阵列的阵元索引，具体可以看函数的解析。再通过索引选取特征向量中的元素，通过ESPRIT的算法便可以得到不同方向上天线阵元之间的信号相位差，再由相位差便可以轻松的得到波达角。</p><h3 id="三维MUSIC算法"><a href="#三维MUSIC算法" class="headerlink" title="三维MUSIC算法"></a>三维MUSIC算法</h3><p>三维MUSIC算法通常基于三维阵列（如平面阵列或立体阵列），其核心思想与二维类似，但需要构造三维空间的阵列流形向量 $\mathbf{a}(\theta, \phi, r)$，并在三维参数空间内进行谱峰搜索：</p><p>$$<br>P_{\text{MUSIC}}(\theta, \phi, r) &#x3D; \frac{1}{\mathbf{a}(\theta, \phi, r)^H \mathbf{E}_n \mathbf{E}_n^H \mathbf{a}(\theta, \phi, r)}<br>$$</p><p>其中，$\theta$ 为方位角，$\phi$ 为俯仰角，$r$ 可为距离或极化等参数。通过在三维参数空间内搜索谱峰，实现对信号源空间位置的精确估计。该方法分辨率高，但计算量大，常需结合降维或并行计算优化。</p><h3 id="互素阵列流形——降维MUSIC算法"><a href="#互素阵列流形——降维MUSIC算法" class="headerlink" title="互素阵列流形——降维MUSIC算法"></a>互素阵列流形——降维MUSIC算法</h3><p>均匀平面阵列(Uniform Planar Array, UPA)  是一种经典模型,其相邻阵元间距均为半波长,该  模型在3维信源定位时精度较高,但在阵列口径较  大时,较高的结构复杂度限制了该模型的应用。为  了实现低复杂度的3维信源精确定位,本文提出  CLACS-SPA结构,其主要特征是将一列互素线阵  (Coprime Linear Array, CLA)沿着与之垂直的方  向按照相同的互素规律进行平移而得到 [[5]]。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250520134601234.png" alt="互素面阵"></p><p>图中左图$ULA1$为间隔为$a$的均匀线阵，$ULA2$为间隔为$b$的均匀线阵，将两个线阵拼接在一起且间隔互为素数则得到了互素线阵；有图中将这样的互素线阵在垂直的方向上拼接就得到了互素面阵。</p><p>对于这样的互素面阵，信源到不同天线之间相位差可以如下面这样表示：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250520135243124.png" alt="相位差计算"></p><p>分别从x轴方向和y轴方向计算相邻两个天线之间的信源波程差可以得到</p><p>$$<br>\begin{align}<br>\Delta_{x,k} &amp;&#x3D; \sqrt{r^2 + l_{x,k}^2 - 2l_{x,k}r \sin\varphi \cos\theta} - r \tag{2} \<br>\Delta_{y,k} &amp;&#x3D; \sqrt{r^2 + l_{y,k}^2 - 2l_{y,k}r \sin\varphi \sin\theta} - r \tag{3}<br>\end{align}<br>$$</p><p>有前面我们可以清楚的知道，波程差一定程度上等价于相位差，而波程差又取决于波达角以及距离（飞行时间）。所以，相位差是由三维参数共同决定的，这也就是说通过MUSIC算法遍历三维空间计算量十分庞大，那么有没有什么办法减少计算呢？</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250520140147302.png" alt="泰勒展开降维"></p><p>上述式子展示了将x或者y方向的波程差通过泰勒公式展开，对高阶项直接舍去便得到了<br>$\gamma_x &#x3D; -\frac{2\pi \sin\varphi \cos\theta}{\lambda}, \quad<br>\phi_x &#x3D; \pi \left(1 - \frac{\sin^2\varphi \cos^2\theta}{\lambda r}\right); \quad$</p><p>其中的$\gamma_x$只跟波达角有关，在求出波达角后$\phi_x$就只跟距离有关，如此便将一个三维的搜索转换为二维的搜索<strong>加上</strong>一维的搜索，大大降低了计算复杂度。</p><h3 id="互素阵列流形MUSIC算法具体实现"><a href="#互素阵列流形MUSIC算法具体实现" class="headerlink" title="互素阵列流形MUSIC算法具体实现"></a>互素阵列流形MUSIC算法具体实现</h3><p>首先是根据泰勒展开后的第一项构建搜索导向矢量$\hat{A}_{x}$，在一定的角度范围内遍历$\theta, \phi$并计算谱值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 泰勒近似方向导向项构造函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xi</span>(<span class="params">l, gamma</span>):</span><br><span class="line">    <span class="keyword">return</span> np.exp(<span class="number">1j</span> * gamma * l)</span><br><span class="line"></span><br><span class="line"><span class="comment">#^ 第一阶段：二维角度搜索 泰勒展开后的零次项作为预测的导向矢量估计ZOA、AOA</span></span><br><span class="line"><span class="keyword">for</span> i, phi <span class="keyword">in</span> <span class="built_in">enumerate</span>(phi_scan):</span><br><span class="line">    <span class="keyword">for</span> j, theta <span class="keyword">in</span> <span class="built_in">enumerate</span>(theta_scan):</span><br><span class="line">        <span class="comment">#^ 泰勒展开的零次项</span></span><br><span class="line">        gamma_x = -k * np.sin(phi) * np.cos(theta)</span><br><span class="line">        gamma_y = -k * np.sin(phi) * np.sin(theta)</span><br><span class="line">        </span><br><span class="line">        xi_x = xi(Lx, gamma_x)  <span class="comment">#^ [9, 1] 横向的天线响应</span></span><br><span class="line">        xi_y = xi(Ly, gamma_y)  <span class="comment">#^ [9, 1] 纵向的天线响应</span></span><br><span class="line">        xi_xy = np.kron(xi_x, xi_y).reshape(-<span class="number">1</span>, <span class="number">1</span>)          <span class="comment">#^ [81, 1] 降维后x方向的导向搜索矢量</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#^ 遍历角度 构建导向矢量 计算与噪声子空间的距离 </span></span><br><span class="line">        psi = xi_xy.conj().T @ Un @ Un.conj().T @ xi_xy     </span><br><span class="line">        Pmap[i, j] = <span class="number">1</span> / np.real(psi)                       <span class="comment">#^ 计算谱值 1/psi 最大值为波达角</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>找到最大的谱值对应的波达角，将波达角带入到第二项中，就变成了距离$r$的单一求解，构建搜索导向矢量并在给定的范围内搜索谱值的最大值，具体如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">upsilon</span>(<span class="params">l, phi_term</span>):</span><br><span class="line">    <span class="keyword">return</span> np.exp(<span class="number">1j</span> * phi_term * l**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#^ 泰勒展开的一次项 带入估计的波达角</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> r_scan:</span><br><span class="line">    phi_x = np.pi / (lam * r) * (<span class="number">1</span> - np.sin(phi_est)**<span class="number">2</span> * np.cos(theta_est)**<span class="number">2</span>)</span><br><span class="line">    phi_y = np.pi / (lam * r) * (<span class="number">1</span> - np.sin(phi_est)**<span class="number">2</span> * np.sin(theta_est)**<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    upsilon_x = upsilon(Lx, phi_x)</span><br><span class="line">    upsilon_y = upsilon(Ly, phi_y)</span><br><span class="line">    upsilon_xy = np.kron(upsilon_x, upsilon_y).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 需要带上零次项进行估计</span></span><br><span class="line">    xi_x = xi(Lx, -<span class="number">2</span> * np.pi / lam * np.sin(phi_est) * np.cos(theta_est))</span><br><span class="line">    xi_y = xi(Ly, -<span class="number">2</span> * np.pi / lam * np.sin(phi_est) * np.sin(theta_est))</span><br><span class="line">    xi_xy = np.kron(xi_x, xi_y).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指数相乘等于相位相加 对应泰勒展开的项</span></span><br><span class="line">    A_est = xi_xy * upsilon_xy</span><br><span class="line">    pseudospectrum = <span class="number">1</span> / np.real((A_est.conj().T @ Un @ Un.conj().T @ A_est))</span><br><span class="line">    P_r.append(pseudospectrum[<span class="number">0</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>最后便可以在保持高精度的前提下简化计算复杂度提高速度</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250520144154490.png" alt="参数估计"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从最初的经典ESPRIT和MUSIC算法，到近年来面向三维建模和5G通感一体化的多维参数估计算法，参数估计技术正不断向高精度、高分辨率和强鲁棒性方向演进。随着阵列结构的创新（如互素阵、稀疏阵列）和信号处理手段的提升（如空间平滑、极化信息融合、降维搜索等），改进算法不仅在低信噪比、强干扰等复杂环境下展现出更优的性能，还显著降低了计算复杂度，提升了实时性和工程可用性。这些进步为5G通感一体化、智能感知、无人系统等前沿应用提供了坚实的技术基础和广阔的发展空间[[1]][[2]][[4]]。</p><blockquote><p>参考资料：<br>[[1]] 基于改进3D-ESPRIT的GTD模型参数估计<br>[[2]] 三维GTD模型参数估计的改进算法<br>[[3]] CN111781573A 专利文档<br>[[4]] TLS-ESPRIT改进空间平滑算法<br>[[5]] 基于稀疏面阵的低复杂度三维信源定位算法</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> 通感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于5G通信的定位感知——AOA解算</title>
      <link href="/2025/04/24/research/AOA_Positioning/"/>
      <url>/2025/04/24/research/AOA_Positioning/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><em><strong>5G-NR</strong></em>，具有⾼速、低延迟的特性，是现代通信强有⼒的技术之一。又因广泛的基站建设，5G逐渐覆盖日常生活中的每个角落，随着覆盖范围的扩张，不仅意味着越来越稳定的通信，感知，更是随之不断的发展。</p><p>下⾯，本文将针对无人机向5G基站通信这一应用场景，尝试通过仿真验证利用无人机与5G基站的通信能够实现利用 <em><strong>CSI</strong></em> 解算出无人机的位置信息，如 <em><strong>AOA、AOD、ToF</strong></em> 等参数，验证 <em><strong>MUSIC</strong></em> 算法的可行性。下面是对如何通过通信的 <em><strong>CSI</strong></em> 实现对位置信息感知的理论描述。</p><h1 id="理论篇"><a href="#理论篇" class="headerlink" title="理论篇"></a>理论篇</h1><h2 id="信号在发送端天线的传播特性"><a href="#信号在发送端天线的传播特性" class="headerlink" title="信号在发送端天线的传播特性"></a>信号在发送端天线的传播特性</h2><p>发送端（无人机）仅考虑单根天线进行收发，且天线是全向极化天线。信号由无人机发出，向四面八方发送信号，这些信号在Tx天线处发出时对应的角度我们称为 <em><strong>AOD（Angle of Departure）</strong></em>。在 <em><strong>Tx</strong></em> 处的AOD有很多不同的值，我们近似认为范围为 <em><strong>[0, 2*pi]</strong></em>。</p><p><img src="https://raw.github.com/allforkarina/embadded_image/refs/heads/master/20250425123140384.png" alt="无人机发送天线"></p><p>由于发送端 —&gt; 接收端的距离很远，信号在信道中传输之后在到达5G基站的天线阵列时，我们近似认为这些信号可以被视为平⾏波。</p><h2 id="接收端天线阵列接收信号"><a href="#接收端天线阵列接收信号" class="headerlink" title="接收端天线阵列接收信号"></a>接收端天线阵列接收信号</h2><p>由于信号在信道中传递有多径特性，其中某⼀个单径上的信号在到达天线阵列时可以被视为⼀组平⾏波。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250425123346494.png" alt="接收天线阵列"></p><p>下面我们仅考虑某一个单径上的信号，这个信号以一组平行波的形式被接收端的天线阵列接收。作⼀条垂直于平⾏波的虚线，我们可以近似认为它与这一组平⾏波的交点所对应的信号相位相同，即这个虚线是一个等相线。由上图可⻅相邻两根天线之间信号传播距离相差 <em><strong>L</strong></em>，又因为波⻓与相应间存在某种关系，我们可以理解为，传播的距离差 <em><strong>L</strong></em> 等价于信号到达天线的相位差 <em><strong>φ</strong></em>。因此可以说,相邻两概天线在同时接收到的信号之间差⼀个恒定的 <em><strong>φ</strong></em> 。以另⼀个⻆度上说，同时接收 <em><strong>N</strong></em> 个天线上的信号且相邻信号之间差⼀个 <em><strong>φ</strong></em>，那么我们可以压缩天线，我只对第⼀根天线接收的信号采样，采样间隔 <em><strong>t &#x3D; L&#x2F;c &#x3D; φ&#x2F;f</strong></em> （ <em><strong>c</strong></em> 是光速，<em><strong>f</strong></em> 是信号的频率）。</p><p>以第⼀根天线接收的信号为基准定义为 <em><strong>S0 &#x3D; exp(j*2*pi*d*cosx)</strong></em>,如此其余天线接收的信号就能够定义为 <em><strong>Sk &#x3D; exp(j*2*pi*k*d*cosx) &#x3D; （exp(j*2*pi*d*cosx)）^k</strong></em> 等等，第k根天线的信号是第一根天线的k次方，又因为第k根天线相较于第一根天线有 <em><strong>k * d</strong></em> 的距离差，表现在信号上有k次方的关系，于是我们认为，第k根天线相较于第一根天线有 <em><strong>φ^k</strong></em> 的相位延迟。若我们定义第一根天线没有延迟，那么我们就可以写出第一条单径对应信号的导向矢量</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250425123744616.png" alt="导向矢量"></p><p>又因为多径，不同AOA的信号同时到达接收天线阵列，彼此叠加。所以我们在天线处采样得到的信号，是K个不同AOA路径信号的叠加。我们多次进行采样，一共采样 <em><strong>M</strong></em> 次就可以得到 <em><strong>MxN</strong></em> 的导向矩阵。</p><p>又因为每个列向量（导向矢量）的元素之间是成指数递增的关系，因此根据矩阵论的相关知识，该导向矩阵是满秩的。</p><h2 id="AOA解算"><a href="#AOA解算" class="headerlink" title="AOA解算"></a>AOA解算</h2><p>这里我们假设一共有一根 <em><strong>Tx</strong></em> ，3根 <em><strong>Rx</strong></em>，这里我们考虑两条多径（一条直射、一条反射）。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250425123355885.png" alt="多径模型"></p><p>对天线上接收的信号进行采样，每一次采样计算出来的导向矢量是由两条路径对应不同的导向矢量叠加得到。我们多次进行采样，这些采样得到的所有导向矢量构成一个导向矩阵，该导向矩阵一定是满秩的。</p><p>每一个导向矢量，xyz三个坐标，对应在一个三维空间中的一个位置，采样了 <em><strong>m</strong></em> 次，则一共有 <em><strong>m</strong></em> 个三维空间中的矢量，每一个矢量又是由两条路径对应的导向矢量通过平行四边形法则叠加得到。两条路径的导向矢量不同是因为不同路径到达接收天线阵列的AOA不同，因此导向矢量也不同。我们可以假设，如果有无数条路径，这些路径对应的AOA也不同，意味着有无数条不同的导向矢量，这些导向矢量的末端连起来必然是一个封闭的空间曲线（因为AOA有界）。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250425123406300.png" alt="空间封闭曲线"></p><p>已知每一个导向矢量对应一个AOA，导向矢量的模长受到对应信道时变衰落的影响，因此每一个导向矢量是对应方向延长线上的点。由于不同AOA的信号在天线处叠加，采样得到的导向矢量对应在空间中是不同AOA导向矢量的加权（信道衰落）和。</p><p>如果每次采样的信号是由两个多径信号叠加，那么采样信号的导向矢量就是这两个多径信号的导向矢量加权和。又两个向量可以张成一个二维的平面（子空间），我们称这个子空间为 <strong>信号子空间</strong>。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250425123415468.png" alt="信号子空间"></p><p>假设你的信道中没有噪声，那么我们可以推断出，无论采样多少次，每次采样的信号对应的导向矢量一定属于这个信号子空间。<em><strong>n</strong></em> 条路径 <em><strong>m</strong></em> 根接收天线对应的信号子空间维数为 <em><strong>R_min &#x3D; min(n, m)</strong></em>。因为信号子空间的维数一定小于或者等于整个导向矢量的空间维数，因此一定可以找到一个垂直于信号子空间的基，这个基对应的空间我们称为 <strong>噪声子空间</strong>。如果你的信道中有噪声，你的导向矢量在空间中表现为在垂直信号子空间的方向上有一定的偏移</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/20250425123421082.png" alt="正交噪声子空间"></p><h2 id="实际解算过程"><a href="#实际解算过程" class="headerlink" title="实际解算过程"></a>实际解算过程</h2><ol><li><p>同时对 <em><strong>N</strong></em> 个天线阵元采样得第⼀个导向矢量；多次采样得 <em><strong>M</strong></em> 个导向矢量；每一个导向矢量是来自 <em><strong>K</strong></em> 个路径的信号叠加（每个路径的AOA不同）。</p></li><li><p>得到导向矢量矩阵 <em><strong>A &#x3D; [P_1, P_2, …, P_n]</strong></em> ，矩阵的形状为 <em><strong>M x N</strong></em> 且一定是满秩的，信号子空间为维度为天线阵元数量与多径数量中的较小值。假设信号子空间为 <em><strong>K</strong></em> 维，导向矢量的空间维度为 <em><strong>N</strong></em> 维，对导向矢量矩阵做特征值分解，能够得到 <em><strong>N</strong></em> 个特征矢量，其中 <em><strong>K</strong></em> 个构成了信号子空间，也对应着 <em><strong>K</strong></em> 个多径各自的 <em><strong>AOA</strong></em>。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> 通感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读札记——“5G信道的估计与均衡”</title>
      <link href="/2025/04/02/research/Channel-state-info/"/>
      <url>/2025/04/02/research/Channel-state-info/</url>
      
        <content type="html"><![CDATA[<h1 id="5G通信信道估计"><a href="#5G通信信道估计" class="headerlink" title="5G通信信道估计"></a>5G通信信道估计</h1><h2 id="一、MIMO——OFDM技术简介"><a href="#一、MIMO——OFDM技术简介" class="headerlink" title="一、MIMO——OFDM技术简介"></a>一、MIMO——OFDM技术简介</h2><h3 id="MIMO："><a href="#MIMO：" class="headerlink" title="MIMO："></a>MIMO：</h3><p>多输入-多输出，即大规模天线阵列用于发送以及接收。</p><p>用基站端天线数量的扩展代替基站数量的扩展。</p><p>减少基站数量意味着多径效应的削弱，有利于减少小尺度衰减对信号传输的影响。</p><h3 id="OFDM："><a href="#OFDM：" class="headerlink" title="OFDM："></a>OFDM：</h3><p>在传统的频分传输基础上，进一步节省频带资源，实现正交频分调制。</p><h2 id="虽然OFDM各个子载波存在有频谱交叠的部分，但是由于是正交的，接收端仍能够解调信号并且可以高效的利用频谱。"><a href="#虽然OFDM各个子载波存在有频谱交叠的部分，但是由于是正交的，接收端仍能够解调信号并且可以高效的利用频谱。" class="headerlink" title="虽然OFDM各个子载波存在有频谱交叠的部分，但是由于是正交的，接收端仍能够解调信号并且可以高效的利用频谱。"></a>虽然OFDM各个子载波存在有频谱交叠的部分，但是由于是正交的，接收端仍能够解调信号并且可以高效的利用频谱。</h2><p>MIMO在空间域上节省资源；OFDM调制在频域上节省资源。</p><h2 id="二、mMIMO——Massive-MIMO"><a href="#二、mMIMO——Massive-MIMO" class="headerlink" title="二、mMIMO——Massive MIMO"></a>二、mMIMO——Massive MIMO</h2><h3 id="MIMO的信道增益"><a href="#MIMO的信道增益" class="headerlink" title="MIMO的信道增益"></a>MIMO的信道增益</h3><p>多用户大规模MIMO，面向于多个用户接入，单个基站端配备有几十上百跟天线：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image001.png" alt="MIMO and UE"></p><p>每个用户端只有一根天线，基站端配备有多根天线与用户相匹配。其中，第m根天线接收到来自第K个用户的信号Im,K在信道中的增益等于：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image002.png" alt="signal amp"></p><p>大尺度的衰减与小尺度的衰减相乘得到。其中，小尺度的衰减系数受天线的影响最大，可以认为是多个用户导致的用户间串扰（IUI-interUser interference）对于有M根天线阵列的基站来说，每根天线接收到K个用户传来的信号，将这<img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image003.png" alt="Channel Matrix">的信号组成矩阵，对应每个信号的信道增益就构成了信道矩阵。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image005.png" alt="Channel Matrix"></p><p>这也是CSI最终我们要得到的参数（矩阵）。</p><h3 id="MIMO的信道分析"><a href="#MIMO的信道分析" class="headerlink" title="MIMO的信道分析"></a>MIMO的信道分析</h3><p>已知不同信道、不同信号的信道估计增益都不一样，这取决于大尺度衰弱叠加上小尺度干扰；因此为了增强信号的信噪比以及削弱用户间的干扰，我们可以采用最大合并比以及最大比发送实现，具体的思想就是根据CSI估计的信道衰减反馈在接收端或者发送端添加一个增益，以追求所有天线的信噪比之和最大。通常不同天线的增益满足：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image006.png" alt="MRC"></p><p>即增益与信道衰减成正比，与上述的描述相符。</p><p>那么我们如何通过CSI解得的信道矩阵求出最大比合并的权重？我们将矩阵写成列向量矩阵，每一列表示一个用户发出的信号被M根天线接受的信道衰减系数，属于小尺度衰减。我们对信道矩阵取模计算衰减可以得到下面式子：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image007.png" alt="MRC"></p><p>中间的展开式暂时不理解为什么等于这个结果，但是直接考虑到展开之前的部分，由于空间域的复杂性，我们可以假设不同天线的信道之间是互不相关的，由此我们就能知道一个信道的共轭转置乘上另一个信道可以理解求取为两个信道的相关性，因此可以近似于0；式子1的结果是因为当前信道和自己的相关性固然为1.这样我们只需要采用线性的处理方式即最大比合并就可以实现大规模MIMO中多个用户的传播。</p><h3 id="MIMO优缺点"><a href="#MIMO优缺点" class="headerlink" title="MIMO优缺点"></a>MIMO优缺点</h3><p>MIMO实现了在同时、同频进行多用户传播（利用波束空间复用），开发了空间域的资源利用，提高了容量。但是于此同时，随着用户数量大量增加，信道数量根据基站侧的天线数量尺度进行扩张，这也会导致导频资源的紧缺（世间真理，一件事物的宽裕会导致另一件事物的紧缺），导致导频污染。就像原本是一个8x8的象棋格，原本是错开的排列，当用户（列数）增加时，就会出现某一行有两个用户，这也就造成了导频污染。</p><h2 id="OFDM调制"><a href="#OFDM调制" class="headerlink" title="OFDM调制"></a>OFDM调制</h2><h3 id="什么是OFDM调制"><a href="#什么是OFDM调制" class="headerlink" title="什么是OFDM调制"></a>什么是OFDM调制</h3><p>OFDM：正交频分复用，通过多载波调制（加载在不同的频段上）实现对频率选择性衰弱一定的抵抗，同时实现串行信号并行传输，提高速率且尽量节省频带资源。并行传输的优势还在于延长了单个符号的持续时间，假设我需要传输四个符号，每个符号持续0.25ns，那么一共传输1ns；如果我使用OFDM并行传输的话，使用4个子载波进行调制，那么在原来的传输时间1ns内我可以每个符号传输1ns并行传输，这样我单个符号的长度是原来的4倍，通过一些纠错码可以更容易校验符号、纠错，提高系统对ISI的抵抗性。</p><p>OFDM实信号的调制表达式如下：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image008.png" alt="MRC"><br><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image009.png" alt="MRC"></p><p>N为子载波的个数。在接收端由于每个子载波在频域上是相互正交的，可以容易的通过相干解调分离出每一个子载波承载的信号，最后再并串转换就可以得到信道传输后的接收信号。当然实际的调制过程更加复杂，一个可能的框图如下：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image010.png" alt="MRC"></p><h3 id="OFDM的技术特点"><a href="#OFDM的技术特点" class="headerlink" title="OFDM的技术特点"></a>OFDM的技术特点</h3><p>由于信道的不确定性，如多普勒频移导致的非正交性都会对OFDM传递的符号间产生严重的干扰；或者普遍存在的符号间干扰都会导致OFDM的正常传输，因此我们在传输的符号之间插入一段间隔称为保护间隔，通过牺牲一部分资源换取通信的稳定性。</p><p>在插入保护间隔的同时手动引入了时延，再加上多普勒频移导致子载波间不再是严格的正交，子载波信道之间会产生干扰，ICI即信道间干扰。于是添加了循环前缀，补全保护间隔的空缺，是不同信道的符号之间对齐，保持子载波之间的正交性，当然，这样也导致了资源的浪费，但是也能够减少复杂信号处理的开销。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image012.png" alt="MRC"></p><h2 id="信道估计"><a href="#信道估计" class="headerlink" title="信道估计"></a>信道估计</h2><p>信道估计即是通过信道估计算法等数学分析手段研究时变无线信道的信道相关参数，这些参数对于接收端的数据恢复有很重要的作用。信道估计算法大致上可以分为三类，非盲估计、半盲估计和盲估计。这里的“盲”是指发送端的信号是否含有导频，所谓导频是一段接收方和发送方约定好的信号，通过观测导频发生的变化可以解出信道对当前信号的响应。因此我们一般使用非盲估计的方法。</p><h3 id="传统信道估计算法"><a href="#传统信道估计算法" class="headerlink" title="传统信道估计算法"></a>传统信道估计算法</h3><p>接收端的信号是传输信号通过信道的冲激响应后叠加一个加性高斯白噪声的结果，通过算法将接收信号还原接近发送信号，而估计与实际之间的误差就是衡量算法优越性的一个指标：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image013.png" alt="MRC"></p><p>非盲估计是基于导频的信道估计算法，其中比较有代表性的有LS算法。即最小二乘法，其优点是复杂度低，易实现。信道模型如下</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image014.png" alt="MRC"><br><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image015.png" alt="MRC"></p><p>上述数学表达式是信号经过FFT后的频域表达，LS的估计目标是找到一个信道响应能够使HX即估计值与Y实际接收值之间的残差最小，数学表示如下：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image016.png" alt="MRC"></p><p>第一行就是求取两者的残差，矩阵运算也就等于共轭转置×原矩阵。最后的展开式是一个关于HLS的一个方程，我们想要让残差最小，也就是在方程的极小值处取值，因此我们对上式求偏导令等式两边为零，最终的结果是：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image017.png" alt="MRC"><br><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image018.png" alt="MRC"></p><p>其中<img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image019.png" alt="MRC">表示为X的伪逆矩阵。对LS算法求一下均方误差可以得到：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image021.png" alt="MRC"></p><p>结果是信噪比（SNR）的倒数，也就是说当信道的信噪比越高，LS算法的估计效果越好，反过来也意味着LS算法易受噪声干扰。从模型的建立也可以看出，若忽略加性白噪声那一项，估计值就等于实际值。</p><p>由于LS算法对噪声的忽略，导致LS在实际的应用上估计误差较大，所以我们考虑另一种算法即MMSE算法。不像LS算法通过对导频信号的估计与原信号之间的差值来取得信道估计的最佳，MMSE直接对信道的冲激响应进行估计，然后通过信道响应的估计与真实信道响应之间的差值来取得最佳，这也就考虑到信道的多种特质（包括噪声）。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image022.png" alt="MRC"></p><p>最小均方误差算法的思路就是实现信道估计结果与信道响应的真实值之间的均方误差达到最低值。我们假设一个矩阵M使得MY能够逼近发射信号X，令信道响应估计矩阵HMMSE为MY，均方差也就是</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image023.png" alt="MRC"></p><p>这是一个关于M矩阵的函数，我们想让均方差取得极小值也就是要令偏导为0。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image024.png" alt="MRC"></p><p>发现M矩阵是真实信道矩阵冲激响应与接收端信号的互相关矩阵乘上接收端信号自相关矩阵的逆。最后信道响应估计矩阵由等式HMMSE &#x3D; MY得出</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image025.png" alt="MRC"></p><p>MMSE 信道估计算法相对于前面的 LS 算法,最大的改进之处在于消除噪声对信道估计的不良影响,能够实现更为精准的信道估计效果。但是我们从算法的思想中也可以发现，MMSE算法是基于真实信道的自相关矩阵实现的，算法要求信道的统计先验信息，而这往往需要很大的工作量，而且大量的矩阵运算也导致运算的复杂度增大以及算力的需求。</p><hr><p>总结一下，上面两种算法对于信道估计在某些层面上都有较好的表现，LS算法是通过假定一个信道响应HLS，通过将导频通过假设的信道响应与接收端实际接收的导频之间的均方差来估计信道响应，这种假设忽略了信道中噪声的影响。而MMSE算法通过假设一个矩阵M，假定信道响应等于接收端的导频乘上矩阵M即MY，通过真实信道响应与估计的信道响应之间的均方差来估计信道响应，这种假设考虑到信道中的噪声提高了精度，但是需要先验条件即真是信道的自相关矩阵。</p><h2 id="压缩感知"><a href="#压缩感知" class="headerlink" title="压缩感知"></a>压缩感知</h2><p>压缩感知基于信号的稀疏性。该技术的原理是:首先求取得到一个域,它可以实现将原始信号转换至此域后能展现出信号的稀疏性质,完成原始信号的稀疏变换;然后为变换得来的稀疏信号寻找合适的观测矩阵,形成较低维度的信号;最后以低采样的代价,应用重构算法把原来的信号估计出来,回到稀疏域进行处理。例如，信号通过无线信道到达基站的天线阵列，从到达的角度考虑，实际信号到达的角度很有限，在角度域上呈现出稀疏性。</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image026.png" alt="MRC"></p><p>如果信号本身不具有某些稀疏性，则利用某一正交基实现线性的稀疏转变：</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image028.png" alt="MRC"></p><p>X是原始的N为信号向量，<img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image029.png" alt="thi">是稀疏变化矩阵，<img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image031.png" alt="theta">是完成转变的稀疏信号。完成信号的稀疏转变后的第二部就是进行测量矩阵的设计问题，将上一步完成的稀疏信号与测量矩阵相乘的目的是将信号降维。（去除冗余的信息）</p><p><img src="https://raw.githubusercontent.com/allforkarina/embadded_image/refs/heads/master/image033.png" alt="MRC"></p><p>测量矩阵×稀疏变换矩阵得到了A即感知矩阵。原信号是一个N维的信号，而感知矩阵是一个M×N的矩阵，也就是说实现了降维，后续只需要借助M维信号就可以实现最终的原始信号的恢复。</p>]]></content>
      
      
      <categories>
          
          <category> 5G </category>
          
          <category> 通感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Channel state infomation(CSI) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识无线通信——5G 信道估计</title>
      <link href="/2025/04/02/research/Knowing_5G/"/>
      <url>/2025/04/02/research/Knowing_5G/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是无线通信"><a href="#什么是无线通信" class="headerlink" title="什么是无线通信"></a>什么是无线通信</h1><p>你在你的手机微信上编辑了一段文字，轻点发送，远在天边的亲朋好友便能够几乎瞬时的接收到你讯息，这固然很好。但是你是否想象过，这个传输的过程是如何实现的？可能你知道，手机向手机基站发送信息，然后基站之间再进行传输，最后由基站向手机对面的人发送消息。那么，现在请你抬头，看看你周围，你是否生活在“盘丝洞”之中。我相信正常的答案是否的（如果你说yes，那你很厉害哟），这就是我们所说的无线通信。这是一个堪称伟大的科技手段，要是信号都只能通过光纤、信号线传输，那我们就真的生活在盘丝洞之中了（!_!）我们现在常用的移动设备像手机、电脑、电视这些，都配备有天线，在基站安装这几十上百的天线构成阵列来接受我们向他发送的信息（后面统称为信号）。</p><p>那你可能会说，就这？你一根天线、我一根天线就能解决的事情，能称得上伟大？当然不是这么简单，你在生活中不难发现，向前推一辆车，过一会他就会自己停下来；向前说话，声音却像是从前面传来。这些说明两点：</p><ol><li>日常生活中存在阻力，或者说衰减，空中传递的信号也不例外会受到衰减，导致从手机到基站的信号的质量往往不如手机端刚发出。</li><li>信号不是像一根线一样固定一个方向传播，而是像声波一样向四周扩散的传播，碰到物体也会反射。现实生活中的反射物更加多，这导致你发出的信号在传播过程中会变成2个、4个、8个甚至更多，这些信号传输到基站就会产生诸多问题，比如哪个信号才是你手机发出的？不同信号之间的到达时间还不同，可能导致通信的延迟。</li></ol><p>无论是上面信号的衰减还是反射导致多径（后续称反射导致的多个信号为多径）都会造成信号延时、信号错乱或者丢包的现象。这也就引起科学家们对无线信号传输的介质（后续我们称为信道）的研究热情，也就是我们所说的信道估计。</p><h1 id="什么是信道"><a href="#什么是信道" class="headerlink" title="什么是信道"></a>什么是信道</h1><p>通过上面的简单讲述，我们知道了信号传输需要借助信道来进行，但是信道是什么？简单来说，信道就是信息传输的“道路”，它决定了你的信号在传输过程中会遇到哪些“坑坑洼洼”，以及它最终能否顺利到达终点。信道可以按照物理性质进一步细分成两大类：</p><ol><li><strong>有线信道</strong>：你可以把它理解成现实生活中的“高速公路”，光纤、电缆等物理介质就像是坚固的公路，保证了信号可以稳定传输。</li><li><strong>无线信道</strong>：它更像是一条“空中航线”，信号依靠电磁波在空中传播，不需要任何实体的介质支撑，但也因此容易受到干扰。</li></ol><p>而我们的手机信号在绝大部分的情况下是按照无线的方式进行传输的，而无线信道不像有线信道那样受物理线路保护，它在现实环境中会受到各种因素的影响，导致信号在传输过程中变得“崎岖不平”。那么我们为了更好的传输信号，我们就需要研究无线信道的一些特性。</p><h3 id="衰弱"><a href="#衰弱" class="headerlink" title="衰弱"></a><strong>衰弱</strong></h3><p>你有没有试过在一个房间里走动时，手机的信号时好时坏？这就是衰落的表现。衰落的原因有很多，比如信号在传播过程中遇到障碍物（墙壁、建筑物等），或者随着传播距离的增加，能量逐渐减少。我们通常把衰落分成两类：</p><ol><li><strong>大尺度衰落</strong>：影响的是信号的整体强度，和传播距离、环境密集程度有关。比如，你站在空旷的草原上，手机信号可能很好；但如果你进入高楼大厦的电梯，信号可能会瞬间变差。</li><li><strong>小尺度衰落</strong>：影响的是信号的细微波动，通常是因为多条路径的信号相互干扰，比如你在城市的街道上走动时，信号可能会在不同建筑物间反射，导致质量不稳定。</li></ol><h3 id="多径效应"><a href="#多径效应" class="headerlink" title="多径效应"></a><strong>多径效应</strong></h3><p>想象一下你在山谷中大喊一声，你的声音会经过不同路径反射回来，形成“回声”。无线信号的情况也是如此——信号在传播过程中，会因为碰到建筑物、树木、地面等产生反射、折射、散射等现象，从而形成多个到达接收端的路径。问题是，不同路径的信号传播时间不一样，到达接收端时可能会相互叠加或抵消，导致信号失真。这种现象被称为多径效应。多径效应会导致两种衰落：</p><ol><li>平坦衰落：如果信号的带宽较小，整个频段的信道影响几乎相同，衰落不会太严重。</li><li>频率选择性衰落：如果信号的带宽较大，不同频率的信号分量会受到不同程度的衰落，从而导致接收信号的畸变。</li></ol><h3 id="多普勒效应"><a href="#多普勒效应" class="headerlink" title="多普勒效应"></a><strong>多普勒效应</strong></h3><p>如果你坐在路边，听着远处驶来的救护车警笛声，你会发现声音的频率在接近时变高，远离时变低。这就是多普勒效应。在无线通信中，如果信号的发射端或接收端在运动（比如你在开车时打电话），信号的频率会发生偏移，影响通信质量。多普勒效应带来的主要影响是：</p><ol><li><strong>频率偏移</strong>：信号的频率发生变化，可能会导致解调困难。</li><li><strong>快衰落</strong>：当信道的变化速度比信号的变化快时，你在传输一个信号符号的时候，还没传完信道的性质就发生了改变，信号就会迅速失真，影响通信的稳定性。</li></ol><p>无线信道是信息传输的“无形道路”，但它并不总是平坦顺畅的。衰落、多径效应、多普勒效应这些问题，使得无线信号在传输过程中会出现各种不可预测的变化。这也正是科学家们研究信道特性的原因——他们希望找到更好的方法来对抗信道的不利影响，让无线通信变得更加稳定高效。那么，如何才能让信号在复杂的无线环境下依然保持良好的质量呢？别着急，这就是我们下一步要讨论的话题——信道估计！</p><h1 id="什么是信道估计（CSI）"><a href="#什么是信道估计（CSI）" class="headerlink" title="什么是信道估计（CSI）"></a>什么是信道估计（CSI）</h1><p>我在上面通过一种举例子的方式带你简要的理解了一下什么是无线通信以及我们为什么要做信道估计，下面我从学术一点的角度上解释什么是信道估计、为什么需要信道估计，以及信道估计有什么用（作者也是初学者，仅作为参考以及补充）？信道估计，顾名思义是对信道参数进行的一种估计。由于信道的不确定性，我们通常采用统计的角度对信道的一些影响信号传输的参数进行估计，比如衰减、时延等等。那我们为什么需要信道估计？我还是举例进行说明，假设一个用户向基站传输10个信号，每个信号经历完全相同的信道（也就是说信道对信号的影响完全一样），如果我不做信道估计，那基站每接收一个信号都要对这个信号进行一个信道影响的消除，这对于基站这种大吞吐量的应用场景显然不合理。如果基站对第一个信号做信道估计，知道了信道对信号的冲激响应是幅度衰减为1&#x2F;2、相位延后10，那么后续的9个信号基站可以直接给一个2倍的增益，然后将相位提前10以此消除信道的干扰，如此就节省了资源又提高了效率。</p><p>后续科学家们通过对信道估计得到的参数进行研究，推出了许多的算法，发现可以通过CSI得到信号从发出到达基站的时间、信号到基站使被接收的角度等，由此衍生了CSI得出信道响应用于定位用户的功能等。</p>]]></content>
      
      
      <categories>
          
          <category> 5G </category>
          
          <category> 通感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5G </tag>
            
            <tag> Channel state infomation(CSI) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wi-Fi Backscatter communication</title>
      <link href="/2025/03/18/research/Wi-Fi%20Backscatter%20communication/"/>
      <url>/2025/03/18/research/Wi-Fi%20Backscatter%20communication/</url>
      
        <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This article is about a new way of communication for edge IoT devices. Aims at transmitting information of sensors without consuming energy or even store energy for sensing environment.</p><p>It is a great method to deal with situation which may encounter some problems like short-energy.</p><p>We realise this method based on 802.11.ac frame structure, using a mcu controling RFID switch to change the resist value, which cause the changing in phase of the Wi-Fi packets.</p><p>The <strong>180 degrees</strong> inversion in phase of Wi-Fi packets will destroy the mac frame of signal transmitted in Los(Line of sight) as superimposed by the inversed Wi-Fi packets, which cause the <strong>0 bits</strong> in ACK block.</p><p>So we can get the information that we modulated onto the Wi-Fi packets without transmitting it by decoding the ACK blocks. That is the main concept of what we do.</p><h2 id="什么是WiFi反向散射系统（WiFi-BackScatter-Communication-System）"><a href="#什么是WiFi反向散射系统（WiFi-BackScatter-Communication-System）" class="headerlink" title="什么是WiFi反向散射系统（WiFi BackScatter Communication System）"></a>什么是WiFi反向散射系统（WiFi BackScatter Communication System）</h2><p>直观点说，Backscatter 通信是一种极低功耗通信方式，设备不用主动“发射信号”，而是通过反射已有的无线信号（比如WiFi）来传递数据。基本原理是假设空气中已经存在一个无线信号（比如 WiFi 路由器发出的信号），背散射设备（比如标签）不自己发射信号，而是通过调节天线的阻抗，选择性地反射或不反射这些信号。接收端设备（比如智能手机）检测这些变化，从中恢复出数据。</p><p>可以理解为有人一直在用手电筒（WiFi 信号）照一个镜子，这个镜子（WiFi Tag）可以控制自己是反光还是吸光（反射或不反射信号），你站在另一边看，就能根据“亮”或“不亮”来解码信息。这样的通信方式可以实现超低功耗（甚至可以完全无电池），完全适配物联网（IoT）设备、RFID 标签等。</p><h2 id="如何理解WiFi-Backscatter所谓的破坏"><a href="#如何理解WiFi-Backscatter所谓的破坏" class="headerlink" title="如何理解WiFi Backscatter所谓的破坏"></a>如何理解WiFi Backscatter所谓的破坏</h2><ol><li><p>理解WiFi Tag的工作方式我们就需要先知道WiFi是怎么传输数据的。我们都知道数据在电脑中是呈现为0101这样的二进制比特流的，每8个bit构成一个字节。而WiFi将至少一个字节包装成一个子帧（subFrame），Tag就是以子帧为基本单位实现破坏的功能的（也就是说破坏很多个bit）。已知我们手机（UE）向路由器发送数据，如果路由器成功接收了那么就会回应UE一个BA（Block ACK）。如果接收到了，在BA对应的帧位置上会显示为1.假设我们原本要传输一共10个子帧，如果AP（例如路由器）全部都接收到了，那么在Wireshark（一个抓包软件）上就会显示BA对应位置有10个1（1表示成功接收）。</p></li><li><p>有的人想你把用户发出的数据破坏了，那用户不就丢包了吗？这时候，我们就要理解多径。信号在空气中不是只沿一条直线传播的，而是在一定范围的角度范围内都有的，这也导致了多径的产生。假设我们现在发出的信号只有两条路径</p></li></ol><p><img src="https://github.com/allforkarina/embadded_image/blob/master/20250406065801171.png?raw=true" alt="Multiple Path"></p><p>其中从Helper到Reader的路径是最短的直线（称为LOS）。另一条路径的信号可能由于外界环境的反射（跟声波一样），路径长度更长，使得信号到达Reader时相比于LOS有一个时延，而这个时延就会导致信号的相位发生改变（改变180°就相当于反向）。</p><ol start="3"><li>那么我们如何实现这个相位反向呢，靠运气等环境自己使信号相位改变吗？下面我们就要讲硬件实现思路。我们都知道信号波长与频率之间的关系：</li></ol><p><img src="https://github.com/allforkarina/embadded_image/blob/master/20250406065807770.png?raw=true" alt="Multiple Path"></p><p>一般频率我们已知，那么我们也就能够算出来信号的波长。一个波长从公式的角度等价于一个完整周期，等价于一个360°的相位偏移，那么我们可以设计一个标签我们的Tag在信号的传输路径中间，用一个开关切换路径，一共两条，一条路径长度是一个完整波长，那么信号通过Tag的天线进入标签再出来经过了一个完整的周期，可以认为相位不变；另一条路径的长度是半个波长，同理信号进入Tag再出来相位改变了180°，与原来的信号反向。相当于我们人为的将多径的长度差变成了一个波长。</p><h2 id="WiFi-Tag调制的具体实现流程"><a href="#WiFi-Tag调制的具体实现流程" class="headerlink" title="WiFi Tag调制的具体实现流程"></a>WiFi Tag调制的具体实现流程</h2><p>假设我们的手机和WiFi路由器在进行数据交换，在一种理想的情况下我们的信号质量很好，没有丢包的情况。我们在中间加入WiFi Backscatter Tag，并且以10KHz的频率去切换开关。假设我们手机网卡发送子帧的速率也是10K个子帧每秒，那么我们可以假设在LOS（即前面说的直射路径）中传输的信号（调制了10K个子帧）的相位都是0°（相对的）。然后在有WiFi Tag的另一条路径，信号调制的10K个子帧有5K个相位为360°，有5K个相位为180°。相位为360°的跟LOS的信号叠加在一起由于同相，对原来的信号起到增强的作用，接收端全是1（参考基础知识1）而相位为180°的跟LOS的信号反向，叠加到一起刚好相互抵消了，那么接收端就是全0（理想情况）。那么我们就可以通过这个0、1之间的交替得出我们WiFi Tag要调制的信号，如下：</p><p><img src="https://github.com/allforkarina/embadded_image/blob/master/20250406065816107.png?raw=true" alt="Multiple Path"></p><hr><p>以下是，我们如何通过软件实现对上述流程的仿真以及体现。</p><h2 id="Introduction-of-environment"><a href="#Introduction-of-environment" class="headerlink" title="Introduction of environment"></a>Introduction of environment</h2><p>In this section I will briefly give a introduction of the hardware requirement, software requirement and the system environment which we based on.</p><ul><li>Firstly, we setup ubuntu 22.04 version in real PC because one of the software we used requires real NIC(Network Interface Card).</li><li>Secondly, we need a low-speed, high-frequency RFID switch which also required low power consuming. Together with a mini-mcu to control it, which means you need a energy provided method.</li><li>thirdly, you may need wireshark to get packets info at initial, then you need PicoScenes as CSI Tool to get ACK block. Also you need pktgen which is provided by Linux kernel.</li></ul><h2 id="Process-of-experiment"><a href="#Process-of-experiment" class="headerlink" title="Process of experiment"></a>Process of experiment</h2><p>Let’s start from equiping your computer with necessary software. First thing is that you need an PC with a Ubuntu system at version 22.04. Then after your configuration of basic settings, you can start from ‘Pktgen’ which is already in your system software and all you need to do is activate it using your root privacy. The detail of the overall process please follow the blog: <a href="https://blog.csdn.net/qq_41596356/article/details/134004341">How to use Pktgen-powerful Wlan test tools</a>. Notice: once you reboot your system, you need to activate the Pktgen using root privacy again.</p><p>Pktgen, used as packet genration and transmission tool, you can send packet which you configure. You then need a software to receive packet and evaluate the infomation of signal-channel through the packet you received. Here I recommend using wireshark to capture packet, and using PicoScenes to get CSI. The installation steps as followed.<br>For Wireshark, you can visit its <a href="https://github.com/wireshark/wireshark">github repository</a> and paste the command at your terminal. The second one PicoScenes, you can download it following this <a href="https://www.bing.com/search?form=QBLH&q=PicoScenes">blog</a>, or visit the <a href="https://ps.zpj.io/">official docs</a> to get to know how to install, how to use it and what is the meaning of CSI values.</p>]]></content>
      
      
      
        <tags>
            
            <tag> BackScatter </tag>
            
            <tag> WiFi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于博客的那些事o.O</title>
      <link href="/2025/03/18/etc/hello-world/"/>
      <url>/2025/03/18/etc/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-的使用指引"><a href="#Hexo-的使用指引" class="headerlink" title="Hexo 的使用指引"></a><em>Hexo</em> 的使用指引</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h1 id="如何快速入门-Markdown"><a href="#如何快速入门-Markdown" class="headerlink" title="如何快速入门 Markdown"></a>如何快速入门 <em><strong>Markdown</strong></em></h1><p><em>Markdown</em>，作为一种基于文本的快速格式化编写语法，相较于传统的文本编译器如 <em>Word</em>、<em>WPS</em> 这些基于图形化的 <em>format</em> 工具，只需要简单的几个字符便可以便可实现 <em>斜体</em>、<strong>粗体</strong>以及<code>高亮</code>等特殊 <em>format</em>。</p><p>而对比起 <em>Latex</em>，<em>Markdown</em> 虽然功能不如其强大，但是由于 <em>Latex</em> 需要更长的学习周期、繁杂的公式和文本表达式，以及较慢的编译速度，对于想快速编写 <em>blog</em> 或者 <em>diary</em> 的新手，我个人更加推荐使用 <em>Markdown</em>。下面我将带领你们快速入手 <em>Markdown</em>，让我们省去一些没用的废话，<em><strong>Let’s start it!!!</strong></em></p><h2 id="清晰分明的标题分级"><a href="#清晰分明的标题分级" class="headerlink" title="清晰分明的标题分级"></a>清晰分明的标题分级</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># | ## | ### | ####</span></span><br></pre></td></tr></table></figure><p>上述，便是 <em>Markdown</em> 中定义的标题分级方式，怎么样，是不是非常的简单清晰！只要你想，你可以不断地叠加<code>#</code>来实现多级标题，当然这样的结果可能只是标题比你的正文还要不起眼。</p><h2 id="强大、快捷的特殊-Format"><a href="#强大、快捷的特殊-Format" class="headerlink" title="强大、快捷的特殊 Format"></a>强大、快捷的特殊 <em>Format</em></h2><p>当你使用 <em>Word</em> 撰写一篇文章的时候，如果你想将某段文字变成粗体来起到强调的作用，你大概率会选中文字，移动你的鼠标到<code>B</code>的粗体标识上，Click一声，实现加粗的效果；如果你是高手，那么你可能会使用快捷键来加粗文字，但是在 <em>Markdown</em> 的世界里，你只需要</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**加粗的文字**</span></span><br></pre></td></tr></table></figure><p>便可以实现 <strong>加粗</strong> 的效果。</p><hr><p>同理，像 <strong>加粗</strong> 这样的方便快捷的 <em>Format</em> 还有 <em>斜体</em>、<code>代码</code>、<del>删除线</del>等等。他们分别对应的格式为</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">_斜体_</span> | <span class="code">`代码`</span> | ~~删除线~~</span><br></pre></td></tr></table></figure><h2 id="常用的文本结构"><a href="#常用的文本结构" class="headerlink" title="常用的文本结构"></a>常用的文本结构</h2><p>这时候有人会问了，博主博主，你的文本 <em><code>format</code></em> 还是太普通了，有没有不吃操作更强大的功能？有的有的！比如，你可以快速的自定义一个列表：</p><table><thead><tr><th></th><th>col1</th><th>col2</th></tr></thead><tbody><tr><td>row1</td><td>—-</td><td>—-</td></tr><tr><td>row2</td><td>—-</td><td>—-</td></tr></tbody></table><p>像上面这个2x2的表格只需要简单的定义方式，如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|      | col1 | col2 |</span><br><span class="line">| ---- | ---- | ---- |</span><br><span class="line">| row1 | ---- | ---- |</span><br><span class="line">| row2 | ---- | ---- |</span><br></pre></td></tr></table></figure><p>其中的<code>| ---- | ---- | ---- |</code>，也就是第二行，作用是区分表格的内容以及每一列的Title. </p><hr><p>当然，你可结合我们上一节的特殊format来自定义你的表格，像</p><table><thead><tr><th></th><th align="left">col1</th><th align="left">col2</th></tr></thead><tbody><tr><td>row1</td><td align="left"><code>code</code></td><td align="left"><em>Italic</em></td></tr><tr><td>row2</td><td align="left"><strong>Bold</strong></td><td align="left"><del>Dele</del></td></tr></tbody></table><hr><p>或许你正在尝试编写一个技术性的博客，你对如何将源码展示开源而感到头痛。直接复制粘贴，格式不对，不够优美；截图呢，虽然有高亮，但是没有办法<code>ctrl + c\v</code>. 对此，我强烈建议你使用 <em>Markdonw</em> 的代码块Structure</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="code">``` (language)</span></span><br><span class="line"><span class="code">(Warning: $ 只是用于防止代码块在我定义的markdown代码块中生效，实际使用只需要上下用```</span>标注这是一个代码块即可生效)    </span><br><span class="line">$ <span class="code">```</span></span><br></pre></td></tr></table></figure><p>括号内的Language表示，<em>Markdown</em> 的代码块支持多种不同的语言，像python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.random.randn(<span class="number">1</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><hr><p>或者你需要一个<code>TODO List</code>来帮助你管理你的事项，那么你可能需要使用到列表。</p><p><em>Markdown</em> 支持多种不同的列表，例如数字列表：</p><ol><li>This is the first list.</li><li>This is the second list</li></ol><p>又或者是点列表：</p><ul><li>list here.</li><li>list here.</li></ul><h2 id="特殊的玩法"><a href="#特殊的玩法" class="headerlink" title="特殊的玩法"></a>特殊的玩法</h2><p><em>Markdown</em> 不仅仅是提供一个方便快捷的文本编辑方式，它还有一些特殊的使用方法来装点你的Markdown文本。</p><ul><li><em><strong>Emoji</strong></em>：✅、😶‍🌫️ etc.</li></ul><hr><p>以上就是比较常用的Markdown使用格式，希望这个指引能够对你有帮助。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
